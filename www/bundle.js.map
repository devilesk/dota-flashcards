{
  "version": 3,
  "sources": [
    "node_modules/browser-pack/_prelude.js",
    "node_modules/bit-array-js/BitArray.js",
    "node_modules/dota-hero-calculator/src/js/herocalc/AbilityModel.js",
    "node_modules/dota-hero-calculator/src/js/herocalc/BuffViewModel.js",
    "node_modules/dota-hero-calculator/src/js/herocalc/StatModel.js",
    "node_modules/dota-hero-calculator/src/js/herocalc/buffs/BuffModel.js",
    "node_modules/dota-hero-calculator/src/js/herocalc/buffs/buffOptionsArray.js",
    "node_modules/dota-hero-calculator/src/js/herocalc/buffs/debuffOptionsArray.js",
    "node_modules/dota-hero-calculator/src/js/herocalc/constants.js",
    "node_modules/dota-hero-calculator/src/js/herocalc/hero/DamageTypeColor.js",
    "node_modules/dota-hero-calculator/src/js/herocalc/hero/HeroDamageMixin.js",
    "node_modules/dota-hero-calculator/src/js/herocalc/hero/HeroModel.js",
    "node_modules/dota-hero-calculator/src/js/herocalc/hero/HeroOption.js",
    "node_modules/dota-hero-calculator/src/js/herocalc/hero/TalentController.js",
    "node_modules/dota-hero-calculator/src/js/herocalc/hero/diffProperties.js",
    "node_modules/dota-hero-calculator/src/js/herocalc/hero/heroOptionsArray.js",
    "node_modules/dota-hero-calculator/src/js/herocalc/hero/nextLevelExp.js",
    "node_modules/dota-hero-calculator/src/js/herocalc/hero/talentAbilityMap.js",
    "node_modules/dota-hero-calculator/src/js/herocalc/hero/totalExp.js",
    "node_modules/dota-hero-calculator/src/js/herocalc/herocalc_abilitydata.js",
    "node_modules/dota-hero-calculator/src/js/herocalc/herocalc_knockout.js",
    "node_modules/dota-hero-calculator/src/js/herocalc/illusion/illusionData.js",
    "node_modules/dota-hero-calculator/src/js/herocalc/inventory/BasicInventoryViewModel.js",
    "node_modules/dota-hero-calculator/src/js/herocalc/inventory/InventoryViewModel.js",
    "node_modules/dota-hero-calculator/src/js/herocalc/inventory/ItemInput.js",
    "node_modules/dota-hero-calculator/src/js/herocalc/inventory/itemBuffOptions.js",
    "node_modules/dota-hero-calculator/src/js/herocalc/inventory/itemDebuffOptions.js",
    "node_modules/dota-hero-calculator/src/js/herocalc/inventory/itemOptionsArray.js",
    "node_modules/dota-hero-calculator/src/js/herocalc/inventory/itemsWithActive.js",
    "node_modules/dota-hero-calculator/src/js/herocalc/inventory/levelItems.js",
    "node_modules/dota-hero-calculator/src/js/herocalc/inventory/stackableItems.js",
    "node_modules/dota-hero-calculator/src/js/herocalc/inventory/validItems.js",
    "node_modules/dota-hero-calculator/src/js/herocalc/lib/knockout.mapping.js",
    "node_modules/dota-hero-calculator/src/js/herocalc/lib/knockout.wrap.js",
    "node_modules/dota-hero-calculator/src/js/herocalc/talents/cooldownTalents.json",
    "node_modules/dota-hero-calculator/src/js/herocalc/util/extend.js",
    "node_modules/dota-hero-calculator/src/js/herocalc/util/findWhere.js",
    "node_modules/hammerjs/hammer.js",
    "node_modules/lodash/_Symbol.js",
    "node_modules/lodash/_baseGetTag.js",
    "node_modules/lodash/_freeGlobal.js",
    "node_modules/lodash/_getRawTag.js",
    "node_modules/lodash/_objectToString.js",
    "node_modules/lodash/_root.js",
    "node_modules/lodash/isArray.js",
    "node_modules/lodash/isObjectLike.js",
    "node_modules/lodash/isString.js",
    "node_modules/lodash/isUndefined.js",
    "node_modules/rollbar/dist/rollbar.umd.min.js",
    "src/js/URI.js",
    "src/js/index.js",
    "src/js/ko.bindingHandlers.checkbox.js",
    "src/js/ko.bindingHandlers.radio.js",
    "src/js/ko.extenders.urlSync.js",
    "src/js/responsivevoice.js",
    "src/js/rollbar.js",
    "src/js/slider.js"
  ],
  "names": [],
  "mappings": "AAAA;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACrLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACj8EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9MA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACbA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzpBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3vBA;AACA;AACA;AACA;AACA;AACA;AACA;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACdA;AACA;AACA;;ACFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/cA;AACA;AACA;;ACFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACp/GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACnCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACnHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AC7KA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACn8CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AC7BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACfA;;ACAA;;ACAA;;ACAA;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACryBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AChNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnlFA;AACA;AACA;AACA;AACA;AACA;AACA;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC5BA;AACA;AACA;AACA;AACA;;;;ACJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtBA;AACA;AACA;;ACFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC9rEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AC7pBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACzEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AC5CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AC1CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA",
  "file": "generated.js",
  "sourceRoot": "",
  "sourcesContent": [
    "(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=\"function\"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error(\"Cannot find module '\"+i+\"'\");throw a.code=\"MODULE_NOT_FOUND\",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u=\"function\"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()",
    "var btoa = (typeof window !== \"undefined\" ? window['btoa'] : typeof global !== \"undefined\" ? global['btoa'] : null);\nvar atob = (typeof window !== \"undefined\" ? window['atob'] : typeof global !== \"undefined\" ? global['atob'] : null);\n\nvar BitArray = (function() {\n    // converts binary string to a hexadecimal string\n    // returns an object with key 'valid' to a boolean value, indicating\n    // if the string is a valid binary string.\n    // If 'valid' is true, the converted hex string can be obtained by\n    // the 'result' key of the returned object\n    function binaryToHex(s) {\n        var i, k, part, accum, ret = '';\n        for (i = s.length - 1; i >= 3; i -= 4) {\n            // extract out in substrings of 4 and convert to hex\n            part = s.substr(i + 1 - 4, 4);\n            accum = 0;\n            for (k = 0; k < 4; k += 1) {\n                if (part[k] !== '0' && part[k] !== '1') {\n                    // invalid character\n                    return {\n                        valid: false\n                    };\n                }\n                // compute the length 4 substring\n                accum = accum * 2 + parseInt(part[k], 10);\n            }\n            if (accum >= 10) {\n                // 'A' to 'F'\n                ret = String.fromCharCode(accum - 10 + 'A'.charCodeAt(0)) + ret;\n            } else {\n                // '0' to '9'\n                ret = String(accum) + ret;\n            }\n        }\n        // remaining characters, i = 0, 1, or 2\n        if (i >= 0) {\n            accum = 0;\n            // convert from front\n            for (k = 0; k <= i; k += 1) {\n                if (s[k] !== '0' && s[k] !== '1') {\n                    return {\n                        valid: false\n                    };\n                }\n                accum = accum * 2 + parseInt(s[k], 10);\n            }\n            // 3 bits, value cannot exceed 2^3 - 1 = 7, just convert\n            ret = String(accum) + ret;\n        }\n        return {\n            valid: true,\n            result: ret\n        };\n    }\n\n    // converts hexadecimal string to a binary string\n    // returns an object with key 'valid' to a boolean value, indicating\n    // if the string is a valid hexadecimal string.\n    // If 'valid' is true, the converted binary string can be obtained by\n    // the 'result' key of the returned object\n    function hexToBinary(s) {\n        var i, k, part, ret = '';\n        // lookup table for easier conversion. '0' characters are padded for '1' to '7'\n        var lookupTable = {\n            '0': '0000',\n            '1': '0001',\n            '2': '0010',\n            '3': '0011',\n            '4': '0100',\n            '5': '0101',\n            '6': '0110',\n            '7': '0111',\n            '8': '1000',\n            '9': '1001',\n            'a': '1010',\n            'b': '1011',\n            'c': '1100',\n            'd': '1101',\n            'e': '1110',\n            'f': '1111',\n            'A': '1010',\n            'B': '1011',\n            'C': '1100',\n            'D': '1101',\n            'E': '1110',\n            'F': '1111'\n        };\n        for (i = 0; i < s.length; i += 1) {\n            if (lookupTable.hasOwnProperty(s[i])) {\n                ret += lookupTable[s[i]];\n            } else {\n                return {\n                    valid: false\n                };\n            }\n        }\n        return {\n            valid: true,\n            result: ret\n        };\n    }\n\n    function hexToBase64(str) {\n        return btoa(String.fromCharCode.apply(null,\n            str.replace(/\\r|\\n/g, \"\").replace(/([\\da-fA-F]{2}) ?/g, \"0x$1 \").replace(/ +$/, \"\").split(\" \")));\n    }\n\n    function base64ToHex(str) {\n        for (var i = 0, bin = atob(str.replace(/[ \\r\\n]+$/, \"\")), hex = []; i < bin.length; ++i) {\n            var tmp = bin.charCodeAt(i).toString(16);\n            if (tmp.length === 1) tmp = \"0\" + tmp;\n            hex[hex.length] = tmp;\n        }\n        return hex.join(\"\");\n    }\n\n    function BitArray(size) {\n        this.size = size;\n        this.data = [];\n        for (var i = 0; i < size; i++) {\n            this.data.push(false);\n        }\n    }\n\n    BitArray.prototype.set = function(index) {\n        this.data[index] = true;\n    };\n\n    BitArray.prototype.clear = function(index) {\n        this.data[index] = false;\n    };\n\n    BitArray.prototype.value = function(index, value) {\n        if (value === undefined) return this.data[index];\n        this.data[index] = !!value;\n    };\n\n    BitArray.prototype.toBase64 = function() {\n        var s = '';\n        for (var i = 0; i < this.data.length; i++) {\n            s = s + (this.data[i] ? '1' : '0');\n        }\n        return hexToBase64(binaryToHex(s).result);\n    };\n\n    BitArray.prototype.fromBase64 = function(value) {\n        value = value || '';\n        var h = base64ToHex(value);\n        var b = hexToBinary(h).result;\n        this.data = [];\n        for (var i = 0; i < this.size; i++) {\n            this.data[i] = b.charAt(i) === '1';\n        }\n    };\n    \n    BitArray.prototype.toBase64UrlSafe = function() {\n        return this.urlEncode(this.toBase64());\n    };\n    \n    BitArray.prototype.fromBase64UrlSafe = function(value) {\n        return this.fromBase64(this.urlDecode(value));\n    };\n    \n    BitArray.prototype.urlEncode = function(value) {\n        value = value || '';\n        return value.replace(/\\+/g, '-').replace(/\\//g, '_').replace(/=/g, '');\n    };\n    \n    BitArray.prototype.urlDecode = function(value) {\n        value = value || '';\n        var incoming = value.replace(/-/g, '+').replace(/_/g, '/');\n        \n        switch (value.length % 4) {\n            case 2: incoming += \"==\"; break;\n            case 3: incoming += \"=\"; break;\n        }\n        return incoming;\n    };\n    \n    return BitArray;\n})();\n\nmodule.exports = BitArray;",
    "'use strict';\nvar ko = require('./herocalc_knockout');\nvar abilityData = require(\"./herocalc_abilitydata\");\nvar TalentController = require(\"./hero/TalentController\");\nvar StatModel = require(\"./StatModel\");\n\nvar AbilityModel = function (a, h) {\n    var self = this;\n    self.hero = h;\n    self.abilityData = abilityData;\n    self.hasScepter = ko.observable(false);\n    self.isShapeShiftActive = ko.observable(false);\n    self.abilities = a;\n    self._abilities = self.abilities();\n    for (var i = 0; i < self.abilities().length; i++) {\n        self._abilities[i].level = ko.observable(0);\n        self._abilities[i].isActive = ko.observable(false);\n        self._abilities[i].isDetail = ko.observable(false);\n        self._abilities[i].baseDamage = ko.observable(0);\n        self._abilities[i].baseDamageReductionPct = ko.observable(0);\n        self._abilities[i].baseDamageMultiplier = ko.observable(0);\n        self._abilities[i].bash = ko.observable(0);\n        self._abilities[i].bashBonusDamage = ko.observable(0);\n        self._abilities[i].bonusDamage = ko.observable(0);\n        self._abilities[i].bonusDamageOrb = ko.observable(0);\n        self._abilities[i].bonusDamagePct = ko.observable(0);\n        self._abilities[i].bonusDamagePrecisionAura = ko.observable(0);\n        self._abilities[i].bonusDamageReduction = ko.observable(0);\n        self._abilities[i].bonusHealth = ko.observable(0);\n        self._abilities[i].bonusStrength = ko.observable(0);\n        self._abilities[i].bonusStrength2 = ko.observable(0);\n        self._abilities[i].bonusAgility = ko.observable(0);\n        self._abilities[i].bonusAgility2 = ko.observable(0);\n        self._abilities[i].bonusInt = ko.observable(0);\n        self._abilities[i].bonusAllStatsReduction = ko.observable(0);\n        self._abilities[i].damageAmplification = ko.observable(0);\n        self._abilities[i].damageReduction = ko.observable(0);\n        self._abilities[i].evasion = ko.observable(0);\n        self._abilities[i].magicResist = ko.observable(0);\n        self._abilities[i].manaregen = ko.observable(0);\n        self._abilities[i].manaregenreduction = ko.observable(0);\n        self._abilities[i].missChance = ko.observable(0);\n        self._abilities[i].movementSpeedFlat = ko.observable(0);\n        self._abilities[i].movementSpeedPct = ko.observable(0);\n        self._abilities[i].movementSpeedPctReduction = ko.observable(0);\n        self._abilities[i].turnRateReduction = ko.observable(0);\n        self._abilities[i].attackrange = ko.observable(0);\n        self._abilities[i].attackspeed = ko.observable(0);\n        self._abilities[i].attackspeedreduction = ko.observable(0);\n        self._abilities[i].armor = ko.observable(0);\n        self._abilities[i].armorReduction = ko.observable(0);\n        self._abilities[i].healthregen = ko.observable(0);\n        self._abilities[i].lifesteal = ko.observable(0);\n        self._abilities[i].visionnight = ko.observable(0);\n        self._abilities[i].visionday = ko.observable(0);\n    }\n    self.abilityControlData = {};\n    self.abilitySettingsData = function (data, parent, index) {\n        if (self.abilityControlData[data] == undefined) {\n            return self.processAbility(data, parent, index, self.abilityData[data]);\n        }\n        else {\n            return self.abilityControlData[data];\n        }\n    }\n    \n    self.processAbility = function (data, parent, index, args) {\n        var result = {};\n        result.data = [];\n        var v;\n        var v_list = [];\n        for (var i=0; i < args.length; i++) {\n            switch (args[i].controlType) {\n                case 'input':\n                    v = ko.observable(0).extend({ numeric: 2 });\n                    v.controlValueType = args[i].controlValueType;\n                    v_list.push(v);\n                    result.data.push({ labelName: args[i].label.toUpperCase() + ':', controlVal: v, controlType: args[i].controlType, display: args[i].display });\n                break;\n                case 'checkbox':\n                    v = ko.observable(false);\n                    v.controlValueType = args[i].controlValueType;\n                    v_list.push(v);\n                    result.data.push({ labelName: args[i].label.toUpperCase() + '?', controlVal: v, controlType: args[i].controlType, display: args[i].display });\n                break;\n                case 'radio':\n                    v = ko.observable(args[i].controlOptions[0].value);\n                    v.controlValueType = args[i].controlValueType;\n                    v_list.push(v);\n                    result.data.push({ labelName: args[i].label.toUpperCase() + '?', controlVal: v, controlType: args[i].controlType, display: args[i].display, controlOptions: args[i].controlOptions });\n                break;\n                case 'method':\n                case 'text':\n                    // single input abilities\n                    if (args[i].controls == undefined) {\n                        if (args[i].noLevel) {\n                            var attributeValue = function (attributeName) {\n                                return {fn: ko.computed(function () {\n                                    var _ability = self.abilities().find(function(b) {\n                                        return b.name == data;\n                                    });\n                                    return self.getAbilityAttributeValue(_ability.attributes, attributeName, 0);\n                                })};\n                            };\n                        }\n                        else {\n                            var attributeValue = function (attributeName) {\n                                return {fn: ko.computed(function () {\n                                    var _ability = self.abilities().find(function(b) {\n                                        return b.name == data;\n                                    });\n                                    return self.getAbilityAttributeValue(_ability.attributes, attributeName, _ability.level());\n                                })};\n                            };\n                        }\n                        var g = attributeValue(args[i].attributeName)\n                        var r = self.getComputedFunction(v, g.fn, args[i].fn, parent, index, self, args[i].returnProperty, undefined, data);\n                        if (args[i].ignoreTooltip) {\n                            var tooltip = args[i].label || args[i].attributeName;\n                        }\n                        else {\n                            var tooltip = self.getAbilityAttributeTooltip(self.abilities()[index].attributes, args[i].attributeName) || args[i].label || args[i].attributeName;\n                        }\n                        result.data.push({ labelName: tooltip.toUpperCase(), controlVal: r, controlType: args[i].controlType, display: args[i].display, clean: g.fn });\n                    }\n                    // multi input abilities\n                    else {\n                        if (args[i].noLevel) {\n                            var attributeValue = function (attributeName) {\n                                return {fn: ko.computed(function () {\n                                    return self.getAbilityAttributeValue(self.abilities()[index].attributes, attributeName, 0);\n                                })};\n                            };\n                        }\n                        else {\n                            var attributeValue = function (attributeName) {\n                                return {fn: ko.computed(function () {\n                                    return self.getAbilityAttributeValue(self.abilities()[index].attributes, attributeName, self.abilities()[index].level());\n                                })};\n                            };\n                        }\n                        var g = attributeValue(args[i].attributeName)\n                        var r = self.getComputedFunction(v_list, g.fn, args[i].fn, parent, index, self, args[i].returnProperty, args[i].controls, data);\n                        if (args[i].ignoreTooltip) {\n                            var tooltip = args[i].label || args[i].attributeName;\n                        }\n                        else {\n                            var tooltip = self.getAbilityAttributeTooltip(self.abilities()[index].attributes, args[i].attributeName) || args[i].label || args[i].attributeName;\n                        }\n                        result.data.push({ labelName: tooltip.toUpperCase(), controlVal: r, controlType: args[i].controlType, display: args[i].display, clean: g.fn });\n                    }\n                    \n                    if (args[i].controlType == 'method') {\n                        v_list.push(r);\n                    }\n                break;\n            }\n        }\n        self.abilityControlData[data] = result;\n        return result;\n    }\n\n    self.getComputedFunction = function (v, attributeValue, fn, parent, index, abilityModel, returnProperty, controls, abilityName) {\n        var _ability = abilityModel.abilities().find(function(b) {\n            return b.name == abilityName;\n        });\n        return ko.pureComputed(function () {                \n            var inputValue;\n            if (controls == undefined) {\n                if (v == undefined) {\n                    inputValue = v;\n                }\n                else if (typeof v() == 'boolean') {\n                    inputValue = v();\n                }\n                else if (v.controlValueType == undefined) {\n                    inputValue = parseFloat(v());\n                }\n                else if (v.controlValueType == 'string') {\n                    inputValue = v();\n                }\n                else {\n                    inputValue = parseFloat(v());\n                }\n            }\n            else {\n                var v_list = [];\n                for (var i=0;i<controls.length;i++) {\n                    switch (typeof v[controls[i]]()) {\n                        case 'boolean':\n                        case 'object':\n                            v_list.push(v[controls[i]]());\n                        break;\n                        default:\n                            v_list.push(parseFloat(v[controls[i]]()));\n                        break;\n                    }\n                }\n                inputValue = v_list;\n            }\n            \n            var returnVal = fn.call(this, inputValue, attributeValue(), parent, index, abilityModel, _ability, TalentController);\n            if (returnProperty != undefined) {\n                _ability[returnProperty](returnVal);\n            }\n            return returnVal;\n        }, this);\n    }\n    \n    self.getAbilityLevelByAbilityName = function (abilityName) {\n        for (var i = 0; i < self.abilities().length; i++) {\n            if (self._abilities[i].name == abilityName) {\n                return self._abilities[i].level();\n            }\n        }\n        return -1;\n    }\n\n    self.getAbilityByName = function (abilityName) {\n        for (var i = 0; i < self.abilities().length; i++) {\n            if (self._abilities[i].name == abilityName) {\n                return self._abilities[i];\n            }\n        }\n        return undefined;\n    }\n\n    self.getAbilityPropertyValue = function (ability, property) {\n        return parseFloat(ko.utils.unwrapObservable(ability[property])[ability.level()-1]);\n    }\n    \n    self.getAttributeBonusLevel = function () {\n        for (var i = 0; i < self.abilities().length; i++) {\n            if (self._abilities[i].name == 'attribute_bonus') {\n                return self._abilities[i].level();\n            }\n        }\n        return 0;        \n    }\n    \n    self.getAllStatsReduction = ko.computed(function () {\n        var sources = new StatModel();\n        for (var i = 0; i < self.abilities().length; i++) {\n            var ability = self._abilities[i];\n            if (ability.level() > 0 && (ability.isActive() || (ability.behavior.indexOf('DOTA_ABILITY_BEHAVIOR_PASSIVE') != -1))) {\n                if (!(ability.name in self.abilityData)) {                    \n                    for (var j = 0; j < self._abilities[i].attributes.length; j++) {\n                        var attribute = self._abilities[i].attributes[j];\n                        /*switch(attribute.name) {\n                            // invoker_quas\n                            case 'bonus_strength':\n                                totalAttribute += parseInt(attribute.value[ability.level()-1]);\n                            break;\n                        }*/\n                    }\n                }\n                else if (ability.bonusAllStatsReduction != undefined) {\n                    // slark_essence_shift\n                    sources.add(ability.bonusAllStatsReduction(), ability.displayname);\n                }\n            }\n        }\n        return sources;\n    });\n    \n    self.getStrengthReduction = ko.computed(function () {\n        var sources = new StatModel();\n        for (var i = 0; i < self.abilities().length; i++) {\n            var ability = self._abilities[i];\n            if (ability.level() > 0 && (ability.isActive() || (ability.behavior.indexOf('DOTA_ABILITY_BEHAVIOR_PASSIVE') != -1))) {\n                if (!(ability.name in self.abilityData)) {                    \n                    for (var j = 0; j < self._abilities[i].attributes.length; j++) {\n                        var attribute = self._abilities[i].attributes[j];\n                        /*switch(attribute.name) {\n                            // invoker_quas\n                            case 'bonus_strength':\n                                totalAttribute += parseInt(attribute.value[ability.level()-1]);\n                            break;\n                        }*/\n                    }\n                }\n                else if (ability.bonusStrength != undefined && ability.name == 'undying_decay') {\n                    // undying_decay\n                    sources.add(-ability.bonusStrength(), ability.displayname);\n                }\n            }\n        }\n        return sources;\n    });\n    \n    self.getStrength = ko.computed(function () {\n        var sources = new StatModel();\n        for (var i = 0; i < self.abilities().length; i++) {\n            var ability = self._abilities[i];\n            if (ability.level() > 0) {\n                if (!(ability.name in self.abilityData)) {\n                    if (ability.isActive() || (ability.behavior.indexOf('DOTA_ABILITY_BEHAVIOR_PASSIVE') != -1)) {\n                        for (var j = 0; j < self._abilities[i].attributes.length; j++) {\n                            var attribute = self._abilities[i].attributes[j];\n                            switch(attribute.name) {\n                                // sven_gods_strength\n                                case 'gods_strength_bonus_str':\n                                    sources.add(parseInt(attribute.value[ability.level()-1]), ability.displayname);\n                                break;\n                            }\n                        }\n                    }\n                }\n                else {\n                    if (ability.bonusStrength != undefined) {\n                        if (ability.isActive() || (ability.behavior.indexOf('DOTA_ABILITY_BEHAVIOR_PASSIVE') != -1)) {\n                            // pudge_flesh_heap,morphling_morph_str,morphling_morph_agi,undying_decay\n                            sources.add(ability.bonusStrength(), ability.displayname);\n                        }\n                    }\n                    if (ability.bonusStrength2 != undefined) {\n                        if (ability.isActive() || (ability.behavior.indexOf('DOTA_ABILITY_BEHAVIOR_PASSIVE') != -1)) {\n                            // morphling_morph_str\n                            sources.add(ability.bonusStrength2(), ability.displayname);\n                        }\n                    }\n                }\n            }\n        }\n        return sources;\n    });\n    \n    self.getAgility = ko.computed(function () {\n        var sources = new StatModel();\n        for (var i = 0; i < self.abilities().length; i++) {\n            var ability = self._abilities[i];\n            if (ability.level() > 0) {\n                if (!(ability.name in self.abilityData)) {\n                    if (ability.isActive() || (ability.behavior.indexOf('DOTA_ABILITY_BEHAVIOR_PASSIVE') != -1)) {\n                        for (var j = 0; j < self._abilities[i].attributes.length; j++) {\n                            var attribute = self._abilities[i].attributes[j];\n                            switch(attribute.name) {\n                                // drow_ranger_marksmanship\n                                case 'marksmanship_agility_bonus':\n                                    sources.add(self.getAbilityAttributeValue(self._abilities[i].attributes, attribute.name, ability.level()), ability.displayname);\n                                break;\n                            }\n                        }\n                    }\n                }\n                else {\n                    if (ability.bonusAgility != undefined) {\n                        if (ability.isActive() || (ability.behavior.indexOf('DOTA_ABILITY_BEHAVIOR_PASSIVE') != -1)) {\n                            // morphling_morph_agi,morphling_morph_str\n                            sources.add(ability.bonusAgility(), ability.displayname);\n                        }\n                    }\n                    if (ability.bonusAgility2 != undefined) {\n                        if (ability.isActive() || (ability.behavior.indexOf('DOTA_ABILITY_BEHAVIOR_PASSIVE') != -1)) {\n                            // morphling_morph_agi,morphling_morph_str\n                            sources.add(ability.bonusAgility2(), ability.displayname);\n                        }\n                    }\n                }\n            }\n        }\n        return sources;\n    });\n\n    self.getIntelligence = ko.computed(function () {\n        var sources = new StatModel();\n        for (var i = 0; i < self.abilities().length; i++) {\n            var ability = self._abilities[i];\n            if (ability.level() > 0) {\n                if (!(ability.name in self.abilityData)) {\n                    if (ability.isActive() || (ability.behavior.indexOf('DOTA_ABILITY_BEHAVIOR_PASSIVE') != -1)) {\n                        for (var j = 0; j < self._abilities[i].attributes.length; j++) {\n                            var attribute = self._abilities[i].attributes[j];\n                            switch(attribute.name) {\n                                // invoker_exort\n                            /*    case 'bonus_intelligence':\n                                    totalAttribute += self.getAbilityAttributeValue(self._abilities[i].attributes, attribute.name, ability.level());\n                                break;*/\n                            }\n                        }\n                    }\n                }\n                /*else if (ability.bonusInt != undefined) {\n                    if (ability.isActive() || (ability.behavior.indexOf('DOTA_ABILITY_BEHAVIOR_PASSIVE') != -1) || ability.name == 'invoker_exort') {\n                        // invoker_exort\n                        totalAttribute+=ability.bonusInt();\n                    }\n                }*/\n            }\n        }\n        return sources;\n    });\n    \n    self.getArmor = ko.computed(function () {\n        var sources = new StatModel();\n        for (var i = 0; i < self.abilities().length; i++) {\n            var ability = self._abilities[i];\n            if (ability.level() > 0 && (ability.isActive() || (ability.behavior.indexOf('DOTA_ABILITY_BEHAVIOR_PASSIVE') != -1))) {\n                if (!(ability.name in self.abilityData)) {\n                    for (var j = 0; j < self._abilities[i].attributes.length; j++) {\n                        var attribute = self._abilities[i].attributes[j];\n                        switch(attribute.name) {\n                            // axe_berserkers_call,dragon_knight_dragon_blood,troll_warlord_berserkers_rage,lycan_shapeshift,enraged_wildkin_toughness_aura\n                            case 'bonus_armor':\n                                if (ability.name != 'templar_assassin_meld') {\n                                    sources.add(self.getAbilityAttributeValue(self._abilities[i].attributes, attribute.name, ability.level()), ability.displayname);\n                                }\n                            break;\n                            // sven_warcry\n                            case 'warcry_armor':\n                                sources.add(self.getAbilityAttributeValue(self._abilities[i].attributes, attribute.name, ability.level()), ability.displayname);\n                            break;\n                            // lich_frost_armor,ogre_magi_frost_armor\n                            case 'armor_bonus':\n                                if (ability.name == 'lich_frost_armor' || ability.name == 'ogre_magi_frost_armor') {\n                                    sources.add(self.getAbilityAttributeValue(self._abilities[i].attributes, attribute.name, ability.level()), ability.displayname);\n                                }\n                            break;\n                        }\n                    }\n                }\n                else if (ability.armor != undefined) {\n                    // shredder_reactive_armor,visage_gravekeepers_cloak\n                    sources.add(ability.armor(), ability.displayname);\n                }\n            }\n        }\n        return sources;\n    });\n\n    self.getArmorBaseReduction = ko.computed(function () {\n        var totalAttribute = 1;\n        for (var i = 0; i < self.abilities().length; i++) {\n            var ability = self._abilities[i];\n            if (ability.level() > 0 && (ability.isActive() || (ability.behavior.indexOf('DOTA_ABILITY_BEHAVIOR_PASSIVE') != -1))) {\n                //if (!(ability.name in self.abilityData)) {\n                    switch(ability.name) {\n                        //elder_titan_natural_order\n                        case 'elder_titan_natural_order':\n                            totalAttribute *= (1-self.getAbilityAttributeValue(self._abilities[i].attributes, 'armor_reduction_pct', ability.level())/100);\n                        break;\n                    }\n                //}\n            }\n        }\n        return totalAttribute;\n    });\n    \n    self.getArmorReduction = ko.computed(function () {\n        var sources = new StatModel();\n        for (var i = 0; i < self.abilities().length; i++) {\n            var ability = self._abilities[i];\n            if (ability.level() > 0 && (ability.isActive() || (ability.behavior.indexOf('DOTA_ABILITY_BEHAVIOR_PASSIVE') != -1))) {\n                if (!(ability.name in self.abilityData)) {\n                    switch(ability.name) {\n                        //templar_assassin_meld\n                        case 'templar_assassin_meld':\n                            sources.add(self.getAbilityAttributeValue(self._abilities[i].attributes, 'bonus_armor', ability.level()), ability.displayname);\n                        break;\n                        // tidehunter_gush\n                        case 'tidehunter_gush':\n                            sources.add(self.getAbilityAttributeValue(self._abilities[i].attributes, 'armor_bonus', ability.level()), ability.displayname);\n                        break;\n                        // naga_siren_rip_tide\n                        case 'naga_siren_rip_tide':\n                        // slardar_amplify_damage\n                        case 'slardar_amplify_damage':\n                        // vengefulspirit_wave_of_terror\n                        case 'vengefulspirit_wave_of_terror':\n                            sources.add(self.getAbilityAttributeValue(self._abilities[i].attributes, 'armor_reduction', ability.level()), ability.displayname);\n                        break;\n                        // nevermore_dark_lord\n                        case 'nevermore_dark_lord':\n                            sources.add(self.getAbilityAttributeValue(self._abilities[i].attributes, 'presence_armor_reduction', ability.level()), ability.displayname);\n                        break;\n                    }\n                }\n                else if (ability.armorReduction != undefined) {\n                    // alchemist_acid_spray\n                    sources.add(ability.armorReduction(), ability.displayname);\n                }\n            }\n        }\n        return sources;\n    });\n\n    self.getHealth = ko.computed(function () {\n        var sources = new StatModel();\n        for (var i = 0; i < self.abilities().length; i++) {\n            var ability = self._abilities[i];\n            if (ability.level() > 0 && (ability.isActive() || (ability.behavior.indexOf('DOTA_ABILITY_BEHAVIOR_PASSIVE') != -1))) {\n                if (!(ability.name in self.abilityData)) {\n                    for (var j = 0; j < self._abilities[i].attributes.length; j++) {\n                        var attribute = self._abilities[i].attributes[j];\n                        switch(attribute.name) {\n                            // lone_druid_true_form,lycan_shapeshift,troll_warlord_berserkers_rage\n                            case 'bonus_hp':\n                                sources.add(self.getAbilityAttributeValue(self._abilities[i].attributes, attribute.name, ability.level()), ability.displayname);\n                            break;\n                            // lone_druid_synergy\n                            case 'true_form_hp_bonus':\n                                if (self.isTrueFormActive()) {\n                                    sources.add(self.getAbilityAttributeValue(self._abilities[i].attributes, attribute.name, ability.level()), ability.displayname);\n                                }\n                            break;\n                        }\n                    }\n                }\n                else if (ability.bonusHealth != undefined) {\n                    // clinkz_death_pact,lycan_howl\n                    sources.add(ability.bonusHealth(), ability.displayname);\n                }\n            }\n        }\n        return sources;\n    });\n    \n    self.isTrueFormActive = function () {\n        for (var i = 0; i < self.abilities().length; i++) {\n            var ability = self._abilities[i];\n            if (ability.isActive() && ability.name == 'lone_druid_true_form') {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    self.getHealthRegen = ko.computed(function () {\n        var sources = new StatModel();\n        for (var i = 0; i < self.abilities().length; i++) {\n            var ability = self._abilities[i];\n            if (ability.level() > 0 && (ability.isActive() || (ability.behavior.indexOf('DOTA_ABILITY_BEHAVIOR_PASSIVE') != -1))) {\n                if (!(ability.name in self.abilityData)) {\n                    for (var j = 0; j < self._abilities[i].attributes.length; j++) {\n                        var attribute = self._abilities[i].attributes[j];\n                        switch(attribute.name) {\n                            // alchemist_chemical_rage, dragon_knight_dragon_blood\n                            case 'bonus_health_regen':\n                            // broodmother_spin_web\n                            case 'heath_regen':\n                            // omniknight_guardian_angel,treant_living_armor,satyr_hellcaller_unholy_aura\n                            case 'health_regen':\n                            // legion_commander_press_the_attack\n                            case 'hp_regen':\n                            // lycan_feral_impulse\n                            case 'bonus_hp_regen':\n                                sources.add(self.getAbilityAttributeValue(self._abilities[i].attributes, attribute.name, ability.level()), ability.displayname);\n                            break;\n                        }\n                    }\n                }\n                else if (ability.healthregen != undefined) {\n                    // shredder_reactive_armor,invoker_quas,necrolyte_sadist\n                    sources.add(ability.healthregen(), ability.displayname);\n                }\n            }\n        }\n        return sources;\n    });\n\n    self.getMana = ko.computed(function () {\n        var sources = new StatModel();\n        for (var i = 0; i < self.abilities().length; i++) {\n            var ability = self._abilities[i];\n            if (ability.level() > 0 && (ability.isActive() || (ability.behavior.indexOf('DOTA_ABILITY_BEHAVIOR_PASSIVE') != -1))) {\n                //if (!(ability.name in self.abilityData)) {\n                    for (var j = 0; j < self._abilities[i].attributes.length; j++) {\n                        var attribute = self._abilities[i].attributes[j];\n                        switch(attribute.name) {\n                            // obsidian_destroyer_essence_aura\n                            case 'bonus_mana':\n                                sources.add(self.getAbilityAttributeValue(self._abilities[i].attributes, attribute.name, ability.level()), ability.displayname);\n                            break;\n                        }\n                    }\n                //}\n            }\n        }\n        return sources;\n    });\n    \n    self.getManaRegen = ko.computed(function () {\n        var sources = new StatModel();\n        for (var i = 0; i < self.abilities().length; i++) {\n            var ability = self._abilities[i];\n            if (ability.level() > 0 && (ability.isActive() || (ability.behavior.indexOf('DOTA_ABILITY_BEHAVIOR_PASSIVE') != -1))) {\n                if (!(ability.name in self.abilityData)) {\n                    for (var j = 0; j < self._abilities[i].attributes.length; j++) {\n                        var attribute = self._abilities[i].attributes[j];\n                        switch(attribute.name) {\n                            // alchemist_chemical_rage\n                            case 'bonus_mana_regen':\n                                sources.add(self.getAbilityAttributeValue(self._abilities[i].attributes, attribute.name, ability.level()), ability.displayname);\n                            break;\n                        }\n                    }\n                }\n                else if (ability.manaregen != undefined) {\n                    // necrolyte_sadist\n                    sources.add(ability.manaregen(), ability.displayname);\n                }\n            }\n        }\n        return sources;\n    });\n    \n    self.getManaRegenArcaneAura = ko.computed(function () {\n        var sources = new StatModel();\n        for (var i = 0; i < self.abilities().length; i++) {\n            var ability = self._abilities[i];\n            if (ability.level() > 0 && (ability.isActive() || (ability.behavior.indexOf('DOTA_ABILITY_BEHAVIOR_PASSIVE') != -1))) {\n                //if (!(ability.name in self.abilityData)) {\n                    for (var j = 0; j < self._abilities[i].attributes.length; j++) {\n                        var attribute = self._abilities[i].attributes[j];\n                        switch(attribute.name) {\n                            // crystal_maiden_brilliance_aura\n                            case 'mana_regen':\n                                if (ability.name == 'crystal_maiden_brilliance_aura') {\n                                    sources.add(self.getAbilityAttributeValue(self._abilities[i].attributes, attribute.name, ability.level()), ability.displayname);\n                                }\n                            break;\n                        }\n                    }\n                //}\n            }\n        }\n        return sources;\n    });\n    \n    self.getManaRegenSelfArcaneAura = ko.computed(function () {\n        var sources = new StatModel();\n        for (var i = 0; i < self.abilities().length; i++) {\n            var ability = self._abilities[i];\n            if (ability.level() > 0 && (ability.isActive() || (ability.behavior.indexOf('DOTA_ABILITY_BEHAVIOR_PASSIVE') != -1))) {\n                //if (!(ability.name in self.abilityData)) {\n                    for (var j = 0; j < self._abilities[i].attributes.length; j++) {\n                        var attribute = self._abilities[i].attributes[j];\n                        switch(attribute.name) {\n                            // crystal_maiden_brilliance_aura\n                            case 'mana_regen_self':\n                                if (ability.name == 'crystal_maiden_brilliance_aura') {\n                                    sources.add(self.getAbilityAttributeValue(self._abilities[i].attributes, attribute.name, ability.level()), ability.displayname);\n                                }\n                            break;\n                        }\n                    }\n                //}\n            }\n        }\n        return sources;\n    });\n\n    self.getManaRegenReduction = ko.computed(function () {\n        var sources = new StatModel();\n        for (var i = 0; i < self.abilities().length; i++) {\n            var ability = self._abilities[i];\n            if (ability.level() > 0 && (ability.isActive() || (ability.behavior.indexOf('DOTA_ABILITY_BEHAVIOR_PASSIVE') != -1))) {\n                /*if (!(ability.name in self.abilityData)) {\n                    for (var j = 0; j < self._abilities[i].attributes.length; j++) {\n                        var attribute = self._abilities[i].attributes[j];\n                        //switch(attribute.name) {\n                        //    // \n                        //    case '':\n                        //        totalAttribute += parseInt(attribute.value[ability.level()-1]);\n                        //    break;\n                        //}\n                    }\n                }\n                else*/ if (ability.manaregenreduction != undefined) {\n                    // pugna_nether_ward\n                    sources.add(-ability.manaregenreduction(), ability.displayname);\n                }\n            }\n        }\n        return sources;\n    });\n    \n    self.getAttackRange = ko.computed(function () {\n        var totalAttribute = 0;\n        for (var i = 0; i < self.abilities().length; i++) {\n            var ability = self._abilities[i];\n            if (ability.level() > 0) {\n                if (!(ability.name in self.abilityData)) {\n                    if (ability.isActive() || (ability.behavior.indexOf('DOTA_ABILITY_BEHAVIOR_PASSIVE') != -1)) {\n                        for (var j = 0; j < self._abilities[i].attributes.length; j++) {\n                            var attribute = self._abilities[i].attributes[j];\n                            switch(attribute.name) {\n                                // winter_wyvern_arctic_burn\n                                case 'attack_range_bonus':\n                                // templar_assassin_psi_blades,sniper_take_aim\n                                case 'bonus_attack_range':\n                                    totalAttribute += self.getAbilityAttributeValue(self._abilities[i].attributes, attribute.name, ability.level());\n                                break;\n                                // terrorblade_metamorphosis,troll_warlord_berserkers_rage\n                                case 'bonus_range':\n                                    if (ability.name == 'terrorblade_metamorphosis') {\n                                        totalAttribute += self.getAbilityAttributeValue(self._abilities[i].attributes, attribute.name, ability.level());\n                                    }\n                                    if (ability.name == 'troll_warlord_berserkers_rage') {\n                                        totalAttribute -= self.getAbilityAttributeValue(self._abilities[i].attributes, attribute.name, ability.level());\n                                    }\n                                break;\n                                // tiny_grow\n                                case 'bonus_range_scepter':\n                                    if (ability.name == 'tiny_grow' && self.hasScepter()) {\n                                        totalAttribute += self.getAbilityAttributeValue(self._abilities[i].attributes, attribute.name, ability.level());\n                                    }\n                                break;\n                                // enchantress_impetus\n                                case 'bonus_attack_range_scepter':\n                                    if (ability.name == 'enchantress_impetus' && self.hasScepter()) {\n                                        totalAttribute += self.getAbilityAttributeValue(self._abilities[i].attributes, attribute.name, ability.level());\n                                    }\n                                break;\n                            }\n                        }\n                        // lone_druid_true_form\n                        if (ability.name == 'lone_druid_true_form') {\n                            totalAttribute -= 422;\n                        }\n                    }\n                    else if (ability.name == 'enchantress_impetus' && self.hasScepter()) {\n                        for (var j = 0; j < self._abilities[i].attributes.length; j++) {\n                            var attribute = self._abilities[i].attributes[j];\n                            switch(attribute.name) {\n                              case 'bonus_attack_range_scepter':\n                                totalAttribute += self.getAbilityAttributeValue(self._abilities[i].attributes, attribute.name, ability.level());\n                              break;\n                            }\n                        }\n                    }\n                }\n                else if (ability.attackrange != undefined) {\n                    if (ability.isActive() || (ability.behavior.indexOf('DOTA_ABILITY_BEHAVIOR_PASSIVE') != -1)) {\n                        // dragon_knight_elder_dragon_form\n                        totalAttribute+=ability.attackrange();\n                    }\n                }\n            }\n        }\n        return totalAttribute;\n    });\n    \n    self.getAttackSpeed = ko.computed(function () {\n        var totalAttribute = 0;\n        for (var i = 0; i < self.abilities().length; i++) {\n            var ability = self._abilities[i];\n            if (ability.level() > 0 && (ability.isActive() || (ability.behavior.indexOf('DOTA_ABILITY_BEHAVIOR_PASSIVE') != -1))) {\n                if (!(ability.name in self.abilityData)) {\n                    for (var j = 0; j < self._abilities[i].attributes.length; j++) {\n                        var attribute = self._abilities[i].attributes[j];\n                        switch(attribute.name) {\n                            // abaddon_frostmourne,troll_warlord_battle_trance\n                            case 'attack_speed':\n                            // visage_grave_chill\n                            case 'attackspeed_bonus':\n                            // mirana_leap\n                            case 'leap_speedbonus_as':\n                            // life_stealer\n                            case 'attack_speed_bonus':\n                                totalAttribute += self.getAbilityAttributeValue(self._abilities[i].attributes, attribute.name, ability.level());\n                            break;\n                            // clinkz_strafe,ursa_overpower\n                            case 'attack_speed_bonus_pct':\n                                if (ability.name == 'clinkz_strafe' || ability.name == 'ursa_overpower') {\n                                    totalAttribute += self.getAbilityAttributeValue(self._abilities[i].attributes, attribute.name, ability.level());\n                                }\n                            break;\n                            // axe_culling_blade,necronomicon_archer_aoe\n                            case 'speed_bonus':\n                                if (ability.name == 'axe_culling_blade' || ability.name == 'necronomicon_archer_aoe') {\n                                    totalAttribute += self.getAbilityAttributeValue(self._abilities[i].attributes, attribute.name, ability.level());\n                                }\n                            break;\n                            // ancient_apparition_chilling_touch\n                            case 'attack_speed_pct':\n                                if (ability.name == 'ancient_apparition_chilling_touch') {\n                                    totalAttribute += self.getAbilityAttributeValue(self._abilities[i].attributes, attribute.name, ability.level());\n                                }\n                            break;\n                            // beastmaster_inner_beast,lycan_feral_impulse,lone_druid_rabid,tiny_grow,phantom_assassin_phantom_strike,windrunner_focusfire,ogre_magi_bloodlust,centaur_khan_endurance_aura\n                            case 'bonus_attack_speed':\n                                if (ability.name == 'beastmaster_inner_beast' \n                                 || ability.name == 'lycan_feral_impulse' \n                                 || ability.name == 'lone_druid_rabid' \n                                 || ability.name == 'tiny_grow' \n                                 || ability.name == 'phantom_assassin_phantom_strike' \n                                 || ability.name == 'windrunner_focusfire' \n                                 || ability.name == 'ogre_magi_bloodlust'\n                                 || ability.name == 'centaur_khan_endurance_aura') {\n                                    totalAttribute += self.getAbilityAttributeValue(self._abilities[i].attributes, attribute.name, ability.level());\n                                }\n                            break;\n                        }\n                    }\n                }\n                else if (ability.attackspeed != undefined) {\n                    // troll_warlord_fervor,wisp_overcharge,lina_fiery_soul,invoker_alacrity,invoker_wex,huskar_berserkers_blood\n                    totalAttribute+=ability.attackspeed();\n                }\n            }\n        }\n        return totalAttribute;\n    });\n\n    self.getAttackSpeedReduction = ko.computed(function () {\n        var totalAttribute = 0;\n        for (var i = 0; i < self.abilities().length; i++) {\n            var ability = self._abilities[i];\n            if (ability.level() > 0 && (ability.isActive() || (ability.behavior.indexOf('DOTA_ABILITY_BEHAVIOR_PASSIVE') != -1))) {\n                if (!(ability.name in self.abilityData)) {\n                    for (var j = 0; j < self._abilities[i].attributes.length; j++) {\n                        var attribute = self._abilities[i].attributes[j];\n                        switch(attribute.name) {\n                            // night_stalker_void,crystal_maiden_crystal_nova,ghost_frost_attack,ogre_magi_frost_armor,polar_furbolg_ursa_warrior_thunder_clap\n                            case 'attackspeed_slow':\n                            // lich_frost_armor,lich_frost_nova,enchantress_untouchable\n                            case 'slow_attack_speed':\n                            // beastmaster_primal_roar\n                            case 'slow_attack_speed_pct':\n                            // storm_spirit_overload\n                            case 'overload_attack_slow':\n                                totalAttribute += self.getAbilityAttributeValue(self._abilities[i].attributes, attribute.name, ability.level());\n                            break;\n                            // omniknight_degen_aura\n                            case 'speed_bonus':\n                                if (ability.name == 'omniknight_degen_aura') {\n                                    totalAttribute += self.getAbilityAttributeValue(self._abilities[i].attributes, attribute.name, ability.level());\n                                }\n                            break;\n                            // tusk_frozen_sigil,crystal_maiden_freezing_field\n                            case 'attack_slow':\n                                if (ability.name == 'crystal_maiden_freezing_field' && !self.hasScepter()) {\n                                    totalAttribute += self.getAbilityAttributeValue(self._abilities[i].attributes, attribute.name, ability.level());\n                                }\n                                else if (ability.name == 'tusk_frozen_sigil') {\n                                    totalAttribute -= self.getAbilityAttributeValue(self._abilities[i].attributes, attribute.name, ability.level());\n                                }\n                            break;\n                            case 'attack_slow_scepter':\n                                if (ability.name == 'crystal_maiden_freezing_field' && self.hasScepter()) {\n                                    totalAttribute += self.getAbilityAttributeValue(self._abilities[i].attributes, attribute.name, ability.level());\n                                }\n                            break;\n                            // faceless_void_time_walk\n                            case 'attack_speed_pct':\n                                if (ability.name == 'faceless_void_time_walk') {\n                                    totalAttribute += self.getAbilityAttributeValue(self._abilities[i].attributes, attribute.name, ability.level());\n                                }\n                            break;\n                            // bounty_hunter_jinada\n                            case 'bonus_attackspeed':\n                                if (ability.name == 'bounty_hunter_jinada') {\n                                    totalAttribute += self.getAbilityAttributeValue(self._abilities[i].attributes, attribute.name, ability.level());\n                                }\n                            break;\n                            // brewmaster_thunder_clap\n                            case 'attack_speed_slow':\n                                if (ability.name == 'brewmaster_thunder_clap') {\n                                    totalAttribute -= self.getAbilityAttributeValue(self._abilities[i].attributes, attribute.name, ability.level());\n                                }\n                            break;\n                            // medusa_stone_gaze\n                            case 'slow':\n                                if (ability.name == 'medusa_stone_gaze') {\n                                    totalAttribute -= self.getAbilityAttributeValue(self._abilities[i].attributes, attribute.name, ability.level());\n                                }\n                            break;\n                            // visage_grave_chill\n                            case 'attackspeed_bonus':\n                                totalAttribute -= self.getAbilityAttributeValue(self._abilities[i].attributes, attribute.name, ability.level());\n                            break;\n                            // abaddon_frostmourne\n                            case 'attack_slow_tooltip':\n                                if (ability.name == 'abaddon_frostmourne') {\n                                    totalAttribute -= self.getAbilityAttributeValue(self._abilities[i].attributes, attribute.name, ability.level());\n                                }\n                            break;\n                        }\n                    }\n                    if (ability.name == 'enraged_wildkin_tornado') {\n                        totalAttribute -= 15;\n                    }\n                }\n                else if (ability.attackspeedreduction != undefined) {\n                    // viper_viper_strike,viper_corrosive_skin,jakiro_liquid_fire,lich_chain_frost,sandking_epicenter,earth_spirit_rolling_boulder\n                    totalAttribute+=ability.attackspeedreduction();\n                }\n            }\n        }\n        return totalAttribute;\n    });\n    self.getBash = ko.computed(function () {\n        var totalAttribute = 1;\n        for (var i = 0; i < self.abilities().length; i++) {\n            var ability = self._abilities[i];\n            if (ability.level() > 0 && (ability.isActive() || (ability.behavior.indexOf('DOTA_ABILITY_BEHAVIOR_PASSIVE') != -1))) {\n                if (!(ability.name in self.abilityData)) {\n                    for (var j = 0; j < self._abilities[i].attributes.length; j++) {\n                        var attribute = self._abilities[i].attributes[j];\n                        switch(attribute.name) {\n                            // slardar_bash\n                            case 'chance':\n                            // sniper_headshot\n                            case 'proc_chance':\n                                totalAttribute *= (1 - self.getAbilityAttributeValue(self._abilities[i].attributes, attribute.name, ability.level())/100);\n                            break;\n                        }\n                    }\n                }\n                else if (ability.bash != undefined) {\n                    // spirit_breaker_greater_bash,faceless_void_time_lock\n                    totalAttribute *= (1 - ability.bash()/100);\n                }\n            }\n        }\n        return totalAttribute;\n    });    \n    self.getBaseDamage = ko.computed(function () {\n        var totalAttribute = 0;\n        var totalMultiplier = 1;\n        var sources = {};\n        for (var i = 0; i < self.abilities().length; i++) {\n            var ability = self._abilities[i];\n            if (ability.level() > 0 && (ability.isActive() || (ability.behavior.indexOf('DOTA_ABILITY_BEHAVIOR_PASSIVE') != -1))) {\n                if (!(ability.name in self.abilityData)) {\n                    for (var j = 0; j < self._abilities[i].attributes.length; j++) {\n                        var attribute = self._abilities[i].attributes[j];\n                        switch(attribute.name) {\n                            // tiny_grow,terrorblade_metamorphosis\n                            case 'bonus_damage':\n                                if (ability.name == 'tiny_grow' || ability.name == 'terrorblade_metamorphosis') {\n                                    totalAttribute += self.getAbilityAttributeValue(self._abilities[i].attributes, attribute.name, ability.level());\n                                    sources[ability.name] = {\n                                        'damage': self.getAbilityAttributeValue(self._abilities[i].attributes, attribute.name, ability.level()),\n                                        'damageType': 'physical',\n                                        'displayname': ability.displayname\n                                    }\n                                }\n                            break;\n                        }\n                    }\n                }\n                else {\n                    if (ability.baseDamageMultiplier != undefined) {\n                        // earthshaker_enchant_totem\n                        totalMultiplier += ability.baseDamageMultiplier()/100;\n                        /*totalAttribute += ability.baseDamage();\n                        sources[ability.name] = {\n                            'damage': ability.baseDamage(),\n                            'damageType': 'physical',\n                            'displayname': ability.displayname\n                        }*/\n                    }\n                    if (ability.baseDamage != undefined) {\n                        // clinkz_death_pact\n                        totalAttribute += ability.baseDamage();\n                        sources[ability.name] = {\n                            'damage': ability.baseDamage(),\n                            'damageType': 'physical',\n                            'displayname': ability.displayname\n                        }\n                    }\n                }\n            }\n        }\n        return { sources: sources, total: totalAttribute, multiplier: totalMultiplier };\n    });\n    \n    self.getSelfBaseDamageReductionPct = ko.computed(function () {\n        var totalAttribute = 1;\n        for (var i = 0; i < self.abilities().length; i++) {\n            var ability = self._abilities[i];\n            if (ability.level() > 0 && (ability.isActive() || (ability.behavior.indexOf('DOTA_ABILITY_BEHAVIOR_PASSIVE') != -1))) {\n                if (!(ability.name in self.abilityData)) {\n                    for (var j = 0; j < self._abilities[i].attributes.length; j++) {\n                        var attribute = self._abilities[i].attributes[j];\n                        switch(attribute.name) {\n                            // medusa_split_shot\n                            case 'damage_modifier':\n                                totalAttribute *= (1 + self.getAbilityAttributeValue(self._abilities[i].attributes, attribute.name, ability.level())/100);\n                            break;\n                            // windrunner_focusfire\n                            case 'focusfire_damage_reduction':\n                                if (!self.hasScepter()) {\n                                    totalAttribute *= (1 + self.getAbilityAttributeValue(self._abilities[i].attributes, attribute.name, ability.level())/100);\n                                }\n                            break;\n                            case 'focusfire_damage_reduction_scepter':\n                                if (self.hasScepter()) {\n                                    totalAttribute *= (1 + self.getAbilityAttributeValue(self._abilities[i].attributes, attribute.name, ability.level())/100);\n                                }\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n        return totalAttribute;\n    });\n    \n    self.getBaseDamageReductionPct = ko.computed(function () {\n        var totalAttribute = 1;\n        for (var i = 0; i < self.abilities().length; i++) {\n            var ability = self._abilities[i];\n            if (ability.level() > 0 && (ability.isActive() || (ability.behavior.indexOf('DOTA_ABILITY_BEHAVIOR_PASSIVE') != -1))) {\n                if (!(ability.name in self.abilityData)) {\n                    for (var j = 0; j < self._abilities[i].attributes.length; j++) {\n                        var attribute = self._abilities[i].attributes[j];\n                        switch(attribute.name) {\n                            // vengefulspirit_command_aura\n                            case 'bonus_damage_pct':\n                                if (ability.name == 'vengefulspirit_command_aura') {\n                                    totalAttribute *= (1 - self.getAbilityAttributeValue(self._abilities[i].attributes, attribute.name, ability.level())/100);\n                                }\n                            break;\n                        }\n                    }\n                }\n                else if (ability.baseDamageReductionPct != undefined) {\n                    // nevermore_requiem\n                    totalAttribute *= (1 + ability.baseDamageReductionPct()/100);\n                }\n            }\n        }\n        return totalAttribute;\n    });\n    \n    self.getBAT = ko.computed(function () {\n        var totalAttribute = 0;\n        for (var i = 0; i < self.abilities().length; i++) {\n            var ability = self._abilities[i];\n            if (ability.level() > 0 && (ability.isActive() || (ability.behavior.indexOf('DOTA_ABILITY_BEHAVIOR_PASSIVE') != -1))) {\n                if (!(ability.name in self.abilityData)) {\n                    for (var j = 0; j < self._abilities[i].attributes.length; j++) {\n                        var attribute = self._abilities[i].attributes[j];\n                        switch(attribute.name) {\n                            // troll_warlord_berserkers_rage,alchemist_chemical_rage,lone_druid_true_form,lycan_shapeshift\n                            case 'base_attack_time':\n                                totalAttribute += self.getAbilityAttributeValue(self._abilities[i].attributes, attribute.name, ability.level());\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n        return totalAttribute;\n    });\n    self.getBonusDamage = ko.computed(function () {\n        var totalAttribute = 0;\n        var sources = {};\n        for (var i = 0; i < self.abilities().length; i++) {\n            var ability = self._abilities[i];\n            if (ability.level() > 0 && (ability.isActive() || (ability.behavior.indexOf('DOTA_ABILITY_BEHAVIOR_PASSIVE') != -1))) {\n                if (!(ability.name in self.abilityData)) {\n                    for (var j = 0; j < self._abilities[i].attributes.length; j++) {\n                        var attribute = self._abilities[i].attributes[j];\n                        switch(attribute.name) {\n                            // broodmother_insatiable_hunger,luna_lunar_blessing,templar_assassin_refraction,templar_assassin_meld,troll_warlord_berserkers_rage,lone_druid_true_form_battle_cry\n                            case 'bonus_damage':\n                                if (ability.name == 'broodmother_insatiable_hunger' || ability.name == 'luna_lunar_blessing'\n                                 || ability.name == 'templar_assassin_refraction' || ability.name == 'templar_assassin_meld'\n                                 || ability.name == 'troll_warlord_berserkers_rage' || ability.name == 'lone_druid_true_form_battle_cry') {\n                                    totalAttribute += self.getAbilityAttributeValue(self._abilities[i].attributes, attribute.name, ability.level());\n                                    sources[ability.name] = {\n                                        'damage': self.getAbilityAttributeValue(self._abilities[i].attributes, attribute.name, ability.level()),\n                                        'damageType': 'physical',\n                                        'displayname': ability.displayname\n                                    }\n                                }\n                            break;\n                        }\n                    }\n                    if (ability.name == 'storm_spirit_overload') {\n                        totalAttribute += self.getAbilityPropertyValue(ability, 'damage');\n                        sources[ability.name] = {\n                            'damage': self.getAbilityPropertyValue(ability, 'damage'),\n                            'damageType': 'magic',\n                            'displayname': ability.displayname\n                        }                        \n                    }\n                }\n                else if (ability.bonusDamage != undefined && ability.bonusDamage() != 0) {\n                    // nevermore_necromastery,ursa_fury_swipes,ursa_enrage,invoker_alacrity,invoker_exort,elder_titan_ancestral_spirit,spectre_desolate,razor_static_link,lycan_howl\n                    totalAttribute+=ability.bonusDamage();\n                    sources[ability.name] = {\n                        'damage': ability.bonusDamage(),\n                        'damageType': ability.name == 'spectre_desolate' ? 'pure' : 'physical',\n                        'displayname': ability.displayname\n                    }\n                }\n            }\n        }\n        return { sources: sources, total: totalAttribute };\n    });\n\n    self.getBonusDamagePercent = ko.computed(function () {\n        var totalAttribute = 0;\n        var sources = {};\n        for (var i = 0; i < self.abilities().length; i++) {\n            var ability = self._abilities[i];\n            if (ability.level() > 0 && (ability.isActive() || (ability.behavior.indexOf('DOTA_ABILITY_BEHAVIOR_PASSIVE') != -1))) {\n                if (!(ability.name in self.abilityData)) {\n                    for (var j = 0; j < self._abilities[i].attributes.length; j++) {\n                        var attribute = self._abilities[i].attributes[j];\n                        switch(attribute.name) {\n                            // bloodseeker_bloodrage\n                            case 'damage_increase_pct':\n                                if (ability.name == 'bloodseeker_bloodrage') {\n                                    totalAttribute += self.getAbilityAttributeValue(self._abilities[i].attributes, attribute.name, ability.level())/100;\n                                    sources[ability.name] = {\n                                        'damage': self.getAbilityAttributeValue(self._abilities[i].attributes, attribute.name, ability.level())/100,\n                                        'damageType': 'physical',\n                                        'displayname': ability.displayname\n                                    }\n                                }\n                            break;\n                            // magnataur_empower,vengefulspirit_command_aura,alpha_wolf_command_aura\n                            case 'bonus_damage_pct':\n                                if (ability.name == 'magnataur_empower' || ability.name == 'vengefulspirit_command_aura' || ability.name == 'alpha_wolf_command_aura') {\n                                    totalAttribute += self.getAbilityAttributeValue(self._abilities[i].attributes, attribute.name, ability.level())/100;\n                                    sources[ability.name] = {\n                                        'damage': self.getAbilityAttributeValue(self._abilities[i].attributes, attribute.name, ability.level())/100,\n                                        'damageType': 'physical',\n                                        'displayname': ability.displayname\n                                    }\n                                }\n                            break;\n                            // lycan_feral_impulse\n                            case 'bonus_damage':\n                                if (ability.name == 'lycan_feral_impulse') {\n                                    totalAttribute += self.getAbilityAttributeValue(self._abilities[i].attributes, attribute.name, ability.level())/100;\n                                    sources[ability.name] = {\n                                        'damage': self.getAbilityAttributeValue(self._abilities[i].attributes, attribute.name, ability.level())/100,\n                                        'damageType': 'physical',\n                                        'displayname': ability.displayname\n                                    }\n                                }\n                            break;\n                            // sven_gods_strength\n                            case 'gods_strength_damage':\n                                if (ability.name == 'sven_gods_strength' && self.hero != undefined && self.hero.heroId() == 'sven') {\n                                    totalAttribute += self.getAbilityAttributeValue(self._abilities[i].attributes, attribute.name, ability.level())/100;\n                                    sources[ability.name] = {\n                                        'damage': self.getAbilityAttributeValue(self._abilities[i].attributes, attribute.name, ability.level())/100,\n                                        'damageType': 'physical',\n                                        'displayname': ability.displayname\n                                    }\n                                }\n                            break;\n                            case 'gods_strength_damage_scepter':\n                                if (ability.name == 'sven_gods_strength' && self.hero == undefined) {\n                                    totalAttribute += self.getAbilityAttributeValue(self._abilities[i].attributes, attribute.name, ability.level())/100;\n                                    sources[ability.name] = {\n                                        'damage': self.getAbilityAttributeValue(self._abilities[i].attributes, attribute.name, ability.level())/100,\n                                        'damageType': 'physical',\n                                        'displayname': ability.displayname\n                                    }\n                                }\n                            break;\n                        }\n                    }\n                }\n                /*else if (ability.bonusDamagePct != undefined && ability.bonusDamagePct() != 0) {\n                    // bloodseeker_bloodrage\n                    // totalAttribute+=ability.bonusDamagePct()/100;\n                    // sources[ability.name] = {\n                        // 'damage': ability.bonusDamagePct()/100,\n                        // 'damageType': 'physical',\n                        // 'displayname': ability.displayname\n                    // }\n                }*/\n            }\n        }\n        return { sources: sources, total: totalAttribute };\n    });\n\n    self.getBonusDamageBackstab = ko.computed(function () {\n        var totalAttribute1 = 0;\n        var totalAttribute2 = 0;\n        var sources = [];\n        for (var i = 0; i < self.abilities().length; i++) {\n            var ability = self._abilities[i];\n            if (ability.name == 'riki_backstab') {\n                if (ability.level() > 0 && (ability.isActive() || (ability.behavior.indexOf('DOTA_ABILITY_BEHAVIOR_PASSIVE') != -1))) {\n                    for (var j = 0; j < self._abilities[i].attributes.length; j++) {\n                        var attribute = self._abilities[i].attributes[j];\n                        switch(attribute.name) {\n                            // riki_backstab\n                            case 'damage_multiplier':\n                                totalAttribute1 += self.getAbilityAttributeValue(self._abilities[i].attributes, attribute.name, ability.level());\n                                sources.push({\n                                    'damage': self.getAbilityAttributeValue(self._abilities[i].attributes, attribute.name, ability.level()),\n                                    'damageType': 'physical',\n                                    'displayname': ability.displayname\n                                });\n                            break;\n                        }\n                    }/*\n                    if (ability.bonusDamageBackstab != undefined) {\n                        // damage_multiplier\n                        totalAttribute2+=ability.bonusDamageBackstab();\n                        sources.push({\n                            'damage': ability.bonusDamageBackstab(),\n                            'damageType': 'physical',\n                            'displayname': ability.displayname\n                        });\n                    }\n                    */\n                }\n            }\n        }\n        return { sources: sources, total: [totalAttribute1,totalAttribute2] };\n    });\n    \n    self.getBonusDamagePrecisionAura = ko.computed(function () {\n        var totalAttribute1 = 0;\n        var totalAttribute2 = 0;\n        var sources = [];\n        for (var i = 0; i < self.abilities().length; i++) {\n            var ability = self._abilities[i];\n            if (ability.name == 'drow_ranger_trueshot') {\n                if (ability.level() > 0 && (ability.isActive() || (ability.behavior.indexOf('DOTA_ABILITY_BEHAVIOR_PASSIVE') != -1))) {\n                    for (var j = 0; j < self._abilities[i].attributes.length; j++) {\n                        var attribute = self._abilities[i].attributes[j];\n                        switch(attribute.name) {\n                            // drow_ranger_trueshot\n                            case 'trueshot_ranged_damage':\n                                totalAttribute1 += self.getAbilityAttributeValue(self._abilities[i].attributes, attribute.name, ability.level())/100;\n                                sources.push({\n                                    'damage': self.getAbilityAttributeValue(self._abilities[i].attributes, attribute.name, ability.level())/100,\n                                    'damageType': 'physical',\n                                    'displayname': ability.displayname\n                                });\n                            break;\n                        }\n                    }\n                    if (ability.bonusDamagePrecisionAura != undefined) {\n                        // drow_ranger_trueshot\n                        totalAttribute2+=ability.bonusDamagePrecisionAura();\n                        sources.push({\n                            'damage': ability.bonusDamagePrecisionAura(),\n                            'damageType': 'physical',\n                            'displayname': ability.displayname\n                        });\n                    }\n                }\n            }\n        }\n        return { sources: sources, total: [totalAttribute1,totalAttribute2] };\n    });\n    \n    self.getBonusDamageReduction = ko.computed(function () {\n        var totalAttribute = 0;\n        for (var i = 0; i < self.abilities().length; i++) {\n            var ability = self._abilities[i];\n            if (ability.level() > 0 && (ability.isActive() || (ability.behavior.indexOf('DOTA_ABILITY_BEHAVIOR_PASSIVE') != -1))) {\n                if (!(ability.name in self.abilityData)) {\n                    for (var j = 0; j < self._abilities[i].attributes.length; j++) {\n                        var attribute = self._abilities[i].attributes[j];\n                        switch(attribute.name) {\n                            // bane_enfeeble\n                            case 'enfeeble_attack_reduction':\n                                totalAttribute += self.getAbilityAttributeValue(self._abilities[i].attributes, attribute.name, ability.level());\n                            break;\n                        }\n                    }\n                }\n                else if (ability.bonusDamageReduction != undefined) {\n                    // rubick_fade_bolt,razor_static_link\n                    totalAttribute+=ability.bonusDamageReduction();\n                }\n            }\n        }\n        return totalAttribute;\n    });\n    \n    self.getBonusDamageReductionPct = ko.computed(function () {\n        var totalAttribute = 1;\n        for (var i = 0; i < self.abilities().length; i++) {\n            var ability = self._abilities[i];\n            if (ability.level() > 0 && (ability.isActive() || (ability.behavior.indexOf('DOTA_ABILITY_BEHAVIOR_PASSIVE') != -1))) {\n                if (!(ability.name in self.abilityData)) {\n                    for (var j = 0; j < self._abilities[i].attributes.length; j++) {\n                        var attribute = self._abilities[i].attributes[j];\n                        switch(attribute.name) {\n                            // medusa_split_shot\n                            case 'damage_modifier':\n                                totalAttribute *= (1 + self.getAbilityAttributeValue(self._abilities[i].attributes, attribute.name, ability.level())/100);\n                            break;\n                            // windrunner_focusfire\n                            case 'focusfire_damage_reduction':\n                                if (!self.hasScepter()) {\n                                    totalAttribute *= (1 + self.getAbilityAttributeValue(self._abilities[i].attributes, attribute.name, ability.level())/100);\n                                }\n                            break;\n                            case 'focusfire_damage_reduction_scepter':\n                                if (self.hasScepter()) {\n                                    totalAttribute *= (1 + self.getAbilityAttributeValue(self._abilities[i].attributes, attribute.name, ability.level())/100);\n                                }\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n        return totalAttribute;\n    });\n\n    self.getDamageAmplification = ko.computed(function () {\n        var totalAttribute = 1;\n        for (var i = 0; i < self.abilities().length; i++) {\n            var ability = self._abilities[i];\n            if (ability.level() > 0 && (ability.isActive() || (ability.behavior.indexOf('DOTA_ABILITY_BEHAVIOR_PASSIVE') != -1))) {\n                /*if (!(ability.name in self.abilityData)) {\n                    if (ability.level() > 0 && (ability.isActive() || (ability.behavior.indexOf('DOTA_ABILITY_BEHAVIOR_PASSIVE') != -1))) {\n                        for (var j = 0; j < self._abilities[i].attributes.length; j++) {\n                            var attribute = self._abilities[i].attributes[j];\n                            switch(attribute.name) {\n                                // bane_enfeeble\n                                case 'enfeeble_attack_reduction':\n                                    totalAttribute += self.getAbilityAttributeValue(self._abilities[i].attributes, attribute.name, ability.level());\n                                break;\n                            }\n                        }\n                    }\n                }\n                else*/ if (ability.damageAmplification != undefined) {\n                        // undying_flesh_golem\n                        totalAttribute *= (1 + ability.damageAmplification()/100);\n                }\n            }\n        }\n        return totalAttribute;\n    });\n    \n    self.getDamageReduction = ko.computed(function () {\n        var totalAttribute = 1;\n        for (var i = 0; i < self.abilities().length; i++) {\n            var ability = self._abilities[i];\n            if (ability.level() > 0 && (ability.isActive() || (ability.behavior.indexOf('DOTA_ABILITY_BEHAVIOR_PASSIVE') != -1))) {\n                if (!(ability.name in self.abilityData)) {\n                    for (var j = 0; j < self._abilities[i].attributes.length; j++) {\n                        var attribute = self._abilities[i].attributes[j];\n                        switch(attribute.name) {\n                            // bloodseeker_bloodrage\n                            case 'damage_increase_pct':\n                                if (ability.name == 'bloodseeker_bloodrage') {\n                                    totalAttribute *= (1 + self.getAbilityAttributeValue(self._abilities[i].attributes, attribute.name, ability.level())/100);\n                                }\n                            break;\n                        }\n                    }\n                    // kunkka_ghostship\n                    if (ability.name == 'kunkka_ghostship') {\n                        totalAttribute *= (1 - 50/100);\n                    }\n                }\n                else if (ability.damageReduction != undefined) {\n                    // wisp_overcharge,bristleback_bristleback,spectre_dispersion,medusa_mana_shield,ursa_enrage,visage_gravekeepers_cloak\n                    totalAttribute *= (1 + ability.damageReduction()/100);\n                }\n            }\n        }\n        return totalAttribute;\n    });\n\n    self.getCritSource = ko.computed(function () {\n        var sources = {};\n        for (var i = 0; i < self.abilities().length; i++) {\n            var ability = self._abilities[i];\n            if (ability.level() > 0 && (ability.isActive() || (ability.behavior.indexOf('DOTA_ABILITY_BEHAVIOR_PASSIVE') != -1))) {\n                if (!(ability.name in self.abilityData)) {\n                    switch(ability.name) {\n                        // phantom_assassin_coup_de_grace,brewmaster_drunken_brawler,chaos_knight_chaos_strike,lycan_shapeshift,skeleton_king_mortal_strike,juggernaut_blade_dance,alpha_wolf_critical_strike,giant_wolf_critical_strike\n                        case 'phantom_assassin_coup_de_grace':\n                            if (sources[ability.name] == undefined) {\n                                sources[ability.name] = {\n                                    'chance': self.getAbilityAttributeValue(self._abilities[i].attributes, 'crit_chance', ability.level())/100,\n                                    'multiplier': self.getAbilityAttributeValue(self._abilities[i].attributes, 'crit_bonus', ability.level())/100,\n                                    'count': 1,\n                                    'displayname': ability.displayname\n                                }\n                            }\n                            else {\n                                sources[ability.name].count += 1;\n                            }\n                        break;\n                        case 'brewmaster_drunken_brawler':\n                            if (sources[ability.name] == undefined) {\n                                sources[ability.name] = {\n                                    'chance': self.getAbilityAttributeValue(self._abilities[i].attributes, 'crit_chance', ability.level())/100,\n                                    'multiplier': self.getAbilityAttributeValue(self._abilities[i].attributes, 'crit_multiplier', ability.level())/100,\n                                    'count': 1,\n                                    'displayname': ability.displayname\n                                }\n                            }\n                            else {\n                                sources[ability.name].count += 1;\n                            }\n                        break;\n                        case 'chaos_knight_chaos_strike':\n                        case 'lycan_shapeshift':\n                            if (sources[ability.name] == undefined) {\n                                sources[ability.name] = {\n                                    'chance': self.getAbilityAttributeValue(self._abilities[i].attributes, 'crit_chance', ability.level())/100,\n                                    'multiplier': self.getAbilityAttributeValue(self._abilities[i].attributes, 'crit_multiplier', ability.level())/100,\n                                    'count': 1,\n                                    'displayname': ability.displayname\n                                }\n                            }\n                            else {\n                                sources[ability.name].count += 1;\n                            }\n                        break;\n                        case 'skeleton_king_mortal_strike':\n                            if (sources[ability.name] == undefined) {\n                                sources[ability.name] = {\n                                    'chance': self.getAbilityAttributeValue(self._abilities[i].attributes, 'crit_chance', ability.level())/100,\n                                    'multiplier': self.getAbilityAttributeValue(self._abilities[i].attributes, 'crit_mult', ability.level())/100,\n                                    'count': 1,\n                                    'displayname': ability.displayname\n                                }\n                            }\n                            else {\n                                sources[ability.name].count += 1;\n                            }\n                        break;\n                        case 'juggernaut_blade_dance':\n                            if (sources[ability.name] == undefined) {\n                                sources[ability.name] = {\n                                    'chance': self.getAbilityAttributeValue(self._abilities[i].attributes, 'blade_dance_crit_chance', ability.level())/100,\n                                    'multiplier': self.getAbilityAttributeValue(self._abilities[i].attributes, 'blade_dance_crit_mult', ability.level())/100,\n                                    'count': 1,\n                                    'displayname': ability.displayname\n                                }\n                            }\n                            else {\n                                sources[ability.name].count += 1;\n                            }\n                        break;\n                        case 'alpha_wolf_critical_strike':\n                        case 'giant_wolf_critical_strike':\n                            if (sources[ability.name] == undefined) {\n                                sources[ability.name] = {\n                                    'chance': self.getAbilityAttributeValue(self._abilities[i].attributes, 'crit_chance', ability.level())/100,\n                                    'multiplier': self.getAbilityAttributeValue(self._abilities[i].attributes, 'crit_mult', ability.level())/100,\n                                    'count': 1,\n                                    'displayname': ability.displayname\n                                }\n                            }\n                            else {\n                                sources[ability.name].count += 1;\n                            }\n                        break;\n                    }\n                }\n            }\n        }\n        return sources;\n    });    \n\n    self.getCleaveSource = ko.computed(function () {\n        var sources = {};\n        for (var i = 0; i < self.abilities().length; i++) {\n            var ability = self._abilities[i];\n            if (ability.level() > 0 && (ability.isActive() || (ability.behavior.indexOf('DOTA_ABILITY_BEHAVIOR_PASSIVE') != -1))) {\n                if (!(ability.name in self.abilityData)) {\n                    switch(ability.name) {\n                        // magnataur_empower\n                        case 'magnataur_empower':\n                            if (sources[ability.name] == undefined) {\n                                sources[ability.name] = {\n                                    'radius': self.getAbilityAttributeValue(self._abilities[i].attributes, 'cleave_radius', ability.level()),\n                                    'magnitude': self.getAbilityAttributeValue(self._abilities[i].attributes, 'cleave_damage_pct', ability.level())/100,\n                                    'count': 1,\n                                    'displayname': ability.displayname\n                                }\n                            }\n                            else {\n                                sources[ability.name].count += 1;\n                            }\n                        break;\n                        // sven_great_cleave\n                        case 'sven_great_cleave':\n                            if (sources[ability.name] == undefined) {\n                                sources[ability.name] = {\n                                    'radius': self.getAbilityAttributeValue(self._abilities[i].attributes, 'great_cleave_radius', ability.level()),\n                                    'magnitude': self.getAbilityAttributeValue(self._abilities[i].attributes, 'great_cleave_damage', ability.level())/100,\n                                    'count': 1,\n                                    'displayname': ability.displayname\n                                }\n                            }\n                            else {\n                                sources[ability.name].count += 1;\n                            }\n                        break;\n                        // kunkka_tidebringer\n                        case 'kunkka_tidebringer':\n                            if (sources[ability.name] == undefined) {\n                                sources[ability.name] = {\n                                    'radius': self.getAbilityAttributeValue(self._abilities[i].attributes, 'radius', ability.level()),\n                                    'magnitude': 1,\n                                    'count': 1,\n                                    'displayname': ability.displayname\n                                }\n                            }\n                            else {\n                                sources[ability.name].count += 1;\n                            }\n                        break;\n                        // tiny_grow\n                        case 'tiny_grow':\n                            if (self.hasScepter()) {\n                                if (sources[ability.name] == undefined) {\n                                    sources[ability.name] = {\n                                        'radius': self.getAbilityAttributeValue(self._abilities[i].attributes, 'bonus_cleave_radius_scepter', ability.level()),\n                                        'magnitude': self.getAbilityAttributeValue(self._abilities[i].attributes, 'bonus_cleave_damage_scepter', ability.level())/100,\n                                        'count': 1,\n                                        'displayname': ability.displayname\n                                    }\n                                }\n                                else {\n                                    sources[ability.name].count += 1;\n                                }\n                            }\n                        break;\n                    }\n                }\n            }\n        }\n        return sources;\n    });    \n    \n    self.getCritChance = ko.computed(function () {\n        var totalAttribute = 1;\n        for (var i = 0; i < self.abilities().length; i++) {\n            var ability = self._abilities[i];\n            if (ability.level() > 0 && (ability.isActive() || (ability.behavior.indexOf('DOTA_ABILITY_BEHAVIOR_PASSIVE') != -1))) {\n                if (!(ability.name in self.abilityData)) {\n                    for (var j = 0; j < self._abilities[i].attributes.length; j++) {\n                        var attribute = self._abilities[i].attributes[j];\n                        switch(attribute.name) {\n                            // phantom_assassin_coup_de_grace,brewmaster_drunken_brawler,chaos_knight_chaos_strike,lycan_shapeshift,skeleton_king_mortal_strike\n                            case 'crit_chance':\n                                totalAttribute *= (1 - self.getAbilityAttributeValue(self._abilities[i].attributes, attribute.name, ability.level())/100);\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n        return totalAttribute;\n    });\n    \n    self.getEvasion = ko.computed(function () {\n        var totalAttribute = 1;\n        for (var i = 0; i < self.abilities().length; i++) {\n            var ability = self._abilities[i];\n            if (ability.level() > 0 && (ability.isActive() || (ability.behavior.indexOf('DOTA_ABILITY_BEHAVIOR_PASSIVE') != -1))) {\n                if (!(ability.name in self.abilityData)) {\n                    for (var j = 0; j < self._abilities[i].attributes.length; j++) {\n                        var attribute = self._abilities[i].attributes[j];\n                        switch(attribute.name) {\n                            // windrunner_windrun\n                            case 'evasion_pct_tooltip':\n                                totalAttribute = 0;\n                            break;\n                            // phantom_assassin_blur\n                            case 'bonus_evasion':\n                            // brewmaster_drunken_brawler\n                            case 'dodge_chance':\n                                totalAttribute *= (1 - self.getAbilityAttributeValue(self._abilities[i].attributes, attribute.name, ability.level())/100);\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n        return totalAttribute;\n    });\n    \n    self.getEvasionBacktrack = ko.computed(function () {\n        var totalAttribute = 1;\n        for (var i = 0; i < self.abilities().length; i++) {\n            var ability = self._abilities[i];\n            if (ability.level() > 0 && (ability.isActive() || (ability.behavior.indexOf('DOTA_ABILITY_BEHAVIOR_PASSIVE') != -1))) {\n                if (!(ability.name in self.abilityData)) {\n                    for (var j = 0; j < self._abilities[i].attributes.length; j++) {\n                        var attribute = self._abilities[i].attributes[j];\n                        switch(attribute.name) {\n                            // faceless_void_backtrack\n                            case 'dodge_chance_pct':\n                                totalAttribute *= (1 - self.getAbilityAttributeValue(self._abilities[i].attributes, attribute.name, ability.level())/100);\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n        return totalAttribute;\n    });\n    \n    self.getBlindSource = ko.computed(function () {\n        var totalAttribute = 0;\n        var sources = [];\n        for (var i = 0; i < self.abilities().length; i++) {\n            var ability = self._abilities[i];\n            if (ability.level() > 0 && (ability.isActive() || (ability.behavior.indexOf('DOTA_ABILITY_BEHAVIOR_PASSIVE') != -1))) {\n                if (!(ability.name in self.abilityData)) {\n                    for (var j = 0; j < self._abilities[i].attributes.length; j++) {\n                        var attribute = self._abilities[i].attributes[j];\n                        switch(attribute.name) {\n                            // broodmother_incapacitating_bite,brewmaster_drunken_haze\n                            case 'miss_chance':\n                            // riki_smoke_screen,keeper_of_the_light_blinding_light,tinker_laser\n                            case 'miss_rate':\n                                var value = self.getAbilityAttributeValue(self._abilities[i].attributes, attribute.name, ability.level())/100;\n                                totalAttribute += value;\n                                sources.push({\n                                    'value': value,\n                                    'displayname': ability.displayname\n                                });\n                            break;\n                        }\n                    }\n                }\n                else if (ability.missChance != undefined) {\n                    // night_stalker_crippling_fear\n                    var value = ability.missChance()/100;\n                    totalAttribute += value;\n                    sources.push({\n                        'value': value,\n                        'displayname': ability.displayname\n                    });\n                }\n            }\n        }\n        return { sources: sources, total: totalAttribute };\n    });\n    \n    self.getLifesteal = ko.computed(function () {\n        var totalAttribute = 0;\n        for (var i = 0; i < self.abilities().length; i++) {\n            var ability = self._abilities[i];\n            if (ability.level() > 0 && (ability.isActive() || (ability.behavior.indexOf('DOTA_ABILITY_BEHAVIOR_PASSIVE') != -1))) {\n                if (!(ability.name in self.abilityData)) {\n                    for (var j = 0; j < self._abilities[i].attributes.length; j++) {\n                        var attribute = self._abilities[i].attributes[j];\n                        switch(attribute.name) {\n                            // skeleton_king_vampiric_aura\n                            case 'vampiric_aura':\n                            // broodmother_insatiable_hunger\n                            case 'lifesteal_pct':\n                                totalAttribute += self.getAbilityAttributeValue(self._abilities[i].attributes, attribute.name, ability.level());\n                            break;\n                        }\n                    }\n                }\n                else if (ability.lifesteal != undefined) {\n                    // life_stealer_open_wounds\n                    totalAttribute+=ability.lifesteal();\n                }\n            }\n        }\n        return totalAttribute;\n    });\n\n    self.getSpellAmp = ko.computed(function () {\n        return new StatModel();\n    });\n    \n    self.getUniqueCooldownReductionFlat = function (ability) {\n        var cooldownMap = TalentController.getUniqueCooldownReductionFlat(self.hero.selectedTalents());\n        return cooldownMap[ability] || 0;\n    }\n    \n    self.getCooldownReductionFlat = ko.computed(function () {\n        var totalAttribute = 0;\n        for (var i = 0; i < self.abilities().length; i++) {\n            var ability = self._abilities[i];\n            if (ability.level() > 0 && (ability.isActive() || (ability.behavior.indexOf('DOTA_ABILITY_BEHAVIOR_PASSIVE') != -1))) {\n                if (!(ability.name in self.abilityData)) {\n                    for (var j = 0; j < self._abilities[i].attributes.length; j++) {\n                        var attribute = self._abilities[i].attributes[j];\n                        switch(attribute.name) {\n                            // keeper_of_the_light_chakra_magic\n                            case 'cooldown_reduction':\n                                totalAttribute += self.getAbilityAttributeValue(self._abilities[i].attributes, attribute.name, ability.level());\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n        return totalAttribute;\n    });\n\n    self.getCooldownReductionPercent = ko.computed(function () {\n        var totalAttribute = 1;\n        return totalAttribute;\n    });\n\n    self.getCooldownIncreaseFlat = ko.computed(function () {\n        var totalAttribute = 0;\n        for (var i = 0; i < self.abilities().length; i++) {\n            var ability = self._abilities[i];\n            if (ability.level() > 0 && (ability.isActive() || (ability.behavior.indexOf('DOTA_ABILITY_BEHAVIOR_PASSIVE') != -1))) {\n                if (!(ability.name in self.abilityData)) {\n                    for (var j = 0; j < self._abilities[i].attributes.length; j++) {\n                        var attribute = self._abilities[i].attributes[j];\n                        switch(attribute.name) {\n                            // faceless_void_time_dilation\n                            case 'duration':\n                                if (ability.name == 'faceless_void_time_dilation') {\n                                    totalAttribute += self.getAbilityAttributeValue(self._abilities[i].attributes, attribute.name, ability.level());\n                                }\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n        return totalAttribute;\n    });\n\n    self.getCooldownIncreasePercent = ko.computed(function () {\n        var totalAttribute = 1;\n        return totalAttribute;\n    });\n    \n    self.getMagicResist = ko.computed(function () {\n        var totalAttribute = 1;\n        for (var i = 0; i < self.abilities().length; i++) {\n            var ability = self._abilities[i];\n            if (ability.level() > 0 && (ability.isActive() || (ability.behavior.indexOf('DOTA_ABILITY_BEHAVIOR_PASSIVE') != -1))) {\n                if (!(ability.name in self.abilityData)) {\n                    for (var j = 0; j < self._abilities[i].attributes.length; j++) {\n                        var attribute = self._abilities[i].attributes[j];\n                        switch(attribute.name) {\n                            // antimage_spell_shield\n                            case 'spell_shield_resistance':\n                                totalAttribute *= (1 - self.getAbilityAttributeValue(self._abilities[i].attributes, attribute.name, ability.level())/100);\n                            break;\n                            // phantom_lancer_phantom_edge\n                            case 'magic_resistance_pct':\n                                if (ability.name == 'phantom_lancer_phantom_edge') {\n                                    totalAttribute *= (1 - self.getAbilityAttributeValue(self._abilities[i].attributes, attribute.name, ability.level())/100);\n                                }\n                            break;\n                            // rubick_null_field\n                            case 'magic_damage_reduction_pct':\n                                if (ability.name == 'rubick_null_field') {\n                                    totalAttribute *= (1 - self.getAbilityAttributeValue(self._abilities[i].attributes, attribute.name, ability.level())/100);\n                                }\n                            break;\n                        }\n                    }\n                }\n                else if (ability.magicResist != undefined) {\n                    // huskar_berserkers_blood,viper_corrosive_skin,visage_gravekeepers_cloak\n                    totalAttribute *= (1 - ability.magicResist()/100);\n                }\n            }\n        }\n        return totalAttribute;\n    });\n\n    self.getMagicResistReduction = ko.computed(function () {\n        var totalAttribute = 1;\n        for (var i = 0; i < self.abilities().length; i++) {\n            var ability = self._abilities[i];\n            if (ability.level() > 0 && (ability.isActive() || (ability.behavior.indexOf('DOTA_ABILITY_BEHAVIOR_PASSIVE') != -1))) {\n                if (!(ability.name in self.abilityData)) {\n                    for (var j = 0; j < self._abilities[i].attributes.length; j++) {\n                        var attribute = self._abilities[i].attributes[j];\n                        switch(attribute.name) {\n                            // ancient_apparition_ice_vortex\n                            case 'spell_resist_pct':\n                            // pugna_decrepify\n                            case 'bonus_spell_damage_pct':\n                            // skywrath_mage_ancient_seal\n                            case 'resist_debuff':\n                                totalAttribute *= (1 - self.getAbilityAttributeValue(self._abilities[i].attributes, attribute.name, ability.level())/100);\n                            break;\n                            // elder_titan_natural_order\n                            case 'magic_resistance_pct':\n                                totalAttribute *= (1 - self.getAbilityAttributeValue(self._abilities[i].attributes, attribute.name, ability.level())/100);\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n        return totalAttribute;\n    });\n    \n    self.getMovementSpeedFlat = ko.computed(function () {\n        var totalAttribute = 0;\n        for (var i = 0; i < self.abilities().length; i++) {\n            var ability = self._abilities[i];\n            if (ability.level() > 0 && (ability.isActive() || (ability.behavior.indexOf('DOTA_ABILITY_BEHAVIOR_PASSIVE') != -1))) {\n                if (!(ability.name in self.abilityData)) {\n                    for (var j = 0; j < self._abilities[i].attributes.length; j++) {\n                        var attribute = self._abilities[i].attributes[j];\n                        switch(attribute.name) {\n                            // alchemist_chemical_rage\n                            case 'bonus_movespeed':\n                                if (ability.name == 'alchemist_chemical_rage') {\n                                    totalAttribute += self.getAbilityAttributeValue(self._abilities[i].attributes, attribute.name, ability.level());\n                                }\n                            break;\n                            // tiny_grow\n                            case 'bonus_movement_speed':\n                                if (ability.name == 'tiny_grow') {\n                                    totalAttribute += self.getAbilityAttributeValue(self._abilities[i].attributes, attribute.name, ability.level());\n                                }\n                            break;\n                            // troll_warlord_berserkers_rage\n                            case 'bonus_move_speed':\n                                if (ability.name == 'troll_warlord_berserkers_rage') {\n                                    totalAttribute += self.getAbilityAttributeValue(self._abilities[i].attributes, attribute.name, ability.level());\n                                }                                \n                            break;\n                            // lone_druid_true_form\n                            case 'speed_loss':\n                                totalAttribute -= self.getAbilityAttributeValue(self._abilities[i].attributes, attribute.name, ability.level());\n                            break;\n                        }\n                    }\n                }\n                else if (ability.movementSpeedFlat != undefined) {\n                // dragon_knight_elder_dragon_form\n                    totalAttribute+=ability.movementSpeedFlat();\n                }\n            }\n        }\n        return totalAttribute;\n    });\n    \n    self.getMovementSpeedPercent = ko.computed(function () {\n        var totalAttribute = 0;\n        for (var i = 0; i < self.abilities().length; i++) {\n            var ability = self._abilities[i];\n            if (ability.level() > 0 && (ability.isActive() || (ability.behavior.indexOf('DOTA_ABILITY_BEHAVIOR_PASSIVE') != -1))) {\n                if (!(ability.name in self.abilityData)) {\n                    for (var j = 0; j < self._abilities[i].attributes.length; j++) {\n                        var attribute = self._abilities[i].attributes[j];\n                        switch(attribute.name) {\n                            // abaddon_frostmourne \n                            case 'move_speed_pct':\n                            // bounty_hunter_track \n                            case 'bonus_move_speed_pct':\n                            // mirana_leap \n                            case 'leap_speedbonus':\n                            // sven_warcry \n                            case 'warcry_movespeed':\n                            // clinkz_wind_walk\n                            case 'move_speed_bonus_pct':\n                            // windrunner_windrun\n                            case 'movespeed_bonus_pct':\n                                totalAttribute += self.getAbilityAttributeValue(self._abilities[i].attributes, attribute.name, ability.level())/100;\n                            break;\n                            // broodmother_spin_web,spectre_spectral_dagger\n                            case 'bonus_movespeed':\n                                if (ability.name == 'broodmother_spin_web' || ability.name == 'spectre_spectral_dagger') {\n                                    totalAttribute += self.getAbilityAttributeValue(self._abilities[i].attributes, attribute.name, ability.level())/100;\n                                }\n                            break;\n                            // axe_culling_blade,necronomicon_archer_aoe\n                            case 'speed_bonus':\n                                if (ability.name == 'axe_culling_blade' || ability.name == 'necronomicon_archer_aoe') {\n                                    totalAttribute += self.getAbilityAttributeValue(self._abilities[i].attributes, attribute.name, ability.level())/100;\n                                }\n                            break;\n                            // nyx_assassin_vendetta \n                            case 'movement_speed':\n                                if (ability.name == 'nyx_assassin_vendetta') {\n                                    totalAttribute += self.getAbilityAttributeValue(self._abilities[i].attributes, attribute.name, ability.level())/100;\n                                }\n                            break;\n                            // spirit_breaker_empowering_haste\n                            case 'bonus_movespeed_pct':\n                                if (ability.name == 'spirit_breaker_empowering_haste') {\n                                    totalAttribute += self.getAbilityAttributeValue(self._abilities[i].attributes, attribute.name, ability.level())/100;\n                                }\n                            break;\n                            // ogre_magi_bloodlust,death_prophet_witchcraft,kobold_taskmaster_speed_aura\n                            case 'bonus_movement_speed':\n                                if (ability.name == 'ogre_magi_bloodlust' || ability.name == 'death_prophet_witchcraft' || ability.name == 'kobold_taskmaster_speed_aura') {\n                                    totalAttribute += self.getAbilityAttributeValue(self._abilities[i].attributes, attribute.name, ability.level())/100;\n                                }\n                            break;\n                            // razor_unstable_current,phantom_lancer_doppelwalk\n                            case 'movement_speed_pct':\n                                if (ability.name == 'razor_unstable_current' || ability.name == 'phantom_lancer_doppelwalk') {\n                                    totalAttribute += self.getAbilityAttributeValue(self._abilities[i].attributes, attribute.name, ability.level())/100;\n                                }\n                            break;\n                            // treant_natures_guise,lone_druid_rabid\n                            case 'bonus_move_speed':\n                                if (ability.name == 'treant_natures_guise' || ability.name == 'lone_druid_rabid') {\n                                    totalAttribute += self.getAbilityAttributeValue(self._abilities[i].attributes, attribute.name, ability.level())/100;\n                                }\n                            break;\n                            // wisp_tether\n                            case 'movespeed':\n                                if (ability.name == 'wisp_tether') {\n                                    totalAttribute += self.getAbilityAttributeValue(self._abilities[i].attributes, attribute.name, ability.level())/100;\n                                }\n                            break;\n                            // kunkka_ghostship,visage_grave_chill\n                            case 'movespeed_bonus':\n                                if (ability.name == 'kunkka_ghostship' || ability.name == 'visage_grave_chill') {\n                                    totalAttribute += self.getAbilityAttributeValue(self._abilities[i].attributes, attribute.name, ability.level())/100;\n                                }                                \n                            break;\n                        }\n                    }\n                }\n                else if (ability.movementSpeedPct != undefined) {\n                // axe_battle_hunger,bristleback_warpath,spirit_breaker_greater_bash,lina_fiery_soul,invoker_ghost_walk,invoker_wex,elder_titan_ancestral_spirit\n                    totalAttribute+=ability.movementSpeedPct()/100;\n                }\n            }\n        }\n        return totalAttribute;\n    });\n\n    self.getMovementSpeedPercentReduction = ko.computed(function () {\n        var totalAttribute = 0;\n        for (var i = 0; i < self.abilities().length; i++) {\n            var ability = self._abilities[i];\n            if (ability.level() > 0 && (ability.isActive() || (ability.behavior.indexOf('DOTA_ABILITY_BEHAVIOR_PASSIVE') != -1))) {\n                if (!(ability.name in self.abilityData)) {\n                    for (var j = 0; j < self._abilities[i].attributes.length; j++) {\n                        var attribute = self._abilities[i].attributes[j];\n                        switch(attribute.name) {\n                            // crystal_maiden_freezing_field\n                            case 'movespeed_slow':\n                                if (ability.name == 'crystal_maiden_freezing_field' && !self.hasScepter()) {\n                                    totalAttribute += self.getAbilityAttributeValue(self._abilities[i].attributes, attribute.name, ability.level())/100;\n                                }\n                            break;\n                            case 'movespeed_slow_scepter':\n                                if (ability.name == 'crystal_maiden_freezing_field' && self.hasScepter()) {\n                                    totalAttribute += self.getAbilityAttributeValue(self._abilities[i].attributes, attribute.name, ability.level())/100;\n                                }\n                            break;\n                            // elder_titan_earth_splitter,magnataur_skewer,abaddon_frostmourne \n                            case 'slow_pct':\n                                totalAttribute -= self.getAbilityAttributeValue(self._abilities[i].attributes, attribute.name, ability.level())/100;\n                            break;\n                            // night_stalker_void,crystal_maiden_crystal_nova,ghost_frost_attack,ogre_magi_frost_armor,polar_furbolg_ursa_warrior_thunder_clap\n                            case 'movespeed_slow':\n                                if (ability.name != 'crystal_maiden_freezing_field') {\n                                    totalAttribute += self.getAbilityAttributeValue(self._abilities[i].attributes, attribute.name, ability.level())/100;\n                                }\n                            break;\n                            // lich_frost_armor,lich_frost_nova,enchantress_enchant\n                            case 'slow_movement_speed':\n                            // beastmaster_primal_roar\n                            case 'slow_movement_speed_pct':\n                            // drow_ranger_frost_arrows\n                            case 'frost_arrows_movement_speed':\n                            // skeleton_king_hellfire_blast\n                            case 'blast_slow':\n                            // slardar_slithereen_crush\n                            case 'crush_extra_slow':\n                            // storm_spirit_overload:\n                            case 'overload_move_slow':\n                            // windrunner_windrun\n                            case 'enemy_movespeed_bonus_pct':\n                                totalAttribute += self.getAbilityAttributeValue(self._abilities[i].attributes, attribute.name, ability.level())/100;\n                            break;\n                            // phantom_assassin_stifling_dagger,tusk_frozen_sigil\n                            case 'move_slow':\n                                if (ability.name == 'phantom_assassin_stifling_dagger') {\n                                    totalAttribute += self.getAbilityAttributeValue(self._abilities[i].attributes, attribute.name, ability.level())/100;\n                                }\n                                else if (ability.name == 'tusk_frozen_sigil') {\n                                    totalAttribute -= self.getAbilityAttributeValue(self._abilities[i].attributes, attribute.name, ability.level())/100;\n                                }\n                            break;\n                            // invoker_ice_wall,medusa_stone_gaze,wisp_tether\n                            case 'slow':\n                                if (ability.name == 'medusa_stone_gaze') {\n                                    totalAttribute -= self.getAbilityAttributeValue(self._abilities[i].attributes, attribute.name, ability.level())/100;\n                                }\n                                else {\n                                    totalAttribute += self.getAbilityAttributeValue(self._abilities[i].attributes, attribute.name, ability.level())/100;\n                                }\n                            break;\n                            // broodmother_incapacitating_bite,bounty_hunter_jinada,spectre_spectral_dagger,winter_wyvern_arctic_burn\n                            case 'bonus_movespeed':\n                                if (ability.name == 'broodmother_incapacitating_bite' || ability.name == 'bounty_hunter_jinada' || ability.name == 'winter_wyvern_arctic_burn' || ability.name == 'winter_wyvern_splinter_blast') {\n                                    totalAttribute += self.getAbilityAttributeValue(self._abilities[i].attributes, attribute.name, ability.level())/100;\n                                }\n                                else if (ability.name == 'spectre_spectral_dagger') {\n                                    totalAttribute -= self.getAbilityAttributeValue(self._abilities[i].attributes, attribute.name, ability.level())/100;\n                                }\n                            break;\n                            // omniknight_degen_aura\n                            case 'speed_bonus':\n                                if (ability.name == 'omniknight_degen_aura') {\n                                    totalAttribute += self.getAbilityAttributeValue(self._abilities[i].attributes, attribute.name, ability.level())/100;\n                                }\n                            break;\n                            // tidehunter_gush\n                            case 'movement_speed':\n                                if (ability.name == 'tidehunter_gush') {\n                                    totalAttribute += self.getAbilityAttributeValue(self._abilities[i].attributes, attribute.name, ability.level())/100;\n                                }\n                            break;\n                            // pugna_decrepify,chen_penitence\n                            case 'bonus_movement_speed':\n                                if (ability.name == 'pugna_decrepify' || ability.name == 'chen_penitence') {\n                                    totalAttribute += self.getAbilityAttributeValue(self._abilities[i].attributes, attribute.name, ability.level())/100;\n                                }\n                            break;\n                            // ancient_apparition_ice_vortex,phantom_lancer_spirit_lance,skywrath_mage_concussive_shot,faceless_void_time_walk\n                            case 'movement_speed_pct':\n                                if (ability.name == 'ancient_apparition_ice_vortex' || ability.name == 'phantom_lancer_spirit_lance' || ability.name == 'faceless_void_time_walk') {\n                                    totalAttribute += self.getAbilityAttributeValue(self._abilities[i].attributes, attribute.name, ability.level())/100;\n                                }\n                                else if (ability.name == 'skywrath_mage_concussive_shot') {\n                                    totalAttribute -= self.getAbilityAttributeValue(self._abilities[i].attributes, attribute.name, ability.level())/100;\n                                }\n                            break;\n                            // razor_unstable_current\n                            case 'slow_amount':\n                                if (ability.name == 'razor_unstable_current') {\n                                    totalAttribute += self.getAbilityAttributeValue(self._abilities[i].attributes, attribute.name, ability.level())/100;\n                                }\n                            break;\n                            // brewmaster_drunken_haze,brewmaster_thunder_clap,treant_leech_seed\n                            case 'movement_slow':\n                                if (ability.name == 'brewmaster_drunken_haze' || ability.name == 'brewmaster_thunder_clap') {\n                                    totalAttribute -= self.getAbilityAttributeValue(self._abilities[i].attributes, attribute.name, ability.level())/100;\n                                }\n                                else if (ability.name == 'ursa_earthshock' || ability.name == 'treant_leech_seed') {\n                                    totalAttribute += self.getAbilityAttributeValue(self._abilities[i].attributes, attribute.name, ability.level())/100;\n                                }\n                            break;\n                            // skeleton_king_reincarnation\n                            case 'movespeed':\n                                if (ability.name == 'skeleton_king_reincarnation') {\n                                    totalAttribute += self.getAbilityAttributeValue(self._abilities[i].attributes, attribute.name, ability.level())/100;\n                                }\n                            break;\n                            // kunkka_torrent,visage_grave_chill\n                            case 'movespeed_bonus':\n                                if (ability.name == 'kunkka_torrent') {\n                                    totalAttribute += self.getAbilityAttributeValue(self._abilities[i].attributes, attribute.name, ability.level())/100;\n                                }\n                                else if (ability.name == 'visage_grave_chill') {\n                                    totalAttribute -= self.getAbilityAttributeValue(self._abilities[i].attributes, attribute.name, ability.level())/100;\n                                }\n                            break;\n                        }\n                    }\n                    if (ability.name == 'satyr_trickster_purge') {\n                        totalAttribute -= 80/100;\n                    }\n                    else if (ability.name == 'enraged_wildkin_tornado') {\n                        totalAttribute -= 15/100;\n                    }\n                }\n                else if (ability.movementSpeedPctReduction != undefined) {\n                    // axe_battle_hunger,batrider_sticky_napalm,shredder_chakram,meepo_geostrike,life_stealer_open_wounds,\n                    // venomancer_poison_sting,viper_viper_strike,viper_corrosive_skin,viper_poison_attack,venomancer_venomous_gale,treant_leech_seed\n                    // lich_chain_frost,sniper_shrapnel,centaur_stampede,huskar_life_break,jakiro_dual_breath,meepo_geostrike,sandking_epicenter\n                    // earth_spirit_rolling_boulder,invoker_ghost_walk,invoker_ice_wall,elder_titan_earth_splitter\n                    // undying_flesh_golem,templar_assassin_psionic_trap,nevermore_requiem,queenofpain_shadow_strike\n                    totalAttribute+=ability.movementSpeedPctReduction()/100;\n                }\n            }\n        }\n        return totalAttribute;\n    });\n\n    self.getTurnRateReduction = ko.computed(function () {\n        var totalAttribute = 0;\n        for (var i = 0; i < self.abilities().length; i++) {\n            var ability = self._abilities[i];\n            if (ability.level() > 0 && (ability.isActive() || (ability.behavior.indexOf('DOTA_ABILITY_BEHAVIOR_PASSIVE') != -1))) {\n                if (!(ability.name in self.abilityData)) {\n                    for (var j = 0; j < self._abilities[i].attributes.length; j++) {\n                        var attribute = self._abilities[i].attributes[j];\n                        switch(attribute.name) {\n                            // medusa_stone_gaze\n                            case 'slow':\n                                if (ability.name == 'medusa_stone_gaze') {\n                                    totalAttribute -= self.getAbilityAttributeValue(self._abilities[i].attributes, attribute.name, ability.level())/100;\n                                }\n                            break;\n                        }\n                    }\n                }\n                else if (ability.turnRateReduction != undefined) {\n                    // batrider_sticky_napalm\n                    totalAttribute+=ability.turnRateReduction()/100;\n                }\n            }\n        }\n        return totalAttribute;\n    });\n    \n    self.getVisionRangeNight = ko.computed(function () {\n        var totalAttribute = 0;\n        for (var i = 0; i < self.abilities().length; i++) {\n            var ability = self._abilities[i];\n            if (ability.level() > 0 && (ability.isActive() || (ability.behavior.indexOf('DOTA_ABILITY_BEHAVIOR_PASSIVE') != -1))) {\n                if (!(ability.name in self.abilityData)) {\n                    for (var j = 0; j < self._abilities[i].attributes.length; j++) {\n                        var attribute = self._abilities[i].attributes[j];\n                        switch(attribute.name) {\n                            // winter_wyvern_arctic_burn\n                            case 'night_vision_bonus':\n                            // lycan_shapeshift,luna_lunar_blessing\n                            case 'bonus_night_vision':\n                                totalAttribute += self.getAbilityAttributeValue(self._abilities[i].attributes, attribute.name, ability.level());\n                            break;\n                        }\n                    }\n                }\n                else if (ability.visionnight != undefined) {\n                    // \n                    totalAttribute+=ability.visionnight();\n                }\n            }\n        }\n        return totalAttribute;\n    });\n\n    self.getVisionRangePctReduction = ko.computed(function () {\n        var totalAttribute = 0;\n        for (var i = 0; i < self.abilities().length; i++) {\n            var ability = self._abilities[i];\n            if (ability.level() > 0 && (ability.isActive() || (ability.behavior.indexOf('DOTA_ABILITY_BEHAVIOR_PASSIVE') != -1))) {\n                if (!(ability.name in self.abilityData)) {\n                    for (var j = 0; j < self._abilities[i].attributes.length; j++) {\n                        var attribute = self._abilities[i].attributes[j];\n                        switch(attribute.name) {\n                            // night_stalker_darkness\n                            case 'blind_percentage':\n                                totalAttribute += self.getAbilityAttributeValue(self._abilities[i].attributes, attribute.name, ability.level())/100;\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n        return totalAttribute;\n    });\n\n    self.setEvasion = ko.computed(function () {\n        var totalAttribute = 0;\n        for (var i = 0; i < self.abilities().length; i++) {\n            var ability = self._abilities[i];\n            if (ability.level() > 0 && (ability.isActive() || (ability.behavior.indexOf('DOTA_ABILITY_BEHAVIOR_PASSIVE') != -1))) {\n                if (ability.name == 'windrunner_windrun') {\n                    return 1;\n                }\n            }\n        }\n        return totalAttribute;\n    });\n    \n    self.setMovementSpeed = ko.computed(function () {\n        var MAX_MOVESPEED = 522;\n        var MIN_MOVESPEED = 100;\n        var totalAttribute = 0;\n        for (var i = 0; i < self.abilities().length; i++) {\n            var ability = self._abilities[i];\n            if (ability.level() > 0 && (ability.isActive() || (ability.behavior.indexOf('DOTA_ABILITY_BEHAVIOR_PASSIVE') != -1))) {\n                if (ability.name == 'spirit_breaker_charge_of_darkness') {\n                    return self.getAbilityAttributeValue(ability.attributes, 'movement_speed', ability.level());\n                }\n                if (ability.name == 'dark_seer_surge') {\n                    return MAX_MOVESPEED;\n                }\n                if (ability.name == 'centaur_stampede') {\n                    return MAX_MOVESPEED;\n                }\n                if (ability.name == 'lycan_shapeshift') {\n                    return MAX_MOVESPEED;\n                }\n                if (ability.name == 'lion_voodoo' || ability.name == 'shadow_shaman_voodoo') {\n                    return MIN_MOVESPEED;\n                }\n            }\n        }\n        return totalAttribute;\n    });\n\n    self.getBashSource = function (attacktype) {\n        var sources = {};\n        for (var i = 0; i < self.abilities().length; i++) {\n            var ability = self._abilities[i];\n            if (ability.level() > 0 && (ability.isActive() || (ability.behavior.indexOf('DOTA_ABILITY_BEHAVIOR_PASSIVE') != -1))) {\n                if (!(ability.name in self.abilityData)) {\n                    for (var j = 0; j < self._abilities[i].attributes.length; j++) {\n                        var attribute = self._abilities[i].attributes[j];\n                        switch(attribute.name) {\n                            // sniper_headshot\n                            case 'proc_chance':\n                                if (sources[ability.name] == undefined && ability.name == 'sniper_headshot') {\n                                    sources[ability.name] = {\n                                        'chance': self.getAbilityAttributeValue(ability.attributes, attribute.name, ability.level())/100,\n                                        'damage': self.getAbilityPropertyValue(ability, 'damage'),\n                                        'count': 1,\n                                        'damageType': 'physical',\n                                        'displayname': ability.displayname\n                                    }\n                                }\n                            break;\n                            // slardar_bash\n                            case 'chance':\n                                if (sources[ability.name] == undefined && ability.name == 'slardar_bash') {\n                                    sources[ability.name] = {\n                                        'chance': self.getAbilityAttributeValue(ability.attributes, attribute.name, ability.level())/100,\n                                        'damage': self.getAbilityAttributeValue(ability.attributes, 'bonus_damage', ability.level()),\n                                        'count': 1,\n                                        'damageType': 'physical',\n                                        'displayname': ability.displayname\n                                    }\n                                }\n                            break;\n                        }\n                    }\n                }\n                else if (ability.bashBonusDamage != undefined) {\n                    // faceless_void_time_lock\n                    if (sources[ability.name] == undefined && ability.name == 'faceless_void_time_lock') {\n                        sources[ability.name] = {\n                            'chance': ability.bash()/100,\n                            'damage': ability.bashBonusDamage(),\n                            'count': 1,\n                            'damageType': 'magic',\n                            'displayname': ability.displayname\n                        }\n                    }\n                    // spirit_breaker_greater_bash\n                    if (sources[ability.name] == undefined && ability.name == 'spirit_breaker_greater_bash') {\n                        sources[ability.name] = {\n                            'chance': ability.bash()/100,\n                            'damage': ability.bashBonusDamage()/100,\n                            'count': 1,\n                            'damageType': 'magic',\n                            'displayname': ability.displayname\n                        }\n                    }\n                }\n            }\n        }\n\n        return sources;\n    };\n    \n    self.getOrbSource = function () {\n        var sources = {};\n        for (var i = 0; i < self.abilities().length; i++) {\n            var ability = self._abilities[i];\n            if (ability.level() > 0 && (ability.isActive() || (ability.behavior.indexOf('DOTA_ABILITY_BEHAVIOR_PASSIVE') != -1))) {\n                if (!(ability.name in self.abilityData)) {\n                    for (var j = 0; j < self._abilities[i].attributes.length; j++) {\n                        var attribute = self._abilities[i].attributes[j];\n                        switch(attribute.name) {\n                            // antimage_mana_break\n                            case 'mana_per_hit':\n                                if (sources[ability.name] == undefined && ability.name == 'antimage_mana_break') {\n                                    sources[ability.name] = {\n                                        'damage': self.getAbilityAttributeValue(ability.attributes, attribute.name, ability.level()) \n                                                * self.getAbilityAttributeValue(ability.attributes, 'damage_per_burn', ability.level()),\n                                        'damageType': 'physical',\n                                        'displayname': ability.displayname\n                                    }\n                                }\n                            break;\n                            // clinkz_searing_arrows\n                            case 'damage_bonus':\n                                if (sources[ability.name] == undefined && ability.name == 'clinkz_searing_arrows') {\n                                    sources[ability.name] = {\n                                        'damage': self.getAbilityAttributeValue(ability.attributes, attribute.name, ability.level()),\n                                        'damageType': 'physical',\n                                        'displayname': ability.displayname\n                                    }\n                                }\n                            // silencer_glaives_of_wisdom\n                            case 'intellect_damage_pct':\n                                if (sources[ability.name] == undefined && ability.name == 'silencer_glaives_of_wisdom') {\n                                    sources[ability.name] = {\n                                        'damage': self.getAbilityAttributeValue(ability.attributes, attribute.name, ability.level())/100 * self.hero.totalInt().total,\n                                        'damageType': 'pure',\n                                        'displayname': ability.displayname\n                                    }\n                                }\n                            break;\n                        }\n                    }\n                }\n                else if (ability.bonusDamageOrb != undefined) {\n                    // obsidian_destroyer_arcane_orb\n                    if (sources[ability.name] == undefined && ability.name == 'obsidian_destroyer_arcane_orb') {\n                        sources[ability.name] = {\n                            'damage': ability.bonusDamageOrb(),\n                            'damageType': 'pure',\n                            'displayname': ability.displayname\n                        }\n                    }\n                }\n            }\n        }\n        \n        return sources;\n    };\n    \n    self.toggleAbility = function (index, data, event) {\n        if (self.abilities()[index()].behavior.indexOf('DOTA_ABILITY_BEHAVIOR_PASSIVE') < 0) {\n            if (self.abilities()[index()].isActive()) {\n                self.abilities()[index()].isActive(false);\n            }\n            else {\n                self.abilities()[index()].isActive(true);\n            }\n            \n            if (self.abilities()[index()].name == 'lycan_shapeshift') {\n                self.isShapeShiftActive(self.abilities()[index()].isActive());\n            }\n        }\n    }.bind(this);\n\n    self.toggleAbilityDetail = function (index, data, event) {\n        if (self.abilities()[index()].isDetail()) {\n            self.abilities()[index()].isDetail(false);\n        }\n        else {\n            self.abilities()[index()].isDetail(true);\n        }\n    }.bind(this);\n    \n    self.getAbility = function (abilityName) {\n        return self.abilities().find(function(b) {\n            return b.name == abilityName;\n        });\n    }\n}\n\nAbilityModel.prototype.levelUpAbility = function (index, data, event, hero) {\n    var self = this;\n    if (self.abilities()[index()].level() < hero.getAbilityLevelMax(data) && hero.availableSkillPoints() > 0 ) {\n        switch(self.abilities()[index()].abilitytype) {\n            case 'DOTA_ABILITY_TYPE_ULTIMATE':\n                if (hero.heroId() == 'invoker') {\n                    if (\n                        (self.abilities()[index()].level() == 0) && (parseInt(hero.selectedHeroLevel()) >= 2) ||\n                        (self.abilities()[index()].level() == 1) && (parseInt(hero.selectedHeroLevel()) >= 7) ||\n                        (self.abilities()[index()].level() == 2) && (parseInt(hero.selectedHeroLevel()) >= 11) ||\n                        (self.abilities()[index()].level() == 3) && (parseInt(hero.selectedHeroLevel()) >= 17)\n                    ) {\n                        self.abilities()[index()].level(self.abilities()[index()].level()+1);\n                        hero.skillPointHistory.push(index());\n                    }\n                }\n                else if (hero.heroId() == 'meepo') {\n                    if (self.abilities()[index()].level() * 7 + 3 <= parseInt(hero.selectedHeroLevel())) {\n                        self.abilities()[index()].level(self.abilities()[index()].level()+1);\n                        hero.skillPointHistory.push(index());\n                    }\n                }\n                else {\n                    if ((self.abilities()[index()].level()+1) * 5 + 1 <= parseInt(hero.selectedHeroLevel())) {\n                        self.abilities()[index()].level(self.abilities()[index()].level()+1);\n                        hero.skillPointHistory.push(index());\n                    }\n                }\n            break;\n            default:\n                if (self.abilities()[index()].level() * 2 + 1 <= parseInt(hero.selectedHeroLevel())) {\n                    self.abilities()[index()].level(self.abilities()[index()].level()+1);\n                    hero.skillPointHistory.push(index());\n                }\n            break;\n        }\n        switch (self.abilities()[index()].name) {\n            case 'beastmaster_call_of_the_wild':\n            case 'chen_test_of_faith':\n            case 'morphling_morph_agi':\n            case 'shadow_demon_shadow_poison':\n                self.abilities()[index() + 1].level(self.abilities()[index()].level());\n            break;\n            case 'morphling_morph_str':\n                self.abilities()[index() - 1].level(self.abilities()[index()].level());\n            break;\n            case 'keeper_of_the_light_spirit_form':\n                self.abilities()[index() - 1].level(self.abilities()[index()].level());\n                self.abilities()[index() - 2].level(self.abilities()[index()].level());\n            break;\n            case 'nevermore_shadowraze1':\n                self.abilities()[index() + 1].level(self.abilities()[index()].level());\n                self.abilities()[index() + 2].level(self.abilities()[index()].level());\n            break;\n            case 'nevermore_shadowraze2':\n                self.abilities()[index() - 1].level(self.abilities()[index()].level());\n                self.abilities()[index() + 1].level(self.abilities()[index()].level());\n            break;\n            case 'nevermore_shadowraze3':\n                self.abilities()[index() - 1].level(self.abilities()[index()].level());\n                self.abilities()[index() - 2].level(self.abilities()[index()].level());\n            break;\n            case 'ember_spirit_fire_remnant':\n                self.abilities()[index() - 1].level(self.abilities()[index()].level());\n            break;\n            case 'lone_druid_true_form':\n                self.abilities()[index() - 1].level(self.abilities()[index()].level());\n            break;\n            case 'monkey_king_tree_dance':\n                self.abilities()[index() + 1].level(self.abilities()[index()].level());\n            break;\n        }\n    }\n};\nAbilityModel.prototype.levelDownAbility = function (index, data, event, hero) {\n    var i = ko.utils.unwrapObservable(index);\n    var self = this;\n    if (self.abilities()[i].level() > 0) {\n        self.abilities()[i].level(self.abilities()[i].level() - 1);\n        hero.skillPointHistory.splice(hero.skillPointHistory().lastIndexOf(i), 1);\n        switch (self.abilities()[i].name) {\n            case 'beastmaster_call_of_the_wild':\n            case 'chen_test_of_faith':\n            case 'morphling_morph_agi':\n            case 'shadow_demon_shadow_poison':\n                self.abilities()[i + 1].level(self.abilities()[i].level());\n            break;\n            case 'morphling_morph_str':\n                self.abilities()[i - 1].level(self.abilities()[i].level());\n            break;\n            case 'keeper_of_the_light_spirit_form':\n                self.abilities()[i - 1].level(self.abilities()[i].level());\n                self.abilities()[i - 2].level(self.abilities()[i].level());\n            break;\n            case 'nevermore_shadowraze1':\n                self.abilities()[i + 1].level(self.abilities()[i].level());\n                self.abilities()[i + 2].level(self.abilities()[i].level());\n            break;\n            case 'nevermore_shadowraze2':\n                self.abilities()[i - 1].level(self.abilities()[i].level());\n                self.abilities()[i + 1].level(self.abilities()[i].level());\n            break;\n            case 'nevermore_shadowraze3':\n                self.abilities()[i - 1].level(self.abilities()[i].level());\n                self.abilities()[i - 2].level(self.abilities()[i].level());\n            break;\n            case 'ember_spirit_fire_remnant':\n                self.abilities()[i - 1].level(self.abilities()[i].level());\n            break;\n            case 'lone_druid_true_form':\n                self.abilities()[i - 1].level(self.abilities()[i].level());\n            break;\n            case 'monkey_king_tree_dance':\n                self.abilities()[i + 1].level(self.abilities()[i].level());\n            break;\n        }\n    }\n};\nAbilityModel.prototype.getAbilityAttributeValue = function (attributes, attributeName, level) {\n    for (var i=0; i < attributes.length; i++) {\n        if (attributes[i].name == attributeName) {\n            if (level == 0) {\n                return parseFloat(attributes[i].value[0]);\n            }\n            else if (level > attributes[i].value.length) {\n                return parseFloat(attributes[i].value[0]);\n            }\n            else {\n                return parseFloat(attributes[i].value[level-1]);\n            }\n        }\n    }\n}\nAbilityModel.prototype.getAbilityAttributeTooltip = function (attributes, attributeName) {\n    for (var i=0; i<attributes.length; i++) {\n        if (attributes[i].name == attributeName) {\n            if (attributes[i].hasOwnProperty('tooltip')) {\n                var d = attributes[i].tooltip.replace(/\\\\n/g, '');\n                return d;\n            }\n            else {\n                return '';\n            }\n        }\n    }\n    return '';\n}\n\nmodule.exports = AbilityModel;",
    "'use strict';\nvar ko = require('./herocalc_knockout');\n\nvar AbilityModel = require(\"./AbilityModel\");\nvar InventoryViewModel = require(\"./inventory/InventoryViewModel\");\nvar findWhere = require(\"./util/findWhere\");\nvar buffOptionsArray = require(\"./buffs/buffOptionsArray\");\nvar debuffOptionsArray = require(\"./buffs/debuffOptionsArray\");\n\nvar BuffViewModel = function (itemData, a) {\n    var self = this;\n    AbilityModel.call(this, ko.observableArray([]));\n    self.availableBuffs = ko.observableArray(buffOptionsArray.items);\n    self.availableDebuffs = ko.observableArray(debuffOptionsArray.items);\n    self.selectedBuff = ko.observable(self.availableBuffs()[0]);\n    \n    self.buffs = ko.observableArray([]);\n    self.itemBuffs = new InventoryViewModel(itemData);\n    \n    self.addBuff = function (data, event) {\n        if (findWhere(self.buffs(), { name: self.selectedBuff().buffName }) == undefined) {\n            var a = JSON.parse(JSON.stringify(self.selectedBuff().abilityData));\n            a.level = ko.observable(0);\n            a.isActive = ko.observable(false);\n            a.isDetail = ko.observable(false);\n            a.baseDamage = ko.observable(0);\n            a.bash = ko.observable(0);\n            a.bashBonusDamage = ko.observable(0);\n            a.bonusDamage = ko.observable(0);\n            a.bonusDamageOrb = ko.observable(0);\n            a.bonusDamagePct = ko.observable(0);\n            a.bonusDamagePrecisionAura = ko.observable(0);\n            a.bonusDamageReduction = ko.observable(0);\n            a.bonusHealth = ko.observable(0);\n            a.bonusStrength = ko.observable(0);\n            a.bonusStrength2 = ko.observable(0);\n            a.bonusAgility = ko.observable(0);\n            a.bonusAgility2 = ko.observable(0);\n            a.bonusInt = ko.observable(0);\n            a.bonusAllStatsReduction = ko.observable(0);\n            a.damageAmplification = ko.observable(0);\n            a.damageReduction = ko.observable(0);\n            a.evasion = ko.observable(0);\n            a.magicResist = ko.observable(0);\n            a.manaregen = ko.observable(0);\n            a.manaregenreduction = ko.observable(0);\n            a.missChance = ko.observable(0);\n            a.movementSpeedFlat = ko.observable(0);\n            a.movementSpeedPct = ko.observable(0);\n            a.movementSpeedPctReduction = ko.observable(0);\n            a.turnRateReduction = ko.observable(0);\n            a.attackrange = ko.observable(0);\n            a.attackspeed = ko.observable(0);\n            a.attackspeedreduction = ko.observable(0);\n            a.armor = ko.observable(0);\n            a.armorReduction = ko.observable(0);\n            a.healthregen = ko.observable(0);\n            a.lifesteal = ko.observable(0);\n            a.visionnight = ko.observable(0);\n            a.visionday = ko.observable(0);\n            switch (a.name) {\n                case 'invoker_cold_snap':\n                case 'invoker_ghost_walk':\n                case 'invoker_tornado':\n                case 'invoker_emp':\n                case 'invoker_alacrity':\n                case 'invoker_chaos_meteor':\n                case 'invoker_sun_strike':\n                case 'invoker_forge_spirit':\n                case 'invoker_ice_wall':\n                case 'invoker_deafening_blast':\n                    a.level(1);\n                break;\n            }\n            self.abilities.push(a);\n            self.buffs.push({ name: self.selectedBuff().buffName, hero: self.selectedBuff().hero, data: a });\n        }\n    };\n    \n    self.removeBuff = function (data, event, abilityName) {\n        if (findWhere(self.buffs(), { name: abilityName })  != undefined) {\n                self.buffs.remove(findWhere(self.buffs(), { name: abilityName }));\n                if (self.abilityControlData[abilityName] != undefined) {\n                    for (var i = 0; i < self.abilityControlData[abilityName].data.length; i++) {\n                        if (self.abilityControlData[abilityName].data[i].controlVal.dispose != undefined) {\n                            self.abilityControlData[abilityName].data[i].controlVal.dispose();\n                        }\n                        if (self.abilityControlData[abilityName].data[i].clean != undefined) {\n                            self.abilityControlData[abilityName].data[i].clean.dispose();\n                        }\n                    }\n                    self.abilityControlData[abilityName] = undefined;\n                }\n                for (var i = 0; i < self.abilities().length; i++) {\n                    if (self.abilities()[i].name == abilityName) {\n                        self.abilities()[i].level(0);\n                        self.abilities.remove(self.abilities()[i]);\n                        break;\n                    }\n                }\n        }\n    };\n    self.toggleBuff = function (index, data, event) {\n        if (self.buffs()[index()].data.behavior.indexOf('DOTA_ABILITY_BEHAVIOR_PASSIVE') < 0) {\n            if (self.buffs()[index()].data.isActive()) {\n                self.buffs()[index()].data.isActive(false);\n                self.abilities()[index()].isActive(false);\n            }\n            else {\n                self.buffs()[index()].data.isActive(true);\n                self.abilities()[index()].isActive(true);\n            }\n        }\n    }.bind(this);\n\n    self.toggleBuffDetail = function (index, data, event) {\n        if (self.buffs()[index()].data.isDetail()) {\n            self.buffs()[index()].data.isDetail(false);\n        }\n        else {\n            self.buffs()[index()].data.isDetail(true);\n        }\n    }.bind(this);\n\n    // Overrides the ability module function to remove available skill point check\n    self.levelUpAbility = function (index, data, event, hero) {\n        if (self.abilities()[index()].level() < hero.getAbilityLevelMax(data)) {\n            switch(self.abilities()[index()].abilitytype) {\n                case 'DOTA_ABILITY_TYPE_ULTIMATE':\n                    self.abilities()[index()].level(self.abilities()[index()].level() + 1);\n                break;\n                default:\n                    self.abilities()[index()].level(self.abilities()[index()].level() + 1);\n                break;\n            }\n            switch (self.abilities()[index()].name) {\n                case 'beastmaster_call_of_the_wild':\n                case 'chen_test_of_faith':\n                case 'morphling_morph_agi':\n                case 'shadow_demon_shadow_poison':\n                    self.abilities()[index() + 1].level(self.abilities()[index()].level());\n                break;\n                case 'morphling_morph_str':\n                    self.abilities()[index() - 1].level(self.abilities()[index()].level());\n                break;\n                case 'keeper_of_the_light_spirit_form':\n                    self.abilities()[index() - 1].level(self.abilities()[index()].level());\n                    self.abilities()[index() - 2].level(self.abilities()[index()].level());\n                case 'nevermore_shadowraze1':\n                    self.abilities()[index() + 1].level(self.abilities()[index()].level());\n                    self.abilities()[index() + 2].level(self.abilities()[index()].level());\n                break;\n                case 'nevermore_shadowraze2':\n                    self.abilities()[index() - 1].level(self.abilities()[index()].level());\n                    self.abilities()[index() + 1].level(self.abilities()[index()].level());\n                break;\n                case 'nevermore_shadowraze3':\n                    self.abilities()[index() - 1].level(self.abilities()[index()].level());\n                    self.abilities()[index() - 2].level(self.abilities()[index()].level());\n                break;\n            }\n        }\n    };\n    self.levelDownAbility = function (index, data, event, hero) {\n        if (self.abilities()[index()].level() > 0) {\n            self.abilities()[index()].level(self.abilities()[index()].level() - 1);\n            switch (self.abilities()[index()].name) {\n                case 'beastmaster_call_of_the_wild':\n                case 'chen_test_of_faith':\n                case 'morphling_morph_agi':\n                case 'shadow_demon_shadow_poison':\n                    self.abilities()[index() + 1].level(self.abilities()[index()].level());\n                break;\n                case 'morphling_morph_str':\n                    self.abilities()[index() - 1].level(self.abilities()[index()].level());\n                break;\n                case 'keeper_of_the_light_spirit_form':\n                    self.abilities()[index() - 1].level(self.abilities()[index()].level());\n                    self.abilities()[index() - 2].level(self.abilities()[index()].level());\n                case 'nevermore_shadowraze1':\n                    self.abilities()[index() + 1].level(self.abilities()[index()].level());\n                    self.abilities()[index() + 2].level(self.abilities()[index()].level());\n                break;\n                case 'nevermore_shadowraze2':\n                    self.abilities()[index() - 1].level(self.abilities()[index()].level());\n                    self.abilities()[index() + 1].level(self.abilities()[index()].level());\n                break;\n                case 'nevermore_shadowraze3':\n                    self.abilities()[index() - 1].level(self.abilities()[index()].level());\n                    self.abilities()[index() - 2].level(self.abilities()[index()].level());\n                break;\n                case 'ember_spirit_fire_remnant':\n                    self.abilities()[index() - 1].level(self.abilities()[index()].level());\n                break;\n                case 'lone_druid_true_form':\n                    self.abilities()[index() - 1].level(self.abilities()[index()].level());\n                break;\n            }\n        }\n    };\n    \n    return self;\n}\nBuffViewModel.prototype = Object.create(AbilityModel.prototype);\nBuffViewModel.prototype.constructor = BuffViewModel;\n\nmodule.exports = BuffViewModel;",
    "var StatModel = function (value, label, id, formatter) {\n    this.components = [];\n    this.total = 0;\n    this.add(value, label, id, formatter);\n}\n\nStatModel.prototype.push = function (value, label, id, formatter) {\n    this.components.push({\n        value: value,\n        label: label,\n        id: id,\n        formatter: formatter\n    });\n}\n\nStatModel.prototype.add = function (value, label, id, formatter) {\n    if (value) {\n        this.push(value, label, id, formatter);\n        this.total += value;\n    }\n    return this;\n}\n\nStatModel.prototype.mult = function (value, label, id, formatter) {\n    if (value) {\n        this.push(value, label, id, formatter);\n        this.total *= value;\n    }\n    return this;\n}\n\nStatModel.prototype.concat = function (s) {\n    this.components = this.components.concat(s.components);\n    this.total += s.total;\n    return this;\n}\n\nmodule.exports = StatModel;",
    "var findWhere = require(\"../util/findWhere\");\n\nvar BuffModel = function (heroData, unitData, hero, ability) {\n    this.buffName = ability;\n    if (heroData['npc_dota_hero_' + hero] == undefined) {\n        this.hero = hero;\n        this.abilityData = findWhere(unitData[hero].abilities, {name: ability})\n        this.buffDisplayName = unitData[hero].displayname + ' - ' + this.abilityData.displayname;\n    }\n    else {\n        this.hero = 'npc_dota_hero_' + hero;\n        this.abilityData = findWhere(heroData['npc_dota_hero_' + hero].abilities, {name: ability})\n        this.buffDisplayName = heroData['npc_dota_hero_' + hero].displayname + ' - ' + this.abilityData.displayname;        \n        if (ability == 'sven_gods_strength') {\n            this.buffDisplayName += ' (Aura for allies)';\n        }\n    }\n\n};\n\nmodule.exports = BuffModel;",
    "var BuffModel = require(\"./BuffModel\");\n\nvar buffOptionsArray = {};\n\nvar init = function (heroData, unitData) {\n    buffOptionsArray.items = [\n        new BuffModel(heroData, unitData, 'abaddon', 'abaddon_frostmourne'),\n        new BuffModel(heroData, unitData, 'axe', 'axe_culling_blade'),\n        new BuffModel(heroData, unitData, 'beastmaster', 'beastmaster_inner_beast'),\n        new BuffModel(heroData, unitData, 'bloodseeker', 'bloodseeker_bloodrage'),\n        new BuffModel(heroData, unitData, 'bounty_hunter', 'bounty_hunter_track'),\n        new BuffModel(heroData, unitData, 'centaur', 'centaur_stampede'),\n        new BuffModel(heroData, unitData, 'crystal_maiden', 'crystal_maiden_brilliance_aura'),\n        new BuffModel(heroData, unitData, 'dark_seer', 'dark_seer_surge'),\n        new BuffModel(heroData, unitData, 'dazzle', 'dazzle_weave'),\n        new BuffModel(heroData, unitData, 'drow_ranger', 'drow_ranger_trueshot'),\n        new BuffModel(heroData, unitData, 'invoker', 'invoker_alacrity'),\n        new BuffModel(heroData, unitData, 'wisp', 'wisp_tether'),\n        new BuffModel(heroData, unitData, 'wisp', 'wisp_overcharge'),\n        new BuffModel(heroData, unitData, 'kunkka', 'kunkka_ghostship'),\n        new BuffModel(heroData, unitData, 'lich', 'lich_frost_armor'),\n        new BuffModel(heroData, unitData, 'life_stealer', 'life_stealer_open_wounds'),\n        new BuffModel(heroData, unitData, 'luna', 'luna_lunar_blessing'),\n        new BuffModel(heroData, unitData, 'lycan', 'lycan_howl'),\n        new BuffModel(heroData, unitData, 'magnataur', 'magnataur_empower'),\n        new BuffModel(heroData, unitData, 'mirana', 'mirana_leap'),\n        new BuffModel(heroData, unitData, 'ogre_magi', 'ogre_magi_bloodlust'),\n        new BuffModel(heroData, unitData, 'omniknight', 'omniknight_guardian_angel'),\n        new BuffModel(heroData, unitData, 'rubick', 'rubick_null_field'),\n        new BuffModel(heroData, unitData, 'skeleton_king', 'skeleton_king_vampiric_aura'),\n        new BuffModel(heroData, unitData, 'spirit_breaker', 'spirit_breaker_empowering_haste'),\n        new BuffModel(heroData, unitData, 'sven', 'sven_warcry'),\n        new BuffModel(heroData, unitData, 'sven', 'sven_gods_strength'),\n        new BuffModel(heroData, unitData, 'treant', 'treant_living_armor'),\n        new BuffModel(heroData, unitData, 'troll_warlord', 'troll_warlord_battle_trance'),\n        new BuffModel(heroData, unitData, 'vengefulspirit', 'vengefulspirit_command_aura'),\n        new BuffModel(heroData, unitData, 'npc_dota_neutral_alpha_wolf', 'alpha_wolf_critical_strike'),\n        new BuffModel(heroData, unitData, 'npc_dota_neutral_alpha_wolf', 'alpha_wolf_command_aura'),\n        new BuffModel(heroData, unitData, 'npc_dota_neutral_polar_furbolg_ursa_warrior', 'centaur_khan_endurance_aura'),\n        new BuffModel(heroData, unitData, 'npc_dota_neutral_kobold_taskmaster', 'kobold_taskmaster_speed_aura'),\n        new BuffModel(heroData, unitData, 'npc_dota_neutral_ogre_magi', 'ogre_magi_frost_armor'),\n        new BuffModel(heroData, unitData, 'npc_dota_neutral_satyr_hellcaller', 'satyr_hellcaller_unholy_aura'),\n        new BuffModel(heroData, unitData, 'npc_dota_neutral_enraged_wildkin', 'enraged_wildkin_toughness_aura'),\n        new BuffModel(heroData, unitData, 'npc_dota_necronomicon_archer_1', 'necronomicon_archer_aoe')\n    ];\n    return buffOptionsArray.items;\n}\n\nbuffOptionsArray.init = init;\n\nmodule.exports = buffOptionsArray;",
    "var BuffModel = require(\"./BuffModel\");\n\nvar debuffOptionsArray = {};\n\nvar init = function (heroData, unitData) {\n    debuffOptionsArray.items = [\n        new BuffModel(heroData, unitData, 'abaddon', 'abaddon_frostmourne'),\n        new BuffModel(heroData, unitData, 'alchemist', 'alchemist_acid_spray'),\n        new BuffModel(heroData, unitData, 'ancient_apparition', 'ancient_apparition_ice_vortex'),\n        new BuffModel(heroData, unitData, 'axe', 'axe_battle_hunger'),\n        new BuffModel(heroData, unitData, 'bane', 'bane_enfeeble'),\n        new BuffModel(heroData, unitData, 'batrider', 'batrider_sticky_napalm'),\n        new BuffModel(heroData, unitData, 'beastmaster', 'beastmaster_primal_roar'),\n        new BuffModel(heroData, unitData, 'bounty_hunter', 'bounty_hunter_jinada'),\n        new BuffModel(heroData, unitData, 'brewmaster', 'brewmaster_thunder_clap'),\n        new BuffModel(heroData, unitData, 'brewmaster', 'brewmaster_drunken_haze'),\n        new BuffModel(heroData, unitData, 'bristleback', 'bristleback_viscous_nasal_goo'),\n        new BuffModel(heroData, unitData, 'broodmother', 'broodmother_incapacitating_bite'),\n        new BuffModel(heroData, unitData, 'centaur', 'centaur_stampede'),\n        new BuffModel(heroData, unitData, 'chen', 'chen_penitence'),\n        new BuffModel(heroData, unitData, 'crystal_maiden', 'crystal_maiden_crystal_nova'),\n        new BuffModel(heroData, unitData, 'crystal_maiden', 'crystal_maiden_freezing_field'),\n        new BuffModel(heroData, unitData, 'dazzle', 'dazzle_weave'),\n        new BuffModel(heroData, unitData, 'drow_ranger', 'drow_ranger_frost_arrows'),\n        new BuffModel(heroData, unitData, 'earth_spirit', 'earth_spirit_rolling_boulder'),\n        new BuffModel(heroData, unitData, 'elder_titan', 'elder_titan_natural_order'),\n        new BuffModel(heroData, unitData, 'elder_titan', 'elder_titan_earth_splitter'),\n        new BuffModel(heroData, unitData, 'enchantress', 'enchantress_untouchable'),\n        new BuffModel(heroData, unitData, 'enchantress', 'enchantress_enchant'),\n        new BuffModel(heroData, unitData, 'faceless_void', 'faceless_void_time_walk'),\n        new BuffModel(heroData, unitData, 'huskar', 'huskar_life_break'),\n        new BuffModel(heroData, unitData, 'invoker', 'invoker_ghost_walk'),\n        new BuffModel(heroData, unitData, 'invoker', 'invoker_ice_wall'),\n        new BuffModel(heroData, unitData, 'wisp', 'wisp_tether'),\n        new BuffModel(heroData, unitData, 'jakiro', 'jakiro_dual_breath'),\n        new BuffModel(heroData, unitData, 'jakiro', 'jakiro_liquid_fire'),\n        new BuffModel(heroData, unitData, 'keeper_of_the_light', 'keeper_of_the_light_blinding_light'),\n        new BuffModel(heroData, unitData, 'kunkka', 'kunkka_torrent'),\n        new BuffModel(heroData, unitData, 'lich', 'lich_frost_nova'),\n        new BuffModel(heroData, unitData, 'lich', 'lich_frost_armor'),\n        new BuffModel(heroData, unitData, 'lich', 'lich_chain_frost'),\n        new BuffModel(heroData, unitData, 'life_stealer', 'life_stealer_open_wounds'),\n        new BuffModel(heroData, unitData, 'lion', 'lion_voodoo'),\n        new BuffModel(heroData, unitData, 'magnataur', 'magnataur_skewer'),\n        new BuffModel(heroData, unitData, 'medusa', 'medusa_stone_gaze'),\n        new BuffModel(heroData, unitData, 'meepo', 'meepo_geostrike'),\n        new BuffModel(heroData, unitData, 'naga_siren', 'naga_siren_rip_tide'),\n        new BuffModel(heroData, unitData, 'night_stalker', 'night_stalker_void'),\n        new BuffModel(heroData, unitData, 'night_stalker', 'night_stalker_crippling_fear'),\n        new BuffModel(heroData, unitData, 'night_stalker', 'night_stalker_darkness'),\n        new BuffModel(heroData, unitData, 'ogre_magi', 'ogre_magi_ignite'),\n        new BuffModel(heroData, unitData, 'omniknight', 'omniknight_degen_aura'),\n        new BuffModel(heroData, unitData, 'phantom_assassin', 'phantom_assassin_stifling_dagger'),\n        new BuffModel(heroData, unitData, 'phantom_lancer', 'phantom_lancer_spirit_lance'),\n        new BuffModel(heroData, unitData, 'pudge', 'pudge_rot'),\n        new BuffModel(heroData, unitData, 'pugna', 'pugna_decrepify'),\n        new BuffModel(heroData, unitData, 'queenofpain', 'queenofpain_shadow_strike'),\n        new BuffModel(heroData, unitData, 'riki', 'riki_smoke_screen'),\n        new BuffModel(heroData, unitData, 'rubick', 'rubick_fade_bolt'),\n        new BuffModel(heroData, unitData, 'sand_king', 'sandking_epicenter'),\n        new BuffModel(heroData, unitData, 'nevermore', 'nevermore_dark_lord'),\n        new BuffModel(heroData, unitData, 'shadow_shaman', 'shadow_shaman_voodoo'),\n        new BuffModel(heroData, unitData, 'skeleton_king', 'skeleton_king_hellfire_blast'),\n        new BuffModel(heroData, unitData, 'skeleton_king', 'skeleton_king_reincarnation'),\n        new BuffModel(heroData, unitData, 'skywrath_mage', 'skywrath_mage_concussive_shot'),\n        new BuffModel(heroData, unitData, 'skywrath_mage', 'skywrath_mage_ancient_seal'),\n        new BuffModel(heroData, unitData, 'slardar', 'slardar_slithereen_crush'),\n        new BuffModel(heroData, unitData, 'slardar', 'slardar_amplify_damage'),\n        new BuffModel(heroData, unitData, 'slark', 'slark_essence_shift'),\n        new BuffModel(heroData, unitData, 'sniper', 'sniper_shrapnel'),\n        new BuffModel(heroData, unitData, 'spectre', 'spectre_spectral_dagger'),\n        new BuffModel(heroData, unitData, 'storm_spirit', 'storm_spirit_overload'),\n        new BuffModel(heroData, unitData, 'templar_assassin', 'templar_assassin_meld'),\n        new BuffModel(heroData, unitData, 'tidehunter', 'tidehunter_gush'),\n        new BuffModel(heroData, unitData, 'tinker', 'tinker_laser'),\n        new BuffModel(heroData, unitData, 'treant', 'treant_leech_seed'),\n        new BuffModel(heroData, unitData, 'tusk', 'tusk_frozen_sigil'),\n        new BuffModel(heroData, unitData, 'undying', 'undying_flesh_golem'),\n        new BuffModel(heroData, unitData, 'ursa', 'ursa_earthshock'),\n        new BuffModel(heroData, unitData, 'vengefulspirit', 'vengefulspirit_wave_of_terror'),\n        new BuffModel(heroData, unitData, 'vengefulspirit', 'vengefulspirit_command_aura'),\n        new BuffModel(heroData, unitData, 'venomancer', 'venomancer_venomous_gale'),\n        new BuffModel(heroData, unitData, 'venomancer', 'venomancer_poison_sting'),\n        new BuffModel(heroData, unitData, 'viper', 'viper_poison_attack'),\n        new BuffModel(heroData, unitData, 'viper', 'viper_corrosive_skin'),\n        new BuffModel(heroData, unitData, 'viper', 'viper_viper_strike'),\n        new BuffModel(heroData, unitData, 'visage', 'visage_grave_chill'),\n        new BuffModel(heroData, unitData, 'warlock', 'warlock_upheaval'),\n        new BuffModel(heroData, unitData, 'weaver', 'weaver_the_swarm'),\n        new BuffModel(heroData, unitData, 'windrunner', 'windrunner_windrun'),\n        new BuffModel(heroData, unitData, 'winter_wyvern', 'winter_wyvern_arctic_burn'),\n        new BuffModel(heroData, unitData, 'winter_wyvern', 'winter_wyvern_splinter_blast'),\n        new BuffModel(heroData, unitData, 'npc_dota_neutral_ghost', 'ghost_frost_attack'),\n        new BuffModel(heroData, unitData, 'npc_dota_neutral_polar_furbolg_ursa_warrior', 'polar_furbolg_ursa_warrior_thunder_clap'),\n        new BuffModel(heroData, unitData, 'npc_dota_neutral_ogre_magi', 'ogre_magi_frost_armor'),\n        new BuffModel(heroData, unitData, 'npc_dota_neutral_satyr_trickster', 'satyr_trickster_purge'),\n        new BuffModel(heroData, unitData, 'npc_dota_neutral_enraged_wildkin', 'enraged_wildkin_tornado')\n    ];\n    return debuffOptionsArray.items;\n}\n\ndebuffOptionsArray.init = init;\n\nmodule.exports = debuffOptionsArray;",
    "var constants = {\n    healthPerStrength: 20,\n    healthRegenPerStrength: 5/700,\n    manaPerInt: 12,\n    manaRegenPerInt: 0.02,\n    spellDmgPerInt: 1/1400,\n    magicResPerInt: 0.15,\n    statusResPerStrength: 0.15,\n    moveSpeedPerAgi: 0.06,\n    armorPerAgi: 1/6,\n    armorMult: 0.05\n};\n\nmodule.exports = constants;",
    "var DamageTypeColor = {\n    'physical': '#979aa2',\n    'pure': 'goldenrod',\n    'magic': '#428bca',\n    'default': '#979aa2'\n}\n\nmodule.exports = DamageTypeColor;",
    "'use strict';\nvar ko = require('../herocalc_knockout');\n    \nvar DamageTypeColor = require(\"./DamageTypeColor\");\nvar extend = require(\"../util/extend\");\nvar TalentController = require(\"./TalentController\");\n\nvar HeroDamageMixin = function (self, itemData) {\n    self.critInfo = ko.pureComputed(function () {\n        var critSources = self.inventory.getCritSource();\n        extend(critSources, self.ability().getCritSource());\n        extend(critSources, self.buffs.getCritSource());\n        var critSourcesArray = [];\n        for (var prop in critSources) {\n            var el = critSources[prop];\n            el.name = prop\n            critSourcesArray.push(el);\n        }\n        function compareByMultiplier(a,b) {\n            if (a.multiplier < b.multiplier)\n                return 1;\n            if (a.multiplier > b.multiplier)\n                return -1;\n            return 0;\n        }\n\n        critSourcesArray.sort(compareByMultiplier);\n        \n        var result = [];\n        var critTotal = 0;\n        for (var i = 0; i < critSourcesArray.length; i++) {\n            var total = 1;\n            for (var j = 0; j < i; j++) {\n                for (var k = 0; k <critSourcesArray[j].count; k++) {\n                    total *= (1 - critSourcesArray[j].chance);\n                }\n            }\n            var total2 = 1;\n            for (var k = 0; k < critSourcesArray[i].count; k++) {\n                total2 *= (1 - critSourcesArray[i].chance);\n            }\n            total *= (1 - total2);\n            critTotal += total;\n            if (critSourcesArray[i].count > 1) {\n                result.push({\n                    'name':critSourcesArray[i].displayname + ' x' + critSourcesArray[i].count,\n                    'chance':critSourcesArray[i].chance,\n                    'multiplier':critSourcesArray[i].multiplier,\n                    'count':critSourcesArray[i].count,\n                    'totalChance':total\n                });\n            }\n            else {\n                result.push({\n                    'name':critSourcesArray[i].displayname,\n                    'chance':critSourcesArray[i].chance,\n                    'multiplier':critSourcesArray[i].multiplier,\n                    'count':critSourcesArray[i].count,\n                    'totalChance':total\n                });\n            }\n        }\n        return { sources: result, total: critTotal };\n    });\n\n    self.cleaveInfo = ko.pureComputed(function () {\n        var cleaveSources = self.inventory.getCleaveSource();\n        extend(cleaveSources, self.ability().getCleaveSource());\n        extend(cleaveSources, self.buffs.getCleaveSource());\n        var cleaveSourcesArray = [];\n        for (var prop in cleaveSources) {\n            var el = cleaveSources[prop];\n            el.name = prop\n            cleaveSourcesArray.push(el);\n        }\n        function compareByRadius(a,b) {\n            if (a.radius < b.radius)\n                return 1;\n            if (a.radius > b.radius)\n                return -1;\n            return 0;\n        }\n\n        cleaveSourcesArray.sort(compareByRadius);\n        var cleaveSourcesByRadius = {};\n        for (var i = 0; i < cleaveSourcesArray.length; i++) {\n            var total = 0;\n            for (var j = 0; j <cleaveSourcesArray.length; j++) {\n                if (cleaveSourcesArray[j].radius >= cleaveSourcesArray[i].radius) {\n                    total += cleaveSourcesArray[j].magnitude * cleaveSourcesArray[j].count;\n                }\n            }\n            cleaveSourcesByRadius[cleaveSourcesArray[i].radius] = total;\n        }\n        var result = [];\n        for (var prop in cleaveSourcesByRadius) {\n            result.push({\n                'radius':prop,\n                'magnitude':cleaveSourcesByRadius[prop]\n            });\n        }\n        return result;\n    });\n    \n    self.bashInfo = ko.pureComputed(function () {\n        var attacktype = self.heroData().attacktype;\n        var bashSources = self.inventory.getBashSource(attacktype);\n        extend(bashSources, self.ability().getBashSource());\n        var bashSourcesArray = [];\n        for (var prop in bashSources) {\n            var el = bashSources[prop];\n            el.name = prop\n            bashSourcesArray.push(el);\n        }\n        function compareByDuration(a, b) {\n            if (a.duration < b.duration)\n                return 1;\n            if (a.duration > b.duration)\n                return -1;\n            return 0;\n        }\n\n        //bashSourcesArray.sort(compareByDuration);\n        \n        var result = [];\n        var bashTotal = 0;\n        for (var i = 0;i < bashSourcesArray.length; i++) {\n            var total = 1;\n            for (var j = 0; j < i; j++) {\n                for (var k = 0; k < bashSourcesArray[j].count; k++) {\n                    total *= (1 - bashSourcesArray[j].chance);\n                }\n            }\n            var total2 = 1;\n            for (var k = 0; k < bashSourcesArray[i].count; k++) {\n                total2 *= (1 - bashSourcesArray[i].chance);\n            }\n            total *= (1 - total2);\n            bashTotal += total;\n            if (bashSourcesArray[i].name === 'spirit_breaker_greater_bash') {\n                var d = bashSourcesArray[i].damage * self.totalMovementSpeed();\n            }\n            else {\n                var d = bashSourcesArray[i].damage;\n            }\n            if (bashSourcesArray[i].count > 1) {\n                result.push({\n                    'name':bashSourcesArray[i].displayname, // + ' x' + bashSourcesArray[i].count,\n                    'chance':bashSourcesArray[i].chance,\n                    'damage':d,\n                    'count':bashSourcesArray[i].count,\n                    'damageType':bashSourcesArray[i].damageType,\n                    'totalChance':total\n                });\n            }\n            else {\n                result.push({\n                    'name':bashSourcesArray[i].displayname,\n                    'chance':bashSourcesArray[i].chance,\n                    'damage':d,\n                    'count':bashSourcesArray[i].count,\n                    'damageType':bashSourcesArray[i].damageType,\n                    'totalChance':total\n                });\n            }\n\n        }\n        return { sources: result, total: bashTotal };\n    });\n    \n    self.orbProcInfo = ko.pureComputed(function () {\n        var attacktype = self.heroData().attacktype;\n        var damageSources = self.inventory.getOrbProcSource();\n        var damageSourcesArray = [];\n        for (var prop in damageSources) {\n            var el = damageSources[prop];\n            el.name = prop\n            damageSourcesArray.push(el);\n        }\n        function compareByDamage(a, b) {\n            if (a.priority > b.priority) {\n                return 1;\n            }\n            if (a.priority < b.priority) {\n                return -1;\n            }\n            if (a.damage < b.damage)\n                return 1;\n            if (a.damage > b.damage)\n                return -1;\n            return 0;\n        }\n\n        damageSourcesArray.sort(compareByDamage);\n        \n        var result = [];\n        var damageTotal = 0;\n        for (var i=0 ; i < damageSourcesArray.length; i++) {\n            var total = 1;\n            for (var j = 0; j < i; j++) {\n                for (var k = 0; k < damageSourcesArray[j].count; k++) {\n                    total *= (1 - damageSourcesArray[j].chance);\n                }\n            }\n            var total2 = 1;\n            for (var k = 0; k < damageSourcesArray[i].count; k++) {\n                total2 *= (1 - damageSourcesArray[i].chance);\n            }\n            total *= (1 - total2);\n            damageTotal += total;\n            if (damageSourcesArray[i].count > 1) {\n                result.push({\n                    'name':damageSourcesArray[i].displayname + ' x' + damageSourcesArray[i].count,\n                    'chance':damageSourcesArray[i].chance,\n                    'damage':damageSourcesArray[i].damage,\n                    'count':damageSourcesArray[i].count,\n                    'damageType':damageSourcesArray[i].damageType,\n                    'totalChance':total\n                });\n            }\n            else {\n                result.push({\n                    'name':damageSourcesArray[i].displayname,\n                    'chance':damageSourcesArray[i].chance,\n                    'damage':damageSourcesArray[i].damage,\n                    'count':damageSourcesArray[i].count,\n                    'damageType':damageSourcesArray[i].damageType,\n                    'totalChance':total\n                });\n            }\n        }\n        return { sources: result, total: damageTotal };\n    });\n    \n    self.getReducedDamage = function (value, type) {\n        var result = value;\n        switch (type) {\n            case 'physical':\n                result = value * (1 - (0.06 * self.enemy().totalArmorPhysical()) / (1 + 0.06 * Math.abs(self.enemy().totalArmorPhysical())));\n            break;\n            case 'magic':\n                result = value * (1 - self.enemy().totalMagicResistance() / 100);\n            break;\n            case 'pure':\n                result = value;\n            break;\n            case 'composite':\n                result = value * (1 - (0.06 * self.enemy().totalArmorPhysical()) / (1 + 0.06 * Math.abs(self.enemy().totalArmorPhysical())));\n                result *= (1 - self.enemy().totalMagicResistance() / 100);\n            break;\n        }\n        result *= self.ability().getDamageAmplification() * self.debuffs.getDamageAmplification();\n        result *= self.enemy().ability().getDamageReduction() * self.enemy().buffs.getDamageReduction();\n        return result;\n    }\n    \n    self.damageTotalInfo = ko.pureComputed(function () {\n        var bonusDamageArray = [\n            self.ability().getBonusDamage().sources,\n            self.buffs.getBonusDamage().sources,\n            TalentController.getBonusDamage(self.selectedTalents()).sources\n        ],\n        bonusDamagePctArray = [\n            self.ability().getBonusDamagePercent().sources,\n            self.buffs.getBonusDamagePercent().sources\n        ],\n        itemBonusDamage = self.inventory.getBonusDamage().sources,\n        itemBonusDamagePct = self.buffs.itemBuffs.getBonusDamagePercent(self.inventory.getBonusDamagePercent()).sources,\n        critSources = self.critInfo(),\n        abilityOrbSources = self.ability().getOrbSource(),\n        itemOrbSources = self.inventory.getOrbSource(),\n        itemProcOrbSources = self.orbProcInfo(),\n        bashSources = self.bashInfo(),\n        \n        attackSources = [];\n        \n        attackSources.push({\n            name: 'Base Attack',\n            cooldown: 1\n        });\n        \n        // weaver_geminate_attack\n        if (self.heroId() === 'weaver') {\n            var a = self.ability().abilities().find(function (ability) {\n                return ability.name === 'weaver_geminate_attack';\n            });\n            if (a) {\n                if (a.level() > 0) {\n                    var cd = a.cooldown[a.level() - 1];\n                    attackSources.push({\n                        name: a.displayname,\n                        cooldown: (1/cd)\n                    });\n                }\n            }\n        }\n        \n        // echo_sabre\n        var item = self.inventory.items().find(function (o) { return o.item === \"echo_sabre\" && o.enabled(); });\n        if (item && self.heroData().attacktype === 'DOTA_UNIT_CAP_MELEE_ATTACK') {\n            var item_echo_sabre = itemData['item_echo_sabre'];\n            attackSources.push({\n                name: item_echo_sabre.displayname,\n                cooldown: (1/item_echo_sabre.cooldown)\n            });\n        }\n\n        var attacks = attackSources.map(function (a) {\n            var baseDamage = (self.baseDamage()[0] + self.baseDamage()[1]) / 2,\n            totalDamage = 0,\n            totalCritableDamage = 0,\n            totalCrit = 0,\n            geminateAttack = { damage: 0, damageReduced: 0, cooldown: 6, active: false },\n            echoSabreAttack = { damage: 0, damageReduced: 0, cooldown: itemData['item_echo_sabre'].cooldown[0], active: false },\n            damage = {\n                pure: 0,\n                physical: 0,\n                magic: 0\n            },\n            result = [],\n            crits = [];\n            \n            // base damage\n            result.push({\n                name: 'Base Damage',\n                damage: baseDamage,\n                damageType: 'physical',\n                damageReduced: self.getReducedDamage(baseDamage, 'physical'),\n                enabled: ko.observable(true)\n            });\n            totalDamage += baseDamage;\n            totalCritableDamage += baseDamage;\n            damage.physical += baseDamage;\n            \n            if (!self.isIllusion()) {\n                // bonus damage from items\n                for (i in itemBonusDamage) {\n                    var d = itemBonusDamage[i].damage*itemBonusDamage[i].count * self.ability().getSelfBaseDamageReductionPct() * self.enemy().ability().getBaseDamageReductionPct() * self.debuffs.itemBuffs.getBaseDamageReductionPct();\n                    result.push({\n                        name: itemBonusDamage[i].displayname + (itemBonusDamage[i].count > 1 ? ' x' + itemBonusDamage[i].count : ''),\n                        damage: d,\n                        damageType: itemBonusDamage[i].damageType,\n                        damageReduced: self.getReducedDamage(d, itemBonusDamage[i].damageType),\n                        enabled: ko.observable(true)\n                    });\n                    totalDamage += d;\n                    totalCritableDamage += d;\n                    damage[itemBonusDamage[i].damageType] += d;\n                }\n\n                // bonus damage percent from items\n                for (i in itemBonusDamagePct) {\n                    var d = baseDamage * itemBonusDamagePct[i].damage;\n                    result.push({\n                        name: itemBonusDamagePct[i].displayname,\n                        damage: d,\n                        damageType: itemBonusDamagePct[i].damageType,\n                        damageReduced: self.getReducedDamage(d, itemBonusDamagePct[i].damageType),\n                        enabled: ko.observable(true)\n                    });\n                    totalDamage += d;\n                    totalCritableDamage += d;\n                    damage[itemBonusDamagePct[i].damageType] += d;\n                }\n            \n                // bonus damage from abilities and buffs\n                for (var i = 0; i < bonusDamageArray.length; i++) {\n                    for (j in bonusDamageArray[i]) {\n                        var d = bonusDamageArray[i][j].damage;\n                        result.push({\n                            name: bonusDamageArray[i][j].displayname,\n                            damage: d,\n                            damageType: bonusDamageArray[i][j].damageType,\n                            damageReduced: self.getReducedDamage(d, bonusDamageArray[i][j].damageType),\n                            enabled: ko.observable(true)\n                        });\n                        totalDamage += d;\n                        totalCritableDamage += d;\n                        damage[bonusDamageArray[i][j].damageType] += d;\n                    }\n                }\n            \n                // bonus damage percent from abilities and buffs\n                for (var i = 0; i < bonusDamagePctArray.length; i++) {\n                    for (j in bonusDamagePctArray[i]) {\n                        var d = baseDamage * bonusDamagePctArray[i][j].damage;\n                        result.push({\n                            name: bonusDamagePctArray[i][j].displayname,\n                            damage: d,\n                            damageType: bonusDamagePctArray[i][j].damageType,\n                            damageReduced: self.getReducedDamage(d, bonusDamagePctArray[i][j].damageType),\n                            enabled: ko.observable(true)\n                        });\n                        totalDamage += d;\n                        totalCritableDamage += d;\n                        damage[bonusDamagePctArray[i][j].damageType] += d;\n                    }\n                }\n                \n                // drow_ranger_trueshot\n                if (self.heroData().attacktype === 'DOTA_UNIT_CAP_RANGED_ATTACK') {\n                    if (self.heroId() === 'drow_ranger') {\n                        var s = self.ability().getBonusDamagePrecisionAura().sources;\n                        var index = 0;\n                    }\n                    else {\n                        var s = self.buffs.getBonusDamagePrecisionAura().sources;\n                        var index = 1;\n                    }\n                    if (s[index] != undefined) {\n                        if (self.heroId() === 'drow_ranger') {\n                            var d = s[index].damage * self.totalAgi().total;\n                        }\n                        else {\n                            var d = s[index].damage;\n                        }\n                        result.push({\n                            name: s[index].displayname,\n                            damage: d,\n                            damageType: 'physical',\n                            damageReduced: self.getReducedDamage(d, 'physical'),\n                            enabled: ko.observable(true)\n                        });\n                        totalDamage += d;\n                        totalCritableDamage += d;\n                        damage.physical += d;                    \n                    }\n                }\n            \n                // riki_backstab\n                if (self.heroId() === 'riki') {\n                    var s = self.ability().getBonusDamageBackstab().sources;\n                    var index = 0;\n                }\n                else {\n                    var s = self.buffs.getBonusDamageBackstab().sources;\n                    var index = 1;\n                }\n                if (s[index] != undefined) {\n                    if (self.heroId() === 'riki') {\n                        var d = s[index].damage * self.totalAgi().total;\n                    }\n                    else {\n                        var d = s[index].damage;\n                    }\n                    result.push({\n                        name: s[index].displayname,\n                        damage: d,\n                        damageType: 'physical',\n                        damageReduced: self.getReducedDamage(d, 'physical'),\n                        enabled: ko.observable(true)\n                    });\n                    totalDamage += d;\n                    //totalCritableDamage += d;\n                    damage.physical += d;                    \n                }\n\n                // bash damage\n                for (var i = 0; i < bashSources.sources.length; i++) {\n                    var o = bashSources.sources[i];\n                    var d = bashSources.sources[i].damage;\n                    var cd = self.attacksPerSecond();\n                    if (o.cooldown) {\n                        cd = Math.max(1/o.cooldown, cd);\n                    }\n                    for (var j = 0; j < bashSources.sources[i].count; j++) {\n                        result.push({\n                            name: bashSources.sources[i].name,\n                            damage: d,\n                            damageType: bashSources.sources[i].damageType,\n                            damageReduced: self.getReducedDamage(d, bashSources.sources[i].damageType),\n                            dps: d * cd * bashSources.sources[i].chance,\n                            dpsReduced: self.getReducedDamage(d, bashSources.sources[i].damageType) * cd * bashSources.sources[i].chance,\n                            enabled: ko.observable(true)\n                        });\n                        totalDamage += d;\n                        damage[bashSources.sources[i].damageType] += d;\n                    }\n                }\n            \n                // %-based orbs\n                for (var i = 0; i < itemProcOrbSources.sources.length; i++) {\n                    var d = itemProcOrbSources.sources[i].damage * (1 - Math.pow(1 - itemProcOrbSources.sources[i].chance, itemProcOrbSources.sources[i].count));\n                    result.push({\n                        name: itemProcOrbSources.sources[i].name,\n                        damage: d,\n                        damageType: itemProcOrbSources.sources[i].damageType,\n                        damageReduced: self.getReducedDamage(d, itemProcOrbSources.sources[i].damageType),\n                        enabled: ko.observable(true)\n                    });\n                    totalDamage += d;\n                    damage[itemProcOrbSources.sources[i].damageType] += d;\n                }\n            }\n            \n            // ability orbs\n            for (var orb in abilityOrbSources) {\n                var d = abilityOrbSources[orb].damage * (1 - itemProcOrbSources.total);\n                result.push({\n                    name: abilityOrbSources[orb].displayname,\n                    damage: d,\n                    damageType: abilityOrbSources[orb].damageType,\n                    damageReduced: self.getReducedDamage(d, abilityOrbSources[orb].damageType),\n                    enabled: ko.observable(true)\n                });\n                totalDamage += d;\n                damage[abilityOrbSources[orb].damageType] += d;\n            }\n            \n            // item orbs\n            if (Object.keys(abilityOrbSources).length === 0) {\n                for (var orb in itemOrbSources) {\n                    var d = itemOrbSources[orb].damage * (1 - itemProcOrbSources.total);\n                    result.push({\n                        name: itemOrbSources[orb].displayname,\n                        damage: d,\n                        damageType: itemOrbSources[orb].damageType,\n                        damageReduced: self.getReducedDamage(d, itemOrbSources[orb].damageType),\n                        enabled: ko.observable(true)\n                    });\n                    totalDamage += d;\n                    damage[itemOrbSources[orb].damageType] += d;\n                }            \n            }\n            \n            // crit damage\n            for (var i = 0; i < critSources.sources.length; i++) {\n                var d = totalCritableDamage * (critSources.sources[i].multiplier - 1);// * critSources.sources[i].totalChance;\n                crits.push({\n                    name: critSources.sources[i].name + ', ' + critSources.sources[i].multiplier + 'x, ' + (critSources.sources[i].totalChance * 100).toFixed(1) + '%',\n                    damage: d,\n                    damageType: 'physical',\n                    damageReduced: self.getReducedDamage(d, 'physical'),\n                    enabled: ko.observable(true),\n                    chance: critSources.sources[i].totalChance\n                });\n                totalCrit += d;\n            }\n\n            var totalReduced = self.getReducedDamage(damage.pure, 'pure') \n                    + self.getReducedDamage(damage.physical, 'physical')\n                    + self.getReducedDamage(damage.magic, 'magic'),\n                totalCritReduced = self.getReducedDamage(totalCrit, 'physical'),\n                dps = {\n                    base: totalDamage * self.attacksPerSecond(),\n                    crit: totalCrit * self.attacksPerSecond(),\n                    geminateAttack: geminateAttack.active ? geminateAttack.damage / geminateAttack.cooldown : 0,\n                    reduced: {\n                        base: totalReduced * self.attacksPerSecond(),\n                        crit: totalCritReduced * self.attacksPerSecond(),\n                        geminateAttack: geminateAttack.active ? self.getReducedDamage(geminateAttack.damage, 'physical') / geminateAttack.cooldown : 0,\n                    }\n                }\n                \n            crits.forEach(function (o) {\n                if (!o.dps) {\n                    o.dps = o.damage * (o.cooldown || self.attacksPerSecond()) * o.chance;\n                }\n                if (!o.dpsReduced) {\n                    o.dpsReduced = o.damageReduced * (o.cooldown || self.attacksPerSecond()) * o.chance;\n                }\n            });\n                \n            result.forEach(function (o) {\n                if (!o.dps) {\n                    o.dps = o.damage * (o.cooldown || self.attacksPerSecond());\n                }\n                if (!o.dpsReduced) {\n                    o.dpsReduced = o.damageReduced * (o.cooldown || self.attacksPerSecond());\n                }\n            });\n            \n            var totalCritChance = crits.reduce(function (memo, o) { return memo + o.chance }, 0);\n                \n            var t1Crit = ko.computed(function () {\n                var c = crits.find(function (o) { return o.enabled(); });\n                return c ? c.damage : 0;\n            });\n            var t2Crit = ko.computed(function () {\n                var c = crits.find(function (o) { return o.enabled(); });\n                return c ? c.damageReduced : 0;\n            });\n            var t3Crit = ko.computed(function () {\n                return crits.filter(function (o) { return o.enabled(); }).reduce(function (memo, o) { return memo + o.dps }, 0);\n            });\n            var t4Crit = ko.computed(function () {\n                return crits.filter(function (o) { return o.enabled(); }).reduce(function (memo, o) { return memo + o.dpsReduced }, 0);\n            });\n                \n            var t1 = ko.computed(function () {\n                return result.filter(function (o) { return o.enabled(); }).reduce(function (memo, o) { return memo + o.damage }, 0) + t1Crit();\n            });\n            var t2 = ko.computed(function () {\n                return result.filter(function (o) { return o.enabled(); }).reduce(function (memo, o) { return memo + o.damageReduced }, 0) + t2Crit();\n            });\n            var t3 = ko.computed(function () {\n                return (result.filter(function (o) { return o.enabled(); }).reduce(function (memo, o) { return memo + o.dps }, 0) + t3Crit()) * a.cooldown;\n            });\n            var t4 = ko.computed(function () {\n                return (result.filter(function (o) { return o.enabled(); }).reduce(function (memo, o) { return memo + o.dpsReduced }, 0) + t4Crit()) * a.cooldown;\n            });\n            \n            var totalCritRow = [t1Crit, t2Crit, t3Crit, t4Crit];\n            \n            var totalRow = [t1, t2, t3, t4];\n\n            return {\n                name: a.name + ' Subtotal',\n                cooldown: a.cooldown,\n                enabled: ko.observable(true),\n                visible: ko.observable(true),\n                totalCritChance: totalCritChance,\n                totalCritRow: totalCritRow,\n                totalRow: totalRow,\n                sources: result,\n                sourcesCrit: crits,\n                total: totalDamage,\n                totalCrit: totalCrit,\n                totalGeminateAttack: totalDamage + geminateAttack.damage,\n                totalGeminateAttackReduced: totalReduced + geminateAttack.damageReduced,\n                geminateAttack: geminateAttack,\n                totalCritReduced: totalCritReduced,\n                totalReduced: totalReduced,\n                sumTotal: totalDamage + totalCrit,\n                sumTotalReduced: totalReduced + totalCritReduced,\n                dps: {\n                    base: dps.base,\n                    crit: dps.base + dps.crit,\n                    geminateAttack: dps.base + dps.geminateAttack,\n                    total: dps.base + dps.crit + dps.geminateAttack,\n                    reduced: {\n                        base: dps.reduced.base,\n                        crit: dps.reduced.base + dps.reduced.crit,\n                        geminateAttack: dps.reduced.base + dps.reduced.geminateAttack,\n                        total: dps.reduced.base + dps.reduced.crit + dps.reduced.geminateAttack\n                    }\n                }\n            };\n        });\n        \n        var t1 = ko.computed(function () {\n            return attacks.filter(function (o) { return o.enabled(); }).reduce(function (memo, o) { return memo + o.totalRow[0]() }, 0);\n        });\n        var t2 = ko.computed(function () {\n            return attacks.filter(function (o) { return o.enabled(); }).reduce(function (memo, o) { return memo + o.totalRow[1]() }, 0);\n        });\n        var t3 = ko.computed(function () {\n            return attacks.filter(function (o) { return o.enabled(); }).reduce(function (memo, o) { return memo + o.totalRow[2]() }, 0);\n        });\n        var t4 = ko.computed(function () {\n            return attacks.filter(function (o) { return o.enabled(); }).reduce(function (memo, o) { return memo + o.totalRow[3]() }, 0);\n        });\n            \n        return {\n            attacks: attacks,\n            totalRow: [t1, t2, t3, t4]\n        }\n    });\n    \n    self.getDamageTypeColor = function (damageType) {\n        return DamageTypeColor[damageType] || DamageTypeColor['default'];\n    }\n    \n}\n\nmodule.exports = HeroDamageMixin;",
    "'use strict';\nvar ko = require('../herocalc_knockout');\n\nvar constants = require(\"../constants\");\nvar StatModel = require(\"../StatModel\");\nvar AbilityModel = require(\"../AbilityModel\");\nvar BuffViewModel = require(\"../BuffViewModel\");\nvar InventoryViewModel = require(\"../inventory/InventoryViewModel\");\nvar diffProperties = require(\"./diffProperties\");\nvar HeroDamageMixin = require(\"./HeroDamageMixin\");\nvar TalentController = require(\"./TalentController\");\nvar totalExp = require(\"./totalExp\");\nvar nextLevelExp = require(\"./nextLevelExp\");\nvar illusionData = require(\"../illusion/illusionData\");\nvar findWhere = require(\"../util/findWhere\");\nvar extend = require(\"../util/extend\");\n\nvar HeroModel = function (heroData, itemData, h) {\n    var self = this;\n    self.heroId = ko.observable(h);\n    self.illusionId = ko.observable('');\n    self.isIllusion = ko.observable(false);\n    self.selectedHeroLevel = ko.observable(1);\n    self.inventory = new InventoryViewModel(itemData, self);\n    self.selectedInventory = ko.observable(-1);\n    self.buffs = new BuffViewModel(itemData);\n    self.buffs.hasScepter = self.inventory.hasScepter;\n    self.debuffs = new BuffViewModel(itemData);\n    self.heroData = ko.pureComputed(function () {\n      return heroData['npc_dota_hero_' + self.heroId()];\n    });\n    self.heroCompare = ko.observable(self);\n    self.enemy = ko.observable(self);\n    self.unit = ko.observable(self);\n    self.clone = ko.observable(self);\n    \n    self.talents = [\n        ko.observable(-1),\n        ko.observable(-1),\n        ko.observable(-1),\n        ko.observable(-1)\n    ];\n    \n    self.selectedTalents = ko.pureComputed(function () {\n        var arr = [];\n        for (var i = 0; i < 4; i++) {\n            if (self.talents[i]() !== -1) {\n                arr.push(self.heroData().talents[i][self.talents[i]()]);\n            }\n        }\n        return arr;\n    });\n    \n    self.skillPointHistory = ko.observableArray();\n    \n    self.ability = ko.computed(function () {\n        var a = new AbilityModel(ko.observableArray(JSON.parse(JSON.stringify(self.heroData().abilities))), self);\n        switch (self.heroId()) {\n            case 'earth_spirit':\n            case 'ogre_magi':\n                a._abilities[3].level(1);\n            break;\n            case 'monkey_king':\n                a._abilities[5].level(1);\n            break;\n            case 'invoker':\n                for (var i = 5; i < 16; i++) {\n                    a._abilities[i].level(1);\n                }\n            break;\n        }\n        self.skillPointHistory.removeAll();\n        a.hasScepter = self.inventory.hasScepter\n        return a;\n    });\n\n    self.availableSkillPoints = ko.computed(function () {\n        var c = self.selectedHeroLevel();\n        for (var i = 0; i < 4; i++) {\n            if (self.selectedHeroLevel() < i * 5 + 10) self.talents[i](-1);\n        }\n        c -= self.talents.filter(function (talent) { return talent() !== -1 }).length;\n        for (var i = 0; i < self.ability().abilities().length; i++) {\n            switch(self.ability().abilities()[i].abilitytype) {\n                case 'DOTA_ABILITY_TYPE_ULTIMATE':\n                    if (self.heroId() === 'invoker') {\n                        /*while (\n                            ((self.ability().abilities()[i].level() == 1) && (parseInt(self.selectedHeroLevel()) < 2)) ||\n                            ((self.ability().abilities()[i].level() == 2) && (parseInt(self.selectedHeroLevel()) < 7)) ||\n                            ((self.ability().abilities()[i].level() == 3) && (parseInt(self.selectedHeroLevel()) < 11)) ||\n                            ((self.ability().abilities()[i].level() == 4) && (parseInt(self.selectedHeroLevel()) < 17))\n                        ) {\n                            self.ability().levelDownAbility(i, null, null, self);\n                        }*/\n                    }\n                    else if (self.heroId() === 'meepo') {\n                        while ((self.ability().abilities()[i].level()-1) * 7 + 3 > parseInt(self.selectedHeroLevel())) {\n                            self.ability().levelDownAbility(i, null, null, self);\n                        }\n                    }\n                    else {\n                        while (self.ability().abilities()[i].level() * 5 + 1 > parseInt(self.selectedHeroLevel())) {\n                            self.ability().levelDownAbility(i, null, null, self);\n                        }\n                    }\n                break;\n                default:\n                    while (self.ability().abilities()[i].level() * 2 - 1 > parseInt(self.selectedHeroLevel())) {\n                        self.ability().levelDownAbility(i, null, null, self);\n                    }\n                break;\n            }\n        }\n        while (self.skillPointHistory().length > c) {\n            self.ability().levelDownAbility(self.skillPointHistory()[self.skillPointHistory().length-1], null, null, self);\n        }\n        return c-self.skillPointHistory().length;\n    }, this);\n    \n    self.getAbilityAttributeValue = function(hero, ability, attributeName, level) {\n        if (!attributeName) return 0;\n        ability = ability.indexOf('phantom_lancer_doppelwalk') == -1 ? ability : 'phantom_lancer_doppelwalk';\n        if (ability == 'item_manta') {\n            var abilityObj = itemData[ability];\n        }\n        else {\n            var abilityObj = findWhere(heroData['npc_dota_hero_' + hero].abilities, {name: ability});\n        }\n        var attribute = findWhere(abilityObj.attributes, {name: attributeName});\n        if (level == 0) {\n            return parseFloat(attribute.value[0]);\n        }\n        else if (level > attribute.value.length) {\n            return parseFloat(attribute.value[0]);\n        }\n        else {\n            return parseFloat(attribute.value[level - 1]);\n        }\n    }\n    \n    self.illusionAbilityLevel = ko.observable(0);\n    \n    self.getIncomingDamageMultiplier = function(illusionType, hasScepter, attackType) {\n        console.log('illusionType', illusionType);\n        if (!illusionType) return 1;\n        var sign = illusionData[illusionType].incoming_damage_sign || 1;\n        if (illusionType == 'item_manta') {\n            if (attackType == 'DOTA_UNIT_CAP_MELEE_ATTACK') {\n                return (1 + sign * self.getAbilityAttributeValue(illusionData[illusionType].hero, illusionType, illusionData[illusionType].incoming_damage_melee, self.illusionAbilityLevel())/100)\n            }\n            else {\n                return (1 + sign * self.getAbilityAttributeValue(illusionData[illusionType].hero, illusionType, illusionData[illusionType].incoming_damage_ranged, self.illusionAbilityLevel())/100)\n            }\n        }\n        else {\n            return (1 + sign * self.getAbilityAttributeValue(illusionData[illusionType].hero, illusionType, illusionData[illusionType].incoming_damage, self.illusionAbilityLevel())/100)\n        }\n    }\n    self.getOutgoingDamageMultiplier = function(illusionType, hasScepter, attackType) {\n        console.log('illusionType', illusionType);\n        if (!illusionType) return 1;\n        var sign = illusionData[illusionType].outgoing_damage_sign || 1;\n        if (illusionType == 'item_manta') {\n            if (attackType == 'DOTA_UNIT_CAP_MELEE_ATTACK') {\n                return (1 + sign * self.getAbilityAttributeValue(illusionData[illusionType].hero, illusionType, illusionData[illusionType].outgoing_damage_melee, self.illusionAbilityLevel())/100);\n            }\n            else {\n                return (1 + sign * self.getAbilityAttributeValue(illusionData[illusionType].hero, illusionType, illusionData[illusionType].outgoing_damage_ranged, self.illusionAbilityLevel())/100);\n            }\n        }\n        else {\n            return (1 + sign * self.getAbilityAttributeValue(illusionData[illusionType].hero, illusionType, illusionData[illusionType].outgoing_damage, self.illusionAbilityLevel())/100);\n        }\n    }\n    \n    self.primaryAttribute = ko.pureComputed(function () {\n        var v = self.heroData().attributeprimary;\n        if (v === 'DOTA_ATTRIBUTE_AGILITY') return 'agi';\n        if (v === 'DOTA_ATTRIBUTE_INTELLECT') return 'int';\n        if (v === 'DOTA_ATTRIBUTE_STRENGTH') return 'str';\n        return '';\n    });\n    self.totalExp = ko.pureComputed(function () {\n        return totalExp[self.selectedHeroLevel() - 1];\n    });\n    self.nextLevelExp = ko.pureComputed(function () {\n        return nextLevelExp[self.selectedHeroLevel() - 1];\n    });\n    self.startingArmor = ko.pureComputed(function () {\n        return self.heroData().attributebaseagility * constants.armorPerAgi + self.heroData().armorphysical;\n    });\n    self.respawnTime = ko.pureComputed(function () {\n        var level = self.selectedHeroLevel();\n        var reduction = TalentController.getRespawnReduction(self.selectedTalents());\n        if (level >= 1 && level <= 5) {\n            return (level - 1) * 2 + 8 - reduction;\n        }\n        else if (level >= 6 && level <= 11) {\n            return (level - 6) * 2 + 26 - reduction;\n        }\n        else if (level >= 12 && level <= 17) {\n            return (level - 12) * 2 + 46 - reduction;\n        }\n        else if (level >= 18 && level <= 24) {\n            return (level - 18) * 4 + 66 - reduction;\n        }\n        else if (level == 25) {\n            return 100 - reduction;\n        }\n    });\n    self.totalAttribute = function (a) {\n        if (a === 'agi') return self.totalAgi().total;\n        if (a === 'int') return self.totalInt().total;\n        if (a === 'str') return self.totalStr().total;\n        return 0;\n    };\n    self.totalAgi = ko.pureComputed(function () {\n        var s = new StatModel(self.heroData().attributebaseagility, 'Base');\n        s.add(self.heroData().attributeagilitygain * (self.selectedHeroLevel() - 1), 'Level')\n            .concat(self.inventory.getAttributes('agi'))\n            .concat(self.ability().getAgility())\n            .concat(TalentController.getAgility(self.selectedTalents()))\n            .concat(self.enemy().ability().getAllStatsReduction())\n            .concat(self.debuffs.getAllStatsReduction())\n        return s;\n    });\n    self.intStolen = ko.observable(0).extend({ numeric: 0 });\n    self.totalInt = ko.pureComputed(function () {\n        var s = new StatModel(self.heroData().attributebaseintelligence, 'Base');\n        s.add(self.heroData().attributeintelligencegain * (self.selectedHeroLevel() - 1), 'Level')\n            .concat(self.inventory.getAttributes('int'))\n            .concat(self.ability().getIntelligence())\n            .concat(TalentController.getIntelligence(self.selectedTalents()))\n            .concat(self.enemy().ability().getAllStatsReduction())\n            .concat(self.debuffs.getAllStatsReduction())\n            .add(self.intStolen(), 'Int Stolen')\n            .add(-self.enemy().intStolen(), 'Int Stolen')\n        return s;\n    });\n    self.totalStr = ko.pureComputed(function () {\n        var s = new StatModel(self.heroData().attributebasestrength, 'Base');\n        s.add(self.heroData().attributestrengthgain * (self.selectedHeroLevel() - 1), 'Level')\n            .concat(self.inventory.getAttributes('str'))\n            .concat(self.ability().getStrength())\n            .concat(TalentController.getStrength(self.selectedTalents()))\n            .concat(self.enemy().ability().getStrengthReduction())\n            .concat(self.enemy().ability().getAllStatsReduction())\n            .concat(self.debuffs.getAllStatsReduction())\n        return s;\n    });\n    // + % status resistance\n    self.perkStr = ko.pureComputed(function () {\n        return self.totalStr().total * constants.statusResPerStrength;\n    });\n    // + % ms\n    self.perkAgi = ko.pureComputed(function () {\n        return self.totalAgi().total * constants.moveSpeedPerAgi;\n    });\n    // + % magic resistance\n    self.perkInt = ko.pureComputed(function () {\n        return self.totalInt().total * constants.magicResPerInt;\n    });\n    self.health = ko.pureComputed(function () {\n        var s = new StatModel(self.heroData().statushealth, 'Base');\n        self.totalStr().components.forEach(function (component) {\n            s.add(component.value * constants.healthPerStrength, component.label == 'Base' ? 'Base Str' : component.label);\n        });\n        s.concat(self.inventory.getHealth())\n        .concat(self.ability().getHealth())\n        .concat(TalentController.getHealth(self.selectedTalents()))\n        return s;\n    });\n    // Health Regeneration = (Base + Sum of Flat Bonuses) * (1 + strength * (5/700))\n    self.healthregen = ko.pureComputed(function () {\n        var healthRegenAura = [self.inventory.getHealthRegenAura, self.buffs.itemBuffs.getHealthRegenAura].reduce(function (memo, fn) {\n            return fn(memo.sources, memo.excludeList);\n        }, {sources: new StatModel(), excludeList: []});\n        \n        var s = new StatModel(self.heroData().statushealthregen, 'Base');\n        if (!self.isIllusion()) {\n            s.concat(self.inventory.getHealthRegen())\n            .concat(self.ability().getHealthRegen())\n            .concat(self.buffs.getHealthRegen())\n            .concat(TalentController.getHealthRegen(self.selectedTalents()))\n            .concat(healthRegenAura.sources)\n        }\n        s.mult(1 + self.totalStr().total * constants.healthRegenPerStrength, 'Str Regen Amp', null, 'percent');\n        console.log('healthregen', s);\n        return s;\n    });\n    self.mana = ko.pureComputed(function () {\n        var s = new StatModel(self.heroData().statusmana, 'Base');\n        self.totalInt().components.forEach(function (component) {\n            s.add(component.value * constants.manaPerInt, component.label == 'Base' ? 'Base Int' : component.label);\n        });\n        s.concat(self.inventory.getMana())\n        .concat(self.ability().getMana())\n        .concat(TalentController.getMana(self.selectedTalents()))\n        return s;\n    });\n    // Mana Regeneration = (Base + Sum of Flat Bonuses) * (1 + intelligence * 0.02)\n    self.manaregen = ko.pureComputed(function () {\n        var s = new StatModel(self.heroData().statusmanaregen, 'Base');\n        s.concat(self.inventory.getManaRegen())\n        .concat(self.inventory.getManaRegenBloodstone())\n        .concat(self.ability().getManaRegen())\n        .concat(TalentController.getManaRegen(self.selectedTalents()))\n        if (self.heroId() == 'crystal_maiden') {\n            s.concat(self.ability().getManaRegenSelfArcaneAura())\n        }\n        else {\n            s.concat(self.buffs.getManaRegenArcaneAura())\n        }\n        s.concat(self.enemy().ability().getManaRegenReduction())\n        s.mult(1 + self.totalInt().total * constants.manaRegenPerInt, 'Mana Regen Amp', null, 'percent');                \n        return s;\n    });\n    self.totalArmorPhysical = ko.pureComputed(function () {\n        var armorAura = [self.inventory.getArmorAura, self.buffs.itemBuffs.getArmorAura].reduce(function (memo, fn) {\n            return fn(memo);\n        }, null);\n        \n        var armorReduction = [self.enemy().inventory.getArmorReduction, self.debuffs.itemBuffs.getArmorReduction].reduce(function (memo, fn) {\n            return fn(memo);\n        }, null);\n        \n        var armorReductionAura = [self.enemy().inventory.getArmorReductionAura, self.debuffs.itemBuffs.getArmorReductionAura].reduce(function (memo, fn) {\n            return fn(memo);\n        }, null);\n        \n        var armorBaseReduction = self.enemy().ability().getArmorBaseReduction() * self.debuffs.getArmorBaseReduction();\n        \n        var s = new StatModel(self.heroData().armorphysical, 'Base');\n        self.totalAgi().components.forEach(function (component) {\n            s.add(component.value * constants.armorPerAgi, component.label == 'Base' ? 'Base Agi' : component.label);\n        });\n        if (armorBaseReduction != 1) {\n            s.mult(self.enemy().ability().getArmorBaseReduction() * self.debuffs.getArmorBaseReduction(), 'Base Armor Reduction %');\n        }\n        if (!self.isIllusion()) {\n            s.concat(self.inventory.getArmor())\n            .concat(self.ability().getArmor())\n            .concat(TalentController.getArmor(self.selectedTalents()))\n            .concat(self.buffs.getArmor())\n            .concat(armorAura)\n            .concat(armorReductionAura)\n        }\n        s.concat(self.enemy().ability().getArmorReduction())\n        .concat(self.debuffs.getArmorReduction())\n        .concat(armorReduction)\n        return s;\n    });\n    self.totalArmorPhysicalReduction = ko.pureComputed(function () {\n        var totalArmor = self.totalArmorPhysical().total;\n        return (constants.armorMult * totalArmor) / (1 + constants.armorMult * Math.abs(totalArmor))\n    });\n    self.spellAmp = ko.pureComputed(function () {\n        var s = new StatModel();\n        self.totalInt().components.forEach(function (component) {\n            s.add(component.value * constants.spellDmgPerInt, component.label == 'Base' ? 'Base Int' : component.label, null, 'percent');\n        });\n        s.concat(self.inventory.getSpellAmp())\n        .concat(self.ability().getSpellAmp())\n        .concat(TalentController.getSpellAmp(self.selectedTalents()))\n        .concat(self.buffs.getSpellAmp())\n        return s;\n    });\n    self.cooldownReductionFlat = ko.pureComputed(function () {\n        return self.inventory.getCooldownReductionFlat()\n                + self.ability().getCooldownReductionFlat()\n                + TalentController.getCooldownReductionFlat(self.selectedTalents())\n                + self.buffs.getCooldownReductionFlat()\n                - self.enemy().inventory.getCooldownIncreaseFlat()\n                - self.enemy().ability().getCooldownIncreaseFlat()\n                - self.debuffs.getCooldownIncreaseFlat()\n                - self.debuffs.itemBuffs.getCooldownIncreaseFlat();\n    });\n    self.cooldownReductionProduct = ko.pureComputed(function () {\n        return self.inventory.getCooldownReductionPercent().value\n                * self.ability().getCooldownReductionPercent()\n                * TalentController.getCooldownReductionPercent(self.selectedTalents())\n                * self.buffs.getCooldownReductionPercent()\n                * self.enemy().inventory.getCooldownIncreasePercent()\n                * self.enemy().ability().getCooldownIncreasePercent()\n                * self.debuffs.getCooldownIncreasePercent()\n                * self.debuffs.itemBuffs.getCooldownIncreasePercent();\n    });\n    self.cooldownReductionPercent = ko.pureComputed(function () {\n        return 1 - self.cooldownReductionProduct();\n    });\n    self.totalMovementSpeed = ko.pureComputed(function () {\n        var MIN_MOVESPEED = 100;\n        var ms = (self.ability().setMovementSpeed() > 0 ? self.ability().setMovementSpeed() : self.buffs.setMovementSpeed());\n        if (ms > 0) {\n            return ms;\n        }\n        else {\n            var movementSpeedFlat = [self.inventory.getMovementSpeedFlat, self.buffs.itemBuffs.getMovementSpeedFlat].reduce(function (memo, fn) {\n                var obj = fn(memo.excludeList);\n                obj.value += memo.value;\n                return obj;\n            }, {value:0, excludeList:[]});\n            var movementSpeedPercent = [self.inventory.getMovementSpeedPercent, self.buffs.itemBuffs.getMovementSpeedPercent].reduce(function (memo, fn) {\n                var obj = fn(memo.excludeList);\n                obj.value += memo.value;\n                return obj;\n            }, {value:0, excludeList:[]});\n            var movementSpeedPercentReduction = [self.enemy().inventory.getMovementSpeedPercentReduction, self.debuffs.itemBuffs.getMovementSpeedPercentReduction].reduce(function (memo, fn) {\n                var obj = fn(memo.excludeList);\n                obj.value += memo.value;\n                return obj;\n            }, {value:0, excludeList:[]});\n            // If agility is a hero's primary attribute, every point in agility increases their movement speed by 0.06%.\n            var agiMovementSpeedPercent = self.primaryAttribute() == 'agi' ? self.totalAgi().total * (0.0006) : 0;\n            return Math.max(\n                self.enemy().inventory.isSheeped() || self.debuffs.itemBuffs.isSheeped() ? 140 :\n                (self.heroData().movementspeed + movementSpeedFlat.value + self.ability().getMovementSpeedFlat() + TalentController.getMovementSpeedFlat(self.selectedTalents())) * \n                (1 //+ self.inventory.getMovementSpeedPercent() \n                   + movementSpeedPercent.value\n                   + agiMovementSpeedPercent\n                   + movementSpeedPercentReduction.value\n                   + self.ability().getMovementSpeedPercent() \n                   //+ self.enemy().inventory.getMovementSpeedPercentReduction() \n                   + self.enemy().ability().getMovementSpeedPercentReduction() \n                   + self.buffs.getMovementSpeedPercent() \n                   + self.debuffs.getMovementSpeedPercentReduction()\n                   + self.unit().ability().getMovementSpeedPercent() \n                )\n            , MIN_MOVESPEED).toFixed(2);\n        }\n    });\n    self.totalTurnRate = ko.pureComputed(function () {\n        return (self.heroData().movementturnrate \n                * (1 + self.enemy().ability().getTurnRateReduction()\n                     + self.debuffs.getTurnRateReduction())).toFixed(2);\n    });\n    self.baseDamage = ko.pureComputed(function () {\n        var totalAttribute = self.totalAttribute(self.primaryAttribute()),\n            abilityBaseDamage = self.ability().getBaseDamage(),\n            minDamage = self.heroData().attackdamagemin,\n            maxDamage = self.heroData().attackdamagemax;\n        console.log('abilityBaseDamage.multiplier', abilityBaseDamage.multiplier);\n        var multiplier = self.ability().getSelfBaseDamageReductionPct()\n            * self.enemy().ability().getBaseDamageReductionPct()\n            * self.debuffs.getBaseDamageReductionPct()\n            * self.debuffs.itemBuffs.getBaseDamageReductionPct()\n            * abilityBaseDamage.multiplier\n            * (self.isIllusion() ? self.getOutgoingDamageMultiplier(self.illusionId(), false, self.heroData().attacktype) : 1);\n        return [\n            Math.floor((minDamage + totalAttribute + abilityBaseDamage.total) * multiplier),\n            Math.floor((maxDamage + totalAttribute + abilityBaseDamage.total) * multiplier)\n        ];\n    });\n    self.baseDamageAvg = ko.pureComputed(function () {\n        return (self.baseDamage()[0] + self.baseDamage()[1]) / 2;\n    });\n    self.baseDamageMin = ko.pureComputed(function () {\n        return self.baseDamage()[0];\n    });\n    self.baseDamageMax = ko.pureComputed(function () {\n        return self.baseDamage()[1];\n    });\n    self.bonusDamage = ko.pureComputed(function () {\n        return self.isIllusion() ? 0 : ((self.inventory.getBonusDamage().total\n                + self.ability().getBonusDamage().total\n                + TalentController.getBonusDamage(self.selectedTalents()).total\n                + self.buffs.getBonusDamage().total\n                + Math.floor((self.baseDamage()[0] + self.baseDamage()[1]) / 2 \n                              * (self.buffs.itemBuffs.getBonusDamagePercent(self.inventory.getBonusDamagePercent()).total\n                                 + self.ability().getBonusDamagePercent().total\n                                 + self.buffs.getBonusDamagePercent().total\n                                )\n                            )\n                + Math.floor(\n                    (self.heroData().attacktype == 'DOTA_UNIT_CAP_RANGED_ATTACK' \n                        ? ((self.heroId() == 'drow_ranger') ? self.ability().getBonusDamagePrecisionAura().total[0] * self.totalAgi().total : self.buffs.getBonusDamagePrecisionAura().total[1])\n                        : 0)\n                  )\n                + Math.floor(\n                    ((self.heroId() == 'riki') ? self.ability().getBonusDamageBackstab().total[0] * self.totalAgi().total : 0)\n                  )\n                ) * self.ability().getSelfBaseDamageReductionPct()\n                  * self.enemy().ability().getBaseDamageReductionPct()\n                  * self.debuffs.itemBuffs.getBaseDamageReductionPct());\n    });\n    self.bonusDamageReduction = ko.pureComputed(function () {\n        return Math.abs(self.enemy().ability().getBonusDamageReduction() + self.debuffs.getBonusDamageReduction());\n    });\n    self.damageAvg = ko.pureComputed(function () {\n        return (self.baseDamage()[0] + self.baseDamage()[1]) / 2 + self.bonusDamage();\n    });\n    self.damageMin = ko.pureComputed(function () {\n        return self.baseDamage()[0] + self.bonusDamage();\n    });\n    self.damageMax = ko.pureComputed(function () {\n        return self.baseDamage()[1] + self.bonusDamage();\n    });\n    self.damage = ko.pureComputed(function () {\n        return [self.baseDamage()[0] + self.bonusDamage(),\n                self.baseDamage()[1] + self.bonusDamage()];\n    });\n    self.totalStatusResistanceProduct = ko.pureComputed(function() {\n        // If strength is a hero's primary attribute, every point in strength increases their status resistance by 0.15%.\n        var strStatusResistance = self.primaryAttribute() == 'str' ? 1 - self.totalStr().total * (0.0015) : 1;\n        return strStatusResistance;\n    });\n    self.totalStatusResistance = ko.pureComputed(function () {\n        return 1 - self.totalStatusResistanceProduct();\n    });\n    self.totalMagicResistanceProduct = ko.pureComputed(function () {\n        //If intelligence is a hero's primary attribute, every point in intelligence increases their magic resistance by 0.15%.\n        var intMagicResistance = self.primaryAttribute() == 'int' ? 1 + self.totalInt().total * (0.0015) : 1;\n        return (1 - self.heroData().magicalresistance / 100)\n                * (self.isIllusion() ? 1 :\n                    self.inventory.getMagicResist()\n                    * intMagicResistance\n                    * self.ability().getMagicResist()\n                    * TalentController.getMagicResist(self.selectedTalents())\n                    * self.buffs.getMagicResist()\n                    * self.inventory.getMagicResistReductionSelf()\n                    * self.enemy().inventory.getMagicResistReduction()\n                    * self.enemy().ability().getMagicResistReduction()\n                    * self.debuffs.getMagicResistReduction()\n                    * self.debuffs.itemBuffs.getMagicResistReduction()\n                  );\n    });\n    self.totalMagicResistance = ko.pureComputed(function () {\n        return 1 - self.totalMagicResistanceProduct();\n    });\n    self.bat = ko.pureComputed(function () {\n        var abilityBAT = self.ability().getBAT();\n        if (abilityBAT > 0) {\n            return abilityBAT;\n        }\n        return self.heroData().attackrate;\n    });\n    self.ias = ko.pureComputed(function () {\n        var attackSpeed = [self.inventory.getAttackSpeed].reduce(function (memo, fn) {\n            var obj = fn(memo.excludeList);\n            obj.value += memo.value;\n            return obj;\n        }, {value:0, excludeList:[]});\n        var attackSpeedAura = [self.inventory.getAttackSpeedAura, self.buffs.itemBuffs.getAttackSpeedAura].reduce(function (memo, fn) {\n            var obj = fn(memo.excludeList);\n            obj.value += memo.value;\n            return obj;\n        }, {value: 0, excludeList: []});\n        var attackSpeedReduction = [self.enemy().inventory.getAttackSpeedReduction, self.debuffs.itemBuffs.getAttackSpeedReduction].reduce(function (memo, fn) {\n            var obj = fn(memo.excludeList);\n            obj.value += memo.value;\n            return obj;\n        }, {value:0, excludeList: []});\n        var val = self.totalAgi().total\n                //+ self.inventory.getAttackSpeed() \n                + attackSpeed.value\n                + attackSpeedAura.value\n                + attackSpeedReduction.value\n                //+ self.enemy().inventory.getAttackSpeedReduction() \n                + self.ability().getAttackSpeed() \n                + TalentController.getAttackSpeed(self.selectedTalents()) \n                + self.enemy().ability().getAttackSpeedReduction() \n                + self.buffs.getAttackSpeed() \n                + self.debuffs.getAttackSpeedReduction()\n                + self.unit().ability().getAttackSpeed(); \n        if (val < -80) {\n            return -80;\n        }\n        else if (val > 500) {\n            return 500;\n        }\n        return val.toFixed(2);\n    });\n    self.attackTime = ko.pureComputed(function () {\n        return (self.bat() / (1 + self.ias() / 100)).toFixed(2);\n    });\n    self.attacksPerSecond = ko.pureComputed(function () {\n        return ((1 + self.ias() / 100) / self.bat()).toFixed(2);\n    });\n    self.totalAccuracyProduct = ko.pureComputed(function () {\n        var accuracySources = self.inventory.getAccuracySource(self.heroData().attacktype);\n        extend(accuracySources, self.enemy().debuffs.itemBuffs.getAccuracyDebuffSource());\n        var accuracySourcesArray = [];\n        for (var prop in accuracySources) {\n            var el = accuracySources[prop];\n            el.name = prop\n            accuracySourcesArray.push(el);\n        }\n        return accuracySourcesArray.reduce(function (memo, source) {\n            return memo * Math.pow((1 - source.chance), source.count)\n        }, 1);\n    });\n    self.accuracy = ko.pureComputed(function () {\n        return 1 - self.totalAccuracyProduct();\n    });\n    self.totalEvasionProduct = ko.pureComputed(function () {\n        return self.inventory.getEvasion()\n            * self.ability().getEvasion()\n            * self.ability().getEvasionBacktrack()\n            * TalentController.getEvasion(self.selectedTalents())\n            * self.buffs.itemBuffs.getEvasion()\n    });\n    self.evasion = ko.pureComputed(function () {\n        if (self.enemy().inventory.isSheeped() || self.debuffs.itemBuffs.isSheeped()) return 0;\n        return 1 - self.totalEvasionProduct();\n    });\n    self.ehpPhysical = ko.pureComputed(function () {\n        var evasion = self.enemy().inventory.isSheeped() || self.debuffs.itemBuffs.isSheeped() ? 1 : self.inventory.getEvasion() * self.ability().getEvasion() * self.buffs.itemBuffs.getEvasion();\n        var ehp = self.health().total / (1 - self.totalArmorPhysicalReduction());\n        ehp /= (1 - (1 - (evasion * self.ability().getEvasionBacktrack())));\n        ehp /= (1 - parseFloat(self.enemy().missChance()) / 100);\n        ehp *= (self.inventory.activeItems().some(function (item) {return item.item == 'mask_of_madness';}) ? (1 / 1.3) : 1);\n        ehp *= (1 / self.ability().getDamageReduction());\n        ehp *= (1 / self.buffs.getDamageReduction());\n        ehp *= (1 / self.enemy().ability().getDamageAmplification());\n        ehp *= (1 / self.debuffs.getDamageAmplification());\n        if (self.isIllusion()) ehp *= (1 / self.getIncomingDamageMultiplier(self.illusionId(), false, self.heroData().attacktype));\n        return ehp.toFixed(2);\n    });\n    self.ehpMagical = ko.pureComputed(function () {\n        var ehp = self.health().total / self.totalMagicResistanceProduct();\n        ehp *= (self.inventory.activeItems().some(function (item) {return item.item == 'mask_of_madness';}) ? (1 / 1.3) : 1);\n        ehp *= (1 / self.ability().getDamageReduction());\n        ehp *= (1 / self.buffs.getDamageReduction());\n        ehp *= (1 / self.ability().getEvasionBacktrack());\n        ehp *= (1 / self.enemy().ability().getDamageAmplification());\n        ehp *= (1 / self.debuffs.getDamageAmplification());\n        if (self.isIllusion()) ehp *= (1 / self.getIncomingDamageMultiplier(self.illusionId(), false, self.heroData().attacktype));\n        return ehp.toFixed(2);\n    });\n    self.bash = ko.pureComputed(function () {\n        var attacktype = self.heroData().attacktype;\n        return 1 - self.inventory.getBash(attacktype) * self.ability().getBash();\n    });\n    \n    self.critChance = ko.pureComputed(function () {\n        return 1 - self.inventory.getCritChance() * self.ability().getCritChance();\n    });\n\n    HeroDamageMixin(self, itemData);\n    \n    self.missChance = ko.pureComputed(function () {\n        var blindDebuff = [self.enemy().inventory.getBlindSource, self.debuffs.itemBuffs.getBlindSource].reduce(function (memo, fn) {\n            var obj = fn(memo.excludeList);\n            obj.total += memo.total;\n            return obj;\n        }, {total:0, excludeList:[]});\n        var blind = 1 - Math.min(self.enemy().ability().getBlindSource().total + self.debuffs.getBlindSource().total + blindDebuff.total, 1);\n        return 1 - self.enemy().totalEvasionProduct() * blind;\n    });\n    self.hitChance = ko.pureComputed(function () {\n        return 1 - (parseFloat(self.missChance())/100) * (1 - parseFloat(self.accuracy())/100);\n    });\n    self.totalattackrange = ko.pureComputed(function () {\n        var attacktype = self.heroData().attacktype;\n        return self.heroData().attackrange\n             + self.ability().getAttackRange()\n             + TalentController.getAttackRange(self.selectedTalents())\n             + self.inventory.getAttackRange(attacktype).value;\n    });\n    self.visionrangeday = ko.pureComputed(function () {\n        return (self.heroData().visiondaytimerange) * (1 + self.enemy().ability().getVisionRangePctReduction() + self.debuffs.getVisionRangePctReduction());\n    });\n    self.visionrangenight = ko.pureComputed(function () {\n        return (self.heroData().visionnighttimerange + self.inventory.getVisionRangeNight() + self.ability().getVisionRangeNight()) * (1 + self.enemy().ability().getVisionRangePctReduction() + self.debuffs.getVisionRangePctReduction());\n    });\n    self.lifesteal = ko.pureComputed(function () {\n        var total = self.inventory.getLifesteal()\n                  + self.ability().getLifesteal()\n                  + TalentController.getLifesteal(self.selectedTalents())\n                  + self.buffs.getLifesteal();\n        if (self.heroData().attacktype == 'DOTA_UNIT_CAP_MELEE_ATTACK') {\n            var lifestealAura = [self.inventory.getLifestealAura, self.buffs.itemBuffs.getLifestealAura].reduce(function (memo, fn) {\n                var obj = fn(memo.excludeList);\n                obj.value += memo.value;\n                return obj;\n            }, {value: 0, excludeList: []});\n            total += lifestealAura.value;\n        }\n        return total/100;\n    });\n    \n    self.diffProperties = diffProperties;\n    self.diff = {};\n    self.diff2 = {};\n\n    for (var i = 0; i < self.diffProperties.length; i++) {\n        var index = i;\n        self.diff[self.diffProperties[index]] = self.getDiffFunction(self.diffProperties[index]);\n        self.diff2[self.diffProperties[index]] = self.getDiffFunction2(self.diffProperties[index]);\n    }\n};\n\nHeroModel.prototype.getDiffFunction = function (prop) {\n    var self = this;\n    return ko.pureComputed(function () {\n        if (prop == 'baseDamage') {\n            return [self[prop]()[0] - self.heroCompare()[prop]()[0], self[prop]()[1] - self.heroCompare()[prop]()[1]];\n        }\n        else {\n            return self[prop]() - self.heroCompare()[prop]();\n        }\n    }, this, { deferEvaluation: true });\n}\n\nHeroModel.prototype.getDiffFunction2 = function (prop) {\n    var self = this;\n    return ko.pureComputed(function () {\n        if (prop == 'baseDamage') {\n            return [self[prop]()[0] - self.heroCompare()[prop]()[0], self[prop]()[1] - self.heroCompare()[prop]()[1]];\n        }\n        else {\n            return self[prop]().total - self.heroCompare()[prop]().total;\n        }\n    }, this, { deferEvaluation: true });\n}\n\nHeroModel.prototype.getAbilityLevelMax = function (data) {\n    if (data.abilitytype === 'DOTA_ABILITY_TYPE_ATTRIBUTES') {\n        return 1;\n    }\n    else if (data.name === 'invoker_quas' || data.name === 'invoker_wex' || data.name === 'invoker_exort') {\n        return 7;\n    }\n    else if (data.name === 'invoker_invoke') {\n        return 1;\n    }\n    else if (data.name === 'earth_spirit_stone_caller' || data.name === 'ogre_magi_unrefined_fireblast' || data.name === 'monkey_king_mischief') {\n        return 1;\n    }\n    else if (data.abilitytype === 'DOTA_ABILITY_TYPE_ULTIMATE' || data.name === 'keeper_of_the_light_recall' ||\n             data.name === 'keeper_of_the_light_blinding_light' || data.name === 'ember_spirit_activate_fire_remnant' ||\n             data.name === 'lone_druid_true_form_battle_cry') {\n        return 3;\n    }\n    else if (data.name === 'puck_ethereal_jaunt'  || data.name === 'shadow_demon_shadow_poison_release' ||\n             data.name === 'templar_assassin_trap' || data.name === 'spectre_reality') {\n        return 0;\n    }\n    else if (data.name === 'invoker_cold_snap'  || data.name === 'invoker_ghost_walk' || data.name === 'invoker_tornado' || \n             data.name === 'invoker_emp' || data.name === 'invoker_alacrity' || data.name === 'invoker_chaos_meteor' || \n             data.name === 'invoker_sun_strike' || data.name === 'invoker_forge_spirit' || data.name === 'invoker_ice_wall' || \n             data.name === 'invoker_deafening_blast') {\n        return 0;\n    }\n    else if (data.name === 'techies_minefield_sign' || data.name === 'techies_focused_detonate') {\n        return 0;\n    }\n    else {\n        return 4;\n    }\n};\n\nHeroModel.prototype.toggleTalent = function (talentTier, talentIndex) {\n    if (this.talents[talentTier]() === talentIndex) {\n        this.talents[talentTier](-1);\n    }\n    else if (this.availableSkillPoints() > 0 || this.talents[talentTier]() == 1 - talentIndex) {\n        if (parseInt(this.selectedHeroLevel()) >= talentTier * 5 + 10) {\n            this.talents[talentTier](talentIndex);\n        }\n    }\n}\n\nmodule.exports = HeroModel;",
    "var HeroOption = function (name, displayname, hero) {\n    this.heroName = name;\n    this.heroDisplayName = displayname;\n    this.hero = hero;\n};\n\nmodule.exports = HeroOption;",
    "var cooldownTalents = require('../talents/cooldownTalents.json');\nvar talentAbilityMap = require('./talentAbilityMap');\nvar StatModel = require(\"../StatModel\");\n\nmodule.exports = {\n    getTalentById: function (talents, talentId) {\n        for (var i = 0; i < talents.length; i++) {\n            var ability = talents[i];\n            if (ability.name == talentId) {\n                return ability;\n            }\n        }\n    },\n    getBonusDamage: function (talents) {\n        var totalAttribute = 0;\n        var sources = {};\n        for (var i = 0; i < talents.length; i++) {\n            var ability = talents[i];\n            if (ability.name.startsWith('special_bonus_attack_damage_')) {\n                totalAttribute += ability.attributes[0].value[0];\n                sources[ability.name] = {\n                    'damage': ability.attributes[0].value[0],\n                    'damageType': 'physical',\n                    'displayname': ability.displayname\n                }\n            }\n        }\n        return { sources: sources, total: totalAttribute };\n    },\n    getHealth: function (talents) {\n        var sources = new StatModel();\n        for (var i = 0; i < talents.length; i++) {\n            var ability = talents[i];\n            if (ability.name.startsWith('special_bonus_hp_') && !ability.name.startsWith('special_bonus_hp_regen_')) {\n                sources.add(ability.attributes[0].value[0], ability.displayname);\n            }\n        }\n        return sources;\n    },\n    getHealthRegen: function (talents) {\n        var sources = new StatModel();\n        for (var i = 0; i < talents.length; i++) {\n            var ability = talents[i];\n            if (ability.name.startsWith('special_bonus_hp_regen_')) {\n                sources.add(ability.attributes[0].value[0], ability.displayname);\n            }\n        }\n        return sources;\n    },\n    getMana: function (talents) {\n        var sources = new StatModel();\n        for (var i = 0; i < talents.length; i++) {\n            var ability = talents[i];\n            if (ability.name.startsWith('special_bonus_mp_') && !ability.name.startsWith('special_bonus_mp_regen_')) {\n                sources.add(ability.attributes[0].value[0], ability.displayname);\n            }\n        }\n        return sources;\n    },\n    getManaRegen: function (talents) {\n        var sources = new StatModel();\n        for (var i = 0; i < talents.length; i++) {\n            var ability = talents[i];\n            if (ability.name.startsWith('special_bonus_mp_regen_')) {\n                sources.add(ability.attributes[0].value[0], ability.displayname);\n            }\n        }\n        return sources;\n    },\n    getArmor: function (talents) {\n        var sources = new StatModel();\n        for (var i = 0; i < talents.length; i++) {\n            var ability = talents[i];\n            if (ability.name.startsWith('special_bonus_armor_')) {\n                sources.add(ability.attributes[0].value[0], ability.displayname);\n            }\n        }\n        return sources;\n    },\n    getSpellAmp: function (talents) {\n        var sources = new StatModel();\n        for (var i = 0; i < talents.length; i++) {\n            var ability = talents[i];\n            if (ability.name.startsWith('special_bonus_spell_amplify_')) {\n                sources.add(ability.attributes[0].value[0]/100, ability.displayname);\n            }\n        }\n        return sources;\n    },\n    getUniqueCooldownReductionFlat: function (talents) {\n        var totalAttribute = {};\n        for (var i = 0; i < talents.length; i++) {\n            var talent = talents[i];\n            if (cooldownTalents.indexOf(talent.name) != -1) {\n                var abilities = [].concat(talentAbilityMap[talent.name]);\n                abilities.forEach(function (ability) {\n                    totalAttribute[ability] = talent.attributes[0].value[0];\n                });\n            }\n        }\n        return totalAttribute;\n    },\n    getCooldownReductionFlat: function (talents) {\n        var totalAttribute = 0;\n        return totalAttribute;\n    },\n    getCooldownReductionPercent: function (talents) {\n        var totalAttribute = 1;\n        for (var i = 0; i < talents.length; i++) {\n            var ability = talents[i];\n            if (ability.name.startsWith('special_bonus_cooldown_reduction_')) {\n                totalAttribute *= (1 - ability.attributes[0].value[0]/100);\n            }\n        }\n        return totalAttribute;\n    },\n    getCooldownIncreaseFlat: function (talents) {\n        var totalAttribute = 0;\n        return totalAttribute;\n    },\n    getCooldownIncreasePercent: function (talents) {\n        var totalAttribute = 1;\n        return totalAttribute;\n    },\n    getMovementSpeedFlat: function (talents) {\n        var totalAttribute = 0;\n        for (var i = 0; i < talents.length; i++) {\n            var ability = talents[i];\n            if (ability.name.startsWith('special_bonus_movement_speed_')) {\n                totalAttribute += ability.attributes[0].value[0];\n            }\n        }\n        return totalAttribute;\n    },\n    getAttackRange: function (talents) {\n        var totalAttribute = 0;\n        for (var i = 0; i < talents.length; i++) {\n            var ability = talents[i];\n            if (ability.name.startsWith('special_bonus_attack_range_')) {\n                totalAttribute += ability.attributes[0].value[0];\n            }\n        }\n        return totalAttribute;\n    },\n    getAttackSpeed: function (talents) {\n        var totalAttribute = 0;\n        for (var i = 0; i < talents.length; i++) {\n            var ability = talents[i];\n            if (ability.name.startsWith('special_bonus_attack_speed_')) {\n                totalAttribute += ability.attributes[0].value[0];\n            }\n        }\n        return totalAttribute;\n    },\n    getLifesteal: function (talents) {\n        var totalAttribute = 0;\n        for (var i = 0; i < talents.length; i++) {\n            var ability = talents[i];\n            if (ability.name.startsWith('special_bonus_lifesteal_')) {\n                totalAttribute += ability.attributes[0].value[0];\n            }\n        }\n        return totalAttribute;\n    },\n    getEvasion: function (talents) {\n        var totalAttribute = 1;\n        for (var i = 0; i < talents.length; i++) {\n            var ability = talents[i];\n            if (ability.name.startsWith('special_bonus_evasion_')) {\n                totalAttribute *= (1 - ability.attributes[0].value[0]/100);\n            }\n        }\n        return totalAttribute;\n    },\n    getMagicResist: function (talents) {\n        var totalAttribute = 1;\n        for (var i = 0; i < talents.length; i++) {\n            var ability = talents[i];\n            if (ability.name.startsWith('special_bonus_magic_resistance_')) {\n                totalAttribute *= (1 - ability.attributes[0].value[0]/100);\n            }\n        }\n        return totalAttribute;\n    },\n    getRespawnReduction: function (talents) {\n        var totalAttribute = 0;\n        for (var i = 0; i < talents.length; i++) {\n            var ability = talents[i];\n            if (ability.name.startsWith('special_bonus_respawn_reduction_')) {\n                totalAttribute += ability.attributes[0].value[0];\n            }\n        }\n        return totalAttribute;\n    },\n    getStrength: function (talents) {\n        var sources = new StatModel();\n        for (var i = 0; i < talents.length; i++) {\n            var ability = talents[i];\n            if (ability.name.startsWith('special_bonus_strength_')) {\n                sources.add(ability.attributes[0].value[0], ability.displayname);\n            }\n            else if (ability.name.startsWith('special_bonus_all_stats_')) {\n                sources.add(ability.attributes[0].value[0], ability.displayname);\n            }\n        }\n        return sources;\n    },\n    getAgility: function (talents) {\n        var sources = new StatModel();\n        for (var i = 0; i < talents.length; i++) {\n            var ability = talents[i];\n            if (ability.name.startsWith('special_bonus_agility_')) {\n                sources.add(ability.attributes[0].value[0], ability.displayname);\n            }\n            else if (ability.name.startsWith('special_bonus_all_stats_')) {\n                sources.add(ability.attributes[0].value[0], ability.displayname);\n            }\n        }\n        return sources;\n    },\n    getIntelligence: function (talents) {\n        var sources = new StatModel();\n        for (var i = 0; i < talents.length; i++) {\n            var ability = talents[i];\n            if (ability.name.startsWith('special_bonus_intelligence_')) {\n                sources.add(ability.attributes[0].value[0], ability.displayname);\n            }\n            else if (ability.name.startsWith('special_bonus_all_stats_')) {\n                sources.add(ability.attributes[0].value[0], ability.displayname);\n            }\n        }\n        return sources;\n    }\n}",
    "var diffProperties = [\n    'totalAgi',\n    'totalInt',\n    'totalStr',\n    'health',\n    'healthregen',\n    'mana',\n    'manaregen',\n    'totalArmorPhysical',\n    'totalArmorPhysicalReduction',\n    'totalMovementSpeed',\n    'totalTurnRate',\n    'spellAmp',\n    'cooldownReductionPercent',\n    'baseDamage',\n    'bonusDamage',\n    'bonusDamageReduction',\n    'damage',\n    'totalMagicResistanceProduct',\n    'totalMagicResistance',\n    'totalStatusResistance',\n    'bat',\n    'ias',\n    'attackTime',\n    'attacksPerSecond',\n    'evasion',\n    'ehpPhysical',\n    'ehpMagical',\n    'bash',\n    'critChance',\n    //'critDamage',\n    'missChance',\n    'accuracy',\n    'hitChance',\n    'totalattackrange',\n    'visionrangeday',\n    'visionrangenight',\n    'lifesteal',\n    'startingArmor'\n];\n\nmodule.exports = diffProperties;",
    "var HeroOption = require(\"./HeroOption\");\n\nvar heroOptionsArray = {};\n\nvar init = function (heroData) {\n    heroOptionsArray.items = [];\n    for (var h in heroData) {\n        heroOptionsArray.items.push(new HeroOption(h.replace('npc_dota_hero_', ''), heroData[h].displayname));\n    }\n    return heroOptionsArray.items;\n}\n\nheroOptionsArray.init = init;\n\nmodule.exports = heroOptionsArray;",
    "var nextLevelExp = [200, 400, 480, 600, 620, 640, 660, 680, 800, 820, 840, 900, 1225, 1250, 1275, 1300, 1325, 1400, 1490, 1500, 1750, 2000, 2250, 2500, '&mdash;'];\n\nmodule.exports = nextLevelExp;",
    "module.exports = {\n    \"special_bonus_unique_abaddon_2\": \"abaddon_death_coil\",\n    \"special_bonus_unique_abaddon\": \"abaddon_aphotic_shield\",\n    \"special_bonus_unique_abaddon_3\": \"abaddon_frostmourne\",\n    \"special_bonus_unique_underlord_2\": \"abyssal_underlord_firestorm\",\n    \"special_bonus_unique_underlord\": \"abyssal_underlord_pit_of_malice\",\n    \"special_bonus_unique_underlord_4\": \"abyssal_underlord_firestorm\",\n    \"special_bonus_unique_alchemist\": \"alchemist_unstable_concoction\",\n    \"special_bonus_unique_alchemist_2\": \"alchemist_unstable_concoction\",\n    \"special_bonus_unique_alchemist_3\": \"alchemist_chemical_rage\",\n    \"special_bonus_unique_alchemist_4\": \"alchemist_chemical_rage\",\n    \"special_bonus_unique_ancient_apparition_3\": \"ancient_apparition_ice_vortex\",\n    \"special_bonus_unique_ancient_apparition_4\": \"ancient_apparition_ice_vortex\",\n    \"special_bonus_unique_ancient_apparition_2\": \"ancient_apparition_chilling_touch\",\n    \"special_bonus_unique_ancient_apparition_1\": \"ancient_apparition_cold_feet\",\n    \"special_bonus_unique_ancient_apparition_5\": \"ancient_apparition_ice_blast\",\n    \"special_bonus_unique_antimage\": \"antimage_blink\",\n    \"special_bonus_unique_antimage_5\": \"antimage_blink\",\n    \"special_bonus_unique_antimage_3\": \"antimage_blink\",\n    \"special_bonus_unique_antimage_4\": \"antimage_spell_shield\",\n    \"special_bonus_unique_antimage_2\": \"antimage_mana_void\",\n    \"special_bonus_unique_arc_warden_2\": \"arc_warden_flux\",\n    \"special_bonus_unique_arc_warden\": \"arc_warden_spark_wraith\",\n    \"special_bonus_unique_axe_3\": \"axe_counter_helix\",\n    \"special_bonus_unique_axe_2\": \"axe_berserkers_call\",\n    \"special_bonus_unique_axe\": \"axe_battle_hunger\",\n    \"special_bonus_unique_bane_4\": \"bane_enfeeble\",\n    \"special_bonus_unique_bane_1\": \"bane_enfeeble\",\n    \"special_bonus_unique_bane_2\": \"bane_brain_sap\",\n    \"special_bonus_unique_bane_3\": \"bane_fiends_grip\",\n    \"special_bonus_unique_batrider_3\": \"batrider_flamebreak\",\n    \"special_bonus_unique_batrider_1\": \"batrider_firefly\",\n    \"special_bonus_unique_batrider_2\": \"batrider_flamebreak\",\n    \"special_bonus_unique_beastmaster\": \"beastmaster_wild_axes\",\n    \"special_bonus_unique_beastmaster_4\": \"beastmaster_inner_beast\",\n    \"special_bonus_unique_bloodseeker_2\": \"bloodseeker_blood_bath\",\n    \"special_bonus_unique_bloodseeker_3\": \"bloodseeker_rupture\",\n    \"special_bonus_unique_bloodseeker\": \"bloodseeker_blood_bath\",\n    \"special_bonus_unique_bloodseeker_4\": \"bloodseeker_thirst\",\n    \"special_bonus_unique_bounty_hunter_2\": \"bounty_hunter_shuriken_toss\",\n    \"special_bonus_unique_bounty_hunter\": \"bounty_hunter_jinada\",\n    \"special_bonus_unique_bounty_hunter_3\": \"bounty_hunter_track\",\n    \"special_bonus_unique_brewmaster_3\": \"brewmaster_thunder_clap\",\n    \"special_bonus_unique_brewmaster\": \"brewmaster_primal_split\",\n    \"special_bonus_unique_brewmaster_2\": \"brewmaster_primal_split\",\n    \"special_bonus_unique_brewmaster_4\": \"brewmaster_drunken_brawler\",\n    \"special_bonus_unique_bristleback_3\": \"bristleback_warpath\",\n    \"special_bonus_unique_broodmother_1\": \"broodmother_insatiable_hunger\",\n    \"special_bonus_unique_centaur_3\": \"centaur_return\",\n    \"special_bonus_unique_centaur_4\": \"centaur_double_edge\",\n    \"special_bonus_unique_centaur_1\": \"centaur_return\",\n    \"special_bonus_unique_centaur_2\": \"centaur_hoof_stomp\",\n    \"special_bonus_unique_chaos_knight\": \"chaos_knight_reality_rift\",\n    \"special_bonus_unique_chaos_knight_2\": \"chaos_knight_reality_rift\",\n    \"special_bonus_unique_chaos_knight_3\": \"chaos_knight_chaos_bolt\",\n    \"special_bonus_unique_chen_3\": \"chen_test_of_faith\",\n    \"special_bonus_unique_chen_1\": \"chen_holy_persuasion\",\n    \"special_bonus_unique_chen_2\": \"chen_hand_of_god\",\n    \"special_bonus_unique_clinkz_1\": \"clinkz_searing_arrows\",\n    \"special_bonus_unique_clinkz_2\": \"clinkz_strafe\",\n    \"special_bonus_unique_clinkz_3\": \"clinkz_searing_arrows\",\n    \"special_bonus_unique_crystal_maiden_3\": \"crystal_maiden_freezing_field\",\n    \"special_bonus_unique_crystal_maiden_1\": \"crystal_maiden_frostbite\",\n    \"special_bonus_unique_crystal_maiden_2\": \"crystal_maiden_crystal_nova\",\n    \"special_bonus_unique_dark_seer_2\": \"dark_seer_vacuum\",\n    \"special_bonus_unique_dark_seer_3\": \"dark_seer_surge\",\n    \"special_bonus_unique_dark_seer\": \"dark_seer_ion_shell\",\n    \"special_bonus_unique_dark_willow_1\": \"dark_willow_shadow_realm\",\n    \"special_bonus_unique_dark_willow_2\": \"dark_willow_terrorize\",\n    \"special_bonus_unique_dazzle_2\": \"dazzle_shadow_wave\",\n    \"special_bonus_unique_dazzle_3\": \"dazzle_poison_touch\",\n    \"special_bonus_unique_dazzle_1\": \"dazzle_shadow_wave\",\n    \"special_bonus_unique_dazzle_4\": \"dazzle_weave\",\n    \"special_bonus_unique_death_prophet_3\": \"death_prophet_spirit_siphon\",\n    \"special_bonus_unique_death_prophet_2\": \"death_prophet_carrion_swarm\",\n    \"special_bonus_unique_death_prophet_4\": \"death_prophet_exorcism\",\n    \"special_bonus_unique_death_prophet\": \"death_prophet_exorcism\",\n    \"special_bonus_unique_disruptor_3\": \"disruptor_thunder_strike\",\n    \"special_bonus_unique_disruptor_2\": \"disruptor_kinetic_field\",\n    \"special_bonus_unique_disruptor\": \"disruptor_thunder_strike\",\n    \"special_bonus_unique_disruptor_4\": \"disruptor_glimpse\",\n    \"special_bonus_unique_disruptor_5\": \"disruptor_kinetic_field\",\n    \"special_bonus_unique_doom_4\": \"doom_bringer_scorched_earth\",\n    \"special_bonus_unique_doom_3\": \"doom_bringer_devour\",\n    \"special_bonus_unique_doom_5\": \"doom_bringer_doom\",\n    \"special_bonus_unique_doom_2\": \"doom_bringer_devour\",\n    \"special_bonus_unique_doom_1\": \"doom_bringer_infernal_blade\",\n    \"special_bonus_unique_dragon_knight\": \"dragon_knight_dragon_blood\",\n    \"special_bonus_unique_dragon_knight_2\": \"dragon_knight_dragon_tail\",\n    \"special_bonus_unique_drow_ranger_2\": \"drow_ranger_wave_of_silence\",\n    \"special_bonus_unique_drow_ranger_3\": \"drow_ranger_marksmanship\",\n    \"special_bonus_unique_drow_ranger_4\": \"drow_ranger_wave_of_silence\",\n    \"special_bonus_unique_drow_ranger_1\": \"drow_ranger_trueshot\",\n    \"special_bonus_unique_earth_spirit\": \"earth_spirit_rolling_boulder\",\n    \"special_bonus_unique_earth_spirit_2\": \"earth_spirit_geomagnetic_grip\",\n    \"special_bonus_unique_earth_spirit_3\": \"earth_spirit_boulder_smash\",\n    \"special_bonus_unique_earthshaker_3\": \"earthshaker_fissure\",\n    \"special_bonus_unique_earthshaker\": \"earthshaker_enchant_totem\",\n    \"special_bonus_unique_elder_titan\": \"elder_titan_ancestral_spirit\",\n    \"special_bonus_unique_elder_titan_2\": \"elder_titan_echo_stomp\",\n    \"special_bonus_unique_elder_titan_3\": \"elder_titan_earth_splitter\",\n    \"special_bonus_unique_ember_spirit_1\": \"ember_spirit_flame_guard\",\n    \"special_bonus_unique_ember_spirit_3\": \"ember_spirit_flame_guard\",\n    \"special_bonus_unique_ember_spirit_2\": \"ember_spirit_searing_chains\",\n    \"special_bonus_unique_ember_spirit_4\": \"ember_spirit_sleight_of_fist\",\n    \"special_bonus_unique_enchantress_2\": \"enchantress_natures_attendants\",\n    \"special_bonus_unique_enchantress_3\": \"enchantress_untouchable\",\n    \"special_bonus_unique_enchantress_1\": \"enchantress_enchant\",\n    \"special_bonus_unique_enchantress_4\": \"enchantress_impetus\",\n    \"special_bonus_unique_enchantress_5\": \"enchantress_natures_attendants\",\n    \"special_bonus_unique_enigma_2\": \"enigma_malefice\",\n    \"special_bonus_unique_enigma\": \"enigma_demonic_conversion\",\n    \"special_bonus_unique_faceless_void_3\": \"faceless_void_time_lock\",\n    \"special_bonus_unique_faceless_void_2\": \"faceless_void_chronosphere\",\n    \"special_bonus_unique_furion_4\": \"furion_sprout\",\n    \"special_bonus_unique_furion_3\": \"furion_teleportation\",\n    \"special_bonus_unique_gyrocopter_2\": \"gyrocopter_flak_cannon\",\n    \"special_bonus_unique_gyrocopter_3\": \"gyrocopter_rocket_barrage\",\n    \"special_bonus_unique_gyrocopter_4\": \"gyrocopter_call_down\",\n    \"special_bonus_unique_gyrocopter_1\": \"gyrocopter_homing_missile\",\n    \"special_bonus_unique_gyrocopter_5\": \"gyrocopter_call_down\",\n    \"special_bonus_unique_huskar_2\": \"huskar_burning_spear\",\n    \"special_bonus_unique_huskar\": \"huskar_life_break\",\n    \"special_bonus_unique_huskar_3\": \"huskar_inner_vitality\",\n    \"special_bonus_unique_invoker_8\": \"invoker_tornado\",\n    \"special_bonus_unique_invoker_6\": \"invoker_chaos_meteor\",\n    \"special_bonus_unique_invoker_7\": \"invoker_cold_snap\",\n    \"special_bonus_unique_invoker_5\": \"invoker_alacrity\",\n    \"special_bonus_unique_invoker_2\": \"invoker_deafening_blast\",\n    \"special_bonus_unique_invoker_3\": \"invoker_tornado\",\n    \"special_bonus_unique_jakiro_2\": \"jakiro_dual_breath\",\n    \"special_bonus_unique_jakiro_4\": \"jakiro_liquid_fire\",\n    \"special_bonus_unique_jakiro_3\": \"jakiro_macropyre\",\n    \"special_bonus_unique_jakiro\": \"jakiro_ice_path\",\n    \"special_bonus_unique_juggernaut\": \"juggernaut_blade_fury\",\n    \"special_bonus_unique_juggernaut_3\": \"juggernaut_blade_fury\",\n    \"special_bonus_unique_juggernaut_2\": \"juggernaut_omni_slash\",\n    \"special_bonus_unique_keeper_of_the_light_2\": \"keeper_of_the_light_chakra_magic\",\n    \"special_bonus_unique_keeper_of_the_light_3\": \"keeper_of_the_light_mana_leak\",\n    \"special_bonus_unique_keeper_of_the_light\": \"keeper_of_the_light_spirit_form_illuminate\",\n    \"special_bonus_unique_kunkka_2\": \"kunkka_torrent\",\n    \"special_bonus_unique_kunkka\": \"kunkka_torrent\",\n    \"special_bonus_unique_kunkka_4\": \"kunkka_tidebringer\",\n    \"special_bonus_unique_legion_commander_4\": \"legion_commander_overwhelming_odds\",\n    \"special_bonus_unique_legion_commander\": \"legion_commander_duel\",\n    \"special_bonus_unique_legion_commander_2\": \"legion_commander_press_the_attack\",\n    \"special_bonus_unique_leshrac_3\": \"leshrac_pulse_nova\",\n    \"special_bonus_unique_leshrac_1\": \"leshrac_diabolic_edict\",\n    \"special_bonus_unique_leshrac_2\": \"leshrac_lightning_storm\",\n    \"special_bonus_unique_lich_3\": \"lich_frost_nova\",\n    \"special_bonus_unique_lich_1\": \"lich_frost_armor\",\n    \"special_bonus_unique_lifestealer_2\": \"life_stealer_open_wounds\",\n    \"special_bonus_unique_lifestealer_3\": \"life_stealer_feast\",\n    \"special_bonus_unique_lifestealer\": \"life_stealer_rage\",\n    \"special_bonus_unique_lina_3\": \"lina_light_strike_array\",\n    \"special_bonus_unique_lina_2\": \"lina_fiery_soul\",\n    \"special_bonus_unique_lina_1\": \"lina_dragon_slave\",\n    \"special_bonus_unique_lion_3\": \"lion_finger_of_death\",\n    \"special_bonus_unique_lion\": \"lion_mana_drain\",\n    \"special_bonus_unique_lion_2\": \"lion_impale\",\n    \"special_bonus_unique_lion_4\": \"lion_voodoo\",\n    \"special_bonus_unique_lone_druid_4\": \"lone_druid_savage_roar\",\n    \"special_bonus_unique_lone_druid_8\": \"lone_druid_true_form_battle_cry\",\n    \"special_bonus_unique_lone_druid_6\": \"lone_druid_rabid\",\n    \"special_bonus_unique_lone_druid_7\": \"lone_druid_true_form_battle_cry\",\n    \"special_bonus_unique_luna_2\": \"luna_lucent_beam\",\n    \"special_bonus_unique_luna_3\": \"luna_lunar_blessing\",\n    \"special_bonus_unique_luna_1\": \"luna_lucent_beam\",\n    \"special_bonus_unique_luna_5\": \"luna_eclipse\",\n    \"special_bonus_unique_lycan_1\": \"lycan_shapeshift\",\n    \"special_bonus_unique_lycan_4\": \"lycan_feral_impulse\",\n    \"special_bonus_unique_lycan_5\": \"lycan_howl\",\n    \"special_bonus_unique_magnus_4\": \"magnataur_shockwave\",\n    \"special_bonus_unique_magnus_3\": \"magnataur_skewer\",\n    \"special_bonus_unique_magnus_2\": \"magnataur_empower\",\n    \"special_bonus_unique_magnus_5\": \"magnataur_reverse_polarity\",\n    \"special_bonus_unique_medusa_3\": \"medusa_mystic_snake\",\n    \"special_bonus_unique_medusa\": \"medusa_stone_gaze\",\n    \"special_bonus_unique_medusa_2\": \"medusa_split_shot\",\n    \"special_bonus_unique_medusa_4\": \"medusa_split_shot\",\n    \"special_bonus_unique_meepo_2\": \"meepo_poof\",\n    \"special_bonus_unique_meepo_3\": \"meepo_earthbind\",\n    \"special_bonus_unique_meepo\": \"meepo_poof\",\n    \"special_bonus_unique_mirana_3\": \"mirana_arrow\",\n    \"special_bonus_unique_mirana_1\": \"mirana_leap\",\n    \"special_bonus_unique_mirana_2\": \"mirana_arrow\",\n    \"special_bonus_unique_mirana_4\": \"mirana_invis\",\n    \"special_bonus_unique_monkey_king_5\": \"monkey_king_tree_dance\",\n    \"special_bonus_unique_monkey_king_7\": \"monkey_king_tree_dance\",\n    \"special_bonus_unique_monkey_king_2\": \"monkey_king_jingu_mastery\",\n    \"special_bonus_unique_monkey_king\": \"monkey_king_boundless_strike\",\n    \"special_bonus_unique_monkey_king_3\": \"monkey_king_primal_spring\",\n    \"special_bonus_unique_monkey_king_4\": \"monkey_king_wukongs_command\",\n    \"special_bonus_unique_monkey_king_6\": \"monkey_king_wukongs_command\",\n    \"special_bonus_unique_morphling_1\": \"morphling_waveform\",\n    \"special_bonus_unique_morphling_4\": \"morphling_waveform\",\n    \"special_bonus_unique_morphling_5\": \"morphling_replicate\",\n    \"special_bonus_unique_morphling_8\": \"morphling_replicate\",\n    \"special_bonus_unique_morphling_6\": \"morphling_waveform\",\n    \"special_bonus_unique_naga_siren_4\": \"naga_siren_mirror_image\",\n    \"special_bonus_unique_naga_siren_2\": \"naga_siren_ensnare\",\n    \"special_bonus_unique_naga_siren\": \"naga_siren_mirror_image\",\n    \"special_bonus_unique_naga_siren_3\": \"naga_siren_rip_tide\",\n    \"special_bonus_unique_necrophos_2\": \"necrolyte_heartstopper_aura\",\n    \"special_bonus_unique_necrophos\": \"necrolyte_death_pulse\",\n    \"special_bonus_unique_nevermore_2\": \"nevermore_shadowraze3\",\n    \"special_bonus_unique_night_stalker\": \"night_stalker_crippling_fear\",\n    \"special_bonus_unique_nyx\": \"nyx_assassin_spiked_carapace\",\n    \"special_bonus_unique_nyx_2\": \"nyx_assassin_impale\",\n    \"special_bonus_unique_nyx_3\": \"nyx_assassin_vendetta\",\n    \"special_bonus_unique_outworld_devourer_2\": \"obsidian_destroyer_essence_aura\",\n    \"special_bonus_unique_outworld_devourer_3\": \"obsidian_destroyer_sanity_eclipse\",\n    \"special_bonus_unique_outworld_devourer\": \"obsidian_destroyer_arcane_orb\",\n    \"special_bonus_unique_ogre_magi\": \"ogre_magi_bloodlust\",\n    \"special_bonus_unique_ogre_magi_2\": \"ogre_magi_fireblast\",\n    \"special_bonus_unique_omniknight_4\": \"omniknight_purification\",\n    \"special_bonus_unique_omniknight_2\": \"omniknight_degen_aura\",\n    \"special_bonus_unique_omniknight_1\": \"omniknight_purification\",\n    \"special_bonus_unique_omniknight_3\": \"omniknight_repel\",\n    \"special_bonus_unique_oracle_2\": \"oracle_fortunes_end\",\n    \"special_bonus_unique_oracle_4\": \"oracle_false_promise\",\n    \"special_bonus_unique_oracle_3\": \"oracle_fates_edict\",\n    \"special_bonus_unique_oracle\": \"oracle_false_promise\",\n    \"special_bonus_unique_pangolier_2\": \"pangolier_shield_crash\",\n    \"special_bonus_unique_pangolier_3\": \"pangolier_swashbuckle\",\n    \"special_bonus_unique_pangolier_4\": \"pangolier_swashbuckle\",\n    \"special_bonus_unique_pangolier_5\": \"pangolier_gyroshell\",\n    \"special_bonus_unique_phantom_assassin\": \"phantom_assassin_stifling_dagger\",\n    \"special_bonus_unique_phantom_assassin_2\": \"phantom_assassin_coup_de_grace\",\n    \"special_bonus_unique_phantom_assassin_3\": \"phantom_assassin_blur\",\n    \"special_bonus_unique_phantom_lancer_2\": \"phantom_lancer_spirit_lance\",\n    \"special_bonus_unique_phantom_lancer\": \"phantom_lancer_phantom_edge\",\n    \"special_bonus_unique_phantom_lancer_3\": \"phantom_lancer_juxtapose\",\n    \"special_bonus_unique_phantom_lancer_4\": \"phantom_lancer_doppelwalk\",\n    \"special_bonus_unique_phoenix_3\": \"phoenix_fire_spirits\",\n    \"special_bonus_unique_phoenix_4\": \"phoenix_icarus_dive\",\n    \"special_bonus_unique_phoenix_2\": \"phoenix_supernova\",\n    \"special_bonus_unique_phoenix_1\": \"phoenix_supernova\",\n    \"special_bonus_unique_phoenix_5\": \"phoenix_sun_ray\",\n    \"special_bonus_unique_puck_2\": \"puck_waning_rift\",\n    \"special_bonus_unique_puck\": \"puck_illusory_orb\",\n    \"special_bonus_unique_puck_3\": \"puck_dream_coil\",\n    \"special_bonus_unique_pudge_2\": \"pudge_rot\",\n    \"special_bonus_unique_pudge_3\": \"pudge_dismember\",\n    \"special_bonus_unique_pudge_1\": \"pudge_flesh_heap\",\n    \"special_bonus_unique_pugna_6\": \"pugna_nether_ward\",\n    \"special_bonus_unique_pugna_1\": \"pugna_life_drain\",\n    \"special_bonus_unique_pugna_5\": \"pugna_decrepify\",\n    \"special_bonus_unique_pugna_2\": \"pugna_nether_blast\",\n    \"special_bonus_unique_queen_of_pain\": \"queenofpain_shadow_strike\",\n    \"special_bonus_unique_clockwerk_3\": \"rattletrap_battery_assault\",\n    \"special_bonus_unique_clockwerk_2\": \"rattletrap_rocket_flare\",\n    \"special_bonus_unique_clockwerk_4\": \"rattletrap_rocket_flare\",\n    \"special_bonus_unique_clockwerk\": \"rattletrap_battery_assault\",\n    \"special_bonus_unique_razor\": \"razor_static_link\",\n    \"special_bonus_unique_razor_3\": \"razor_unstable_current\",\n    \"special_bonus_unique_razor_2\": \"razor_eye_of_the_storm\",\n    \"special_bonus_unique_razor_4\": \"razor_unstable_current\",\n    \"special_bonus_unique_riki_3\": \"riki_blink_strike\",\n    \"special_bonus_unique_riki_4\": \"riki_tricks_of_the_trade\",\n    \"special_bonus_unique_riki_5\": \"riki_permanent_invisibility\",\n    \"special_bonus_unique_rubick_2\": \"rubick_fade_bolt\",\n    \"special_bonus_unique_rubick_3\": \"rubick_null_field\",\n    \"special_bonus_unique_rubick\": \"rubick_telekinesis_land\",\n    \"special_bonus_unique_rubick_4\": \"rubick_telekinesis\",\n    \"special_bonus_unique_rubick_5\": \"rubick_empty2\",\n    \"special_bonus_unique_sand_king_2\": \"sandking_sand_storm\",\n    \"special_bonus_unique_sand_king_3\": \"sandking_epicenter\",\n    \"special_bonus_unique_sand_king\": \"sandking_epicenter\",\n    \"special_bonus_unique_sand_king_4\": \"sandking_sand_storm\",\n    \"special_bonus_unique_shadow_demon_4\": \"shadow_demon_shadow_poison\",\n    \"special_bonus_unique_shadow_demon_2\": \"shadow_demon_soul_catcher\",\n    \"special_bonus_unique_shadow_demon_3\": \"shadow_demon_shadow_poison\",\n    \"special_bonus_unique_shadow_demon_1\": \"shadow_demon_demonic_purge\",\n    \"special_bonus_unique_shadow_demon_5\": \"shadow_demon_disruption\",\n    \"special_bonus_unique_shadow_shaman_5\": \"shadow_shaman_voodoo\",\n    \"special_bonus_unique_shadow_shaman_2\": \"shadow_shaman_shackles\",\n    \"special_bonus_unique_shadow_shaman_3\": \"shadow_shaman_ether_shock\",\n    \"special_bonus_unique_timbersaw_2\": \"shredder_reactive_armor\",\n    \"special_bonus_unique_timbersaw\": \"shredder_whirling_death\",\n    \"special_bonus_unique_timbersaw_3\": \"shredder_timber_chain\",\n    \"special_bonus_unique_silencer\": \"silencer_curse_of_the_silent\",\n    \"special_bonus_unique_silencer_3\": \"silencer_glaives_of_wisdom\",\n    \"special_bonus_unique_silencer_4\": \"silencer_global_silence\",\n    \"special_bonus_unique_wraith_king_3\": \"skeleton_king_hellfire_blast\",\n    \"special_bonus_unique_wraith_king_1\": \"skeleton_king_reincarnation\",\n    \"special_bonus_unique_wraith_king_2\": \"skeleton_king_vampiric_aura\",\n    \"special_bonus_unique_wraith_king_4\": \"skeleton_king_reincarnation\",\n    \"special_bonus_unique_skywrath\": \"skywrath_mage_ancient_seal\",\n    \"special_bonus_unique_skywrath_2\": \"skywrath_mage_arcane_bolt\",\n    \"special_bonus_unique_skywrath_4\": \"skywrath_mage_concussive_shot\",\n    \"special_bonus_unique_skywrath_3\": \"skywrath_mage_ancient_seal\",\n    \"special_bonus_unique_skywrath_5\": \"skywrath_mage_mystic_flare\",\n    \"special_bonus_unique_slardar_3\": \"slardar_amplify_damage\",\n    \"special_bonus_unique_slark_2\": \"slark_dark_pact\",\n    \"special_bonus_unique_slark\": \"slark_pounce\",\n    \"special_bonus_unique_slark_3\": \"slark_shadow_dance\",\n    \"special_bonus_unique_slark_4\": \"slark_essence_shift\",\n    \"special_bonus_unique_sniper_1\": \"sniper_shrapnel\",\n    \"special_bonus_unique_sniper_3\": \"sniper_headshot\",\n    \"special_bonus_unique_sniper_4\": \"sniper_assassinate\",\n    \"special_bonus_unique_sniper_2\": \"sniper_shrapnel\",\n    \"special_bonus_unique_spectre_2\": \"spectre_desolate\",\n    \"special_bonus_unique_spectre\": \"spectre_spectral_dagger\",\n    \"special_bonus_unique_spectre_3\": \"spectre_spectral_dagger\",\n    \"special_bonus_unique_spectre_4\": \"spectre_haunt\",\n    \"special_bonus_unique_spectre_5\": \"spectre_dispersion\",\n    \"special_bonus_unique_spirit_breaker_3\": \"spirit_breaker_greater_bash\",\n    \"special_bonus_unique_spirit_breaker_1\": \"spirit_breaker_greater_bash\",\n    \"special_bonus_unique_storm_spirit_5\": \"storm_spirit_static_remnant\",\n    \"special_bonus_unique_storm_spirit\": \"storm_spirit_electric_vortex\",\n    \"special_bonus_unique_storm_spirit_3\": \"storm_spirit_overload\",\n    \"special_bonus_unique_storm_spirit_4\": \"storm_spirit_ball_lightning\",\n    \"special_bonus_unique_sven_3\": \"sven_storm_bolt\",\n    \"special_bonus_unique_sven_2\": \"sven_gods_strength\",\n    \"special_bonus_unique_sven\": \"sven_storm_bolt\",\n    \"special_bonus_unique_techies_3\": \"techies_land_mines\",\n    \"special_bonus_unique_templar_assassin_6\": \"templar_assassin_psionic_trap\",\n    \"special_bonus_unique_templar_assassin_3\": \"templar_assassin_psionic_trap\",\n    \"special_bonus_unique_templar_assassin_4\": \"templar_assassin_refraction\",\n    \"special_bonus_unique_templar_assassin_2\": \"templar_assassin_meld\",\n    \"special_bonus_unique_templar_assassin_5\": \"templar_assassin_psi_blades\",\n    \"special_bonus_unique_templar_assassin\": \"templar_assassin_refraction\",\n    \"special_bonus_unique_terrorblade_2\": \"terrorblade_reflection\",\n    \"special_bonus_unique_terrorblade\": \"terrorblade_sunder\",\n    \"special_bonus_unique_terrorblade_3\": \"terrorblade_metamorphosis\",\n    \"special_bonus_unique_tidehunter_2\": \"tidehunter_gush\",\n    \"special_bonus_unique_tidehunter_3\": \"tidehunter_anchor_smash\",\n    \"special_bonus_unique_tidehunter_4\": \"tidehunter_kraken_shell\",\n    \"special_bonus_unique_tidehunter\": \"tidehunter_gush\",\n    \"special_bonus_unique_tinker_2\": \"tinker_march_of_the_machines\",\n    \"special_bonus_unique_tinker\": \"tinker_laser\",\n    \"special_bonus_unique_tiny\": \"tiny_avalanche\",\n    \"special_bonus_unique_tiny_4\": \"tiny_craggy_exterior\",\n    \"special_bonus_unique_tiny_5\": \"tiny_toss\",\n    \"special_bonus_unique_tiny_3\": \"tiny_avalanche\",\n    \"special_bonus_unique_tiny_2\": \"tiny_toss\",\n    \"special_bonus_unique_treant_4\": \"treant_natures_guise\",\n    \"special_bonus_unique_treant_2\": \"treant_leech_seed\",\n    \"special_bonus_unique_treant\": \"treant_living_armor\",\n    \"special_bonus_unique_treant_5\": \"treant_overgrowth\",\n    \"special_bonus_unique_troll_warlord_2\": \"troll_warlord_fervor\",\n    \"special_bonus_unique_troll_warlord_4\": \"troll_warlord_battle_trance\",\n    \"special_bonus_unique_tusk_2\": \"tusk_snowball\",\n    \"special_bonus_unique_tusk_3\": \"tusk_snowball\",\n    \"special_bonus_unique_tusk_5\": \"tusk_ice_shards\",\n    \"special_bonus_unique_undying_3\": \"undying_tombstone\",\n    \"special_bonus_unique_undying_4\": \"undying_decay\",\n    \"special_bonus_unique_undying\": \"undying_tombstone\",\n    \"special_bonus_unique_undying_5\": \"undying_tombstone\",\n    \"special_bonus_unique_undying_2\": \"undying_decay\",\n    \"special_bonus_unique_ursa_2\": \"ursa_earthshock\",\n    \"special_bonus_unique_ursa_3\": \"ursa_enrage\",\n    \"special_bonus_unique_ursa_4\": \"ursa_fury_swipes\",\n    \"special_bonus_unique_ursa_5\": \"ursa_earthshock\",\n    \"special_bonus_unique_ursa\": \"ursa_fury_swipes\",\n    \"special_bonus_unique_vengeful_spirit_4\": \"vengefulspirit_wave_of_terror\",\n    \"special_bonus_unique_vengeful_spirit_6\": \"vengefulspirit_wave_of_terror\",\n    \"special_bonus_unique_vengeful_spirit_5\": \"vengefulspirit_magic_missile\",\n    \"special_bonus_unique_vengeful_spirit_2\": \"vengefulspirit_command_aura\",\n    \"special_bonus_unique_vengeful_spirit_1\": \"vengefulspirit_magic_missile\",\n    \"special_bonus_unique_vengeful_spirit_3\": \"vengefulspirit_magic_missile\",\n    \"special_bonus_unique_venomancer_3\": \"venomancer_venomous_gale\",\n    \"special_bonus_unique_venomancer_2\": \"venomancer_poison_sting\",\n    \"special_bonus_unique_venomancer_4\": \"venomancer_poison_nova\",\n    \"special_bonus_unique_venomancer_6\": \"venomancer_poison_nova\",\n    \"special_bonus_unique_venomancer\": \"venomancer_plague_ward\",\n    \"special_bonus_unique_viper_1\": \"viper_corrosive_skin\",\n    \"special_bonus_unique_viper_2\": \"viper_viper_strike\",\n    \"special_bonus_unique_viper_4\": \"viper_poison_attack\",\n    \"special_bonus_unique_viper_3\": \"viper_nethertoxin\",\n    \"special_bonus_unique_visage_3\": \"visage_soul_assumption\",\n    \"special_bonus_unique_visage_4\": \"visage_soul_assumption\",\n    \"special_bonus_unique_visage_5\": \"visage_gravekeepers_cloak\",\n    \"special_bonus_unique_warlock_5\": \"warlock_fatal_bonds\",\n    \"special_bonus_unique_warlock_3\": \"warlock_shadow_word\",\n    \"special_bonus_unique_warlock_6\": \"warlock_shadow_word\",\n    \"special_bonus_unique_warlock_2\": \"warlock_rain_of_chaos\",\n    \"special_bonus_unique_warlock_1\": \"warlock_rain_of_chaos\",\n    \"special_bonus_unique_weaver_1\": \"weaver_shukuchi\",\n    \"special_bonus_unique_weaver_2\": \"weaver_shukuchi\",\n    \"special_bonus_unique_weaver_5\": \"weaver_geminate_attack\",\n    \"special_bonus_unique_windranger_2\": \"windrunner_windrun\",\n    \"special_bonus_unique_windranger_3\": \"windrunner_powershot\",\n    \"special_bonus_unique_windranger_5\": \"windrunner_shackleshot\",\n    \"special_bonus_unique_windranger\": \"windrunner_windrun\",\n    \"special_bonus_unique_windranger_4\": \"windrunner_focusfire\",\n    \"special_bonus_unique_winter_wyvern_1\": \"winter_wyvern_arctic_burn\",\n    \"special_bonus_unique_winter_wyvern_2\": \"winter_wyvern_cold_embrace\",\n    \"special_bonus_unique_winter_wyvern_3\": \"winter_wyvern_winters_curse\",\n    \"special_bonus_unique_winter_wyvern_4\": \"winter_wyvern_splinter_blast\",\n    \"special_bonus_unique_wisp_3\": \"wisp_spirits\",\n    \"special_bonus_unique_wisp\": \"wisp_spirits\",\n    \"special_bonus_unique_wisp_5\": \"wisp_tether\",\n    \"special_bonus_unique_wisp_4\": \"wisp_tether\",\n    \"special_bonus_unique_wisp_2\": \"wisp_tether\",\n    \"special_bonus_unique_witch_doctor_1\": \"witch_doctor_death_ward\",\n    \"special_bonus_unique_witch_doctor_4\": \"witch_doctor_maledict\",\n    \"special_bonus_unique_witch_doctor_2\": \"witch_doctor_voodoo_restoration\",\n    \"special_bonus_unique_witch_doctor_5\": \"witch_doctor_death_ward\",\n    \"special_bonus_unique_zeus\": \"zuus_static_field\",\n    \"special_bonus_unique_zeus_3\": \"zuus_lightning_bolt\",\n    \"special_bonus_unique_zeus_2\": \"zuus_arc_lightning\",\n    \n    \"special_bonus_unique_underlord_3\": \"abyssal_underlord_atrophy_aura\",\n    \"special_bonus_unique_beastmaster_2\": \"beastmaster_call_of_the_wild\",\n    \"special_bonus_unique_beastmaster_3\": \"beastmaster_call_of_the_wild\",\n    \"special_bonus_unique_bristleback\": \"bristleback_viscous_nasal_goo\",\n    \"special_bonus_unique_bristleback_2\": \"bristleback_quill_spray\",\n    \"special_bonus_unique_broodmother_3\": \"broodmother_spawn_spiderlings\",\n    //\"special_bonus_unique_broodmother_4\": \"+20 Spiders Attack Damage\",\n    //\"special_bonus_unique_broodmother_2\": \"+350 Spiders Health\",\n    //\"special_bonus_unique_chen_4\": \"+1000 Creep Min Health\",\n    \"special_bonus_unique_crystal_maiden_4\": \"crystal_maiden_brilliance_aura\",\n    \"special_bonus_unique_dark_seer_4\": \"dark_seer_wall_of_replica\",\n    \"special_bonus_unique_earthshaker_2\": \"earthshaker_echo_slam\",\n    \"special_bonus_unique_ember_spirit_5\": \"ember_spirit_fire_remnant\",\n    //\"special_bonus_unique_enigma_3\": \"+70 Eidolon Damage\",\n    \"special_bonus_unique_faceless_void\": \"faceless_void_time_walk\",\n    //\"special_bonus_unique_faceless_void_4\": \"+25% Backtrack\",\n    \"special_bonus_unique_furion_2\": \"furion_force_of_nature\",\n    //\"special_bonus_unique_furion\": \"2x Treant HP/Damage\",\n    \"special_bonus_unique_invoker_1\": \"invoker_forge_spirit\",\n    //\"special_bonus_unique_invoker_4\": \"Cataclysm\",\n    \"special_bonus_unique_kunkka_3\": \"kunkka_ghostship\",\n    \"special_bonus_unique_legion_commander_3\": \"legion_commander_moment_of_courage\",\n    //\"special_bonus_unique_lich_2\": \"Attacks Apply 30% MS and AS Slow\",\n    //\"special_bonus_unique_lone_druid_2\": \"+10 Spirit Bear Armor\",\n    //\"special_bonus_unique_lone_druid_9\": \"0 Entangle Cooldown\",\n    \"special_bonus_unique_lycan_3\": \"lycan_feral_impulse\",\n    \"special_bonus_unique_lycan_2\": \"lycan_summon_wolves\",\n    //\"special_bonus_unique_morphling_3\": \"+2 Multishot Adaptive Strike\",\n    \"special_bonus_unique_nevermore_3\": \"nevermore_dark_lord\",\n    \"special_bonus_unique_nevermore_1\": \"nevermore_necromastery\",\n    \"special_bonus_unique_night_stalker_2\": \"night_stalker_hunter_in_the_night\",\n    \"special_bonus_unique_pugna_4\": \"pugna_nether_blast\",\n    \"special_bonus_unique_pugna_3\": \"pugna_nether_ward\",\n    \"special_bonus_unique_queen_of_pain_2\": \"queenofpain_scream_of_pain\",\n    \"special_bonus_unique_riki_2\": \"riki_smoke_screen\",\n    \"special_bonus_unique_riki_1\": \"riki_permanent_invisibility\",\n    //\"special_bonus_unique_shadow_shaman_1\": \"+1 Serpent Wards Max HP\",\n    //\"special_bonus_unique_shadow_shaman_4\": \"+60 Wards Attack Damage\",\n    //\"special_bonus_unique_silencer_2\": \"+2 Intelligence Steal\",\n    \"special_bonus_unique_wraith_king_5\": \"skeleton_king_mortal_strike\",\n    //\"special_bonus_unique_wraith_king_6\": \"+30 Skeletons Attack Damage\",\n    \"special_bonus_unique_slardar_2\": \"slardar_bash\",\n    \"special_bonus_unique_slardar\": \"slardar_bash\",\n    \"special_bonus_unique_spirit_breaker_2\": \"spirit_breaker_charge_of_darkness\",\n    \"special_bonus_unique_techies\": \"techies_suicide\",\n    //\"special_bonus_unique_techies_4\": \"+25 Mines Movement Speed\",\n    \"special_bonus_unique_tinker_3\": \"tinker_heat_seeking_missile\",\n    //\"special_bonus_unique_treant_3\": \"3s Tree Respawn Time\",\n    //\"special_bonus_unique_troll_warlord_3\": \"+50 Whirling Axes Damage\",\n    //\"special_bonus_unique_troll_warlord\": \"-6s Whirling Axes Cooldown\",\n    \"special_bonus_unique_tusk\": \"tusk_walrus_punch\",\n    //\"special_bonus_unique_tusk_4\": \"12% Chance Walrus Punch\",\n    \"special_bonus_unique_venomancer_5\": \"venomancer_venomous_gale\",\n    //\"special_bonus_unique_visage_2\": \"+80 Familiars Movement Speed\",\n    \"special_bonus_unique_visage_6\": \"visage_summon_familiars\",\n    //\"special_bonus_unique_warlock_4\": \"Summons a Golem on death\",\n    \"special_bonus_unique_weaver_3\": \"weaver_the_swarm\",\n    \"special_bonus_unique_weaver_4\": \"weaver_the_swarm\",\n    \"special_bonus_unique_witch_doctor_3\": \"witch_doctor_paralyzing_cask\"\n}",
    "var totalExp = [0, 200, 500, 900, 1400, 2000, 2615, 3425, 3890, 4550, 5225, 6000, 7175, 8375, 9600, 10850, 12125, 13500, 14900, 16325, 17925, 19825, 22025, 24525, 27500];\n\nmodule.exports = totalExp;",
    "var abilityData = {\n    'alchemist_acid_spray': [\n        {\n            label: 'Duration',\n            controlType: 'input'\n        },\n        {\n            attributeName: 'damage',\n            label: 'Total Damage',\n            controlType: 'text',\n            fn: function (v, a, parent, index, abilityModel, ability, TalentController) {\n                return v*a;\n            }\n        },\n        {\n            attributeName: 'armor_reduction',\n            label: 'Total Damage',\n            controlType: 'text',\n            fn: function (v, a, parent, index, abilityModel, ability, TalentController) {\n                return -a;\n            },\n            returnProperty: 'armorReduction'\n        }\n    ],\n    'alchemist_unstable_concoction': [\n        {\n            label: 'Brew Time',\n            controlType: 'input'\n        },\n        {\n            attributeName: 'max_damage',\n            label: 'Total Damage',\n            controlType: 'text',\n            fn: function (v, a, parent, index, abilityModel, ability, TalentController) {\n                return v*a/5;\n            }\n        },\n        {\n            attributeName: 'max_stun',\n            label: 'Total Stun',\n            controlType: 'text',\n            fn: function (v, a, parent, index, abilityModel, ability, TalentController) {\n                return v*a/5;\n            }\n        }\n    ],\n    'ancient_apparition_cold_feet': [\n        {\n            label: 'Duration',\n            controlType: 'input'\n        },\n        {\n            attributeName: 'damage',\n            label: 'Total Damage',\n            controlType: 'text',\n            fn: function (v, a, parent, index, abilityModel, ability, TalentController) {\n                return v*a;\n            }\n        },\n        {\n            attributeName: 'stun_duration',\n            label: 'Total Stun',\n            controlType: 'text',\n            fn: function (v, a, parent, index, abilityModel, ability, TalentController) {\n                return a;\n            }\n        }\n    ],\n    'ancient_apparition_ice_blast': [\n        {\n            label: 'Duration',\n            controlType: 'input'\n        },\n        {\n            attributeName: 'dot_damage',\n            label: 'Total Damage',\n            controlType: 'text',\n            fn: function (v, a, parent, index, abilityModel, ability, TalentController) {\n                return abilityModel.getAbilityPropertyValue(ability, 'damage')+v*a;\n            }\n        }\n    ],\n    'antimage_mana_void': [\n        {\n            label: 'Enemy Missing Mana',\n            controlType: 'input'\n        },\n        {\n            attributeName: 'mana_void_damage_per_mana',\n            label: 'Total Damage',\n            controlType: 'text',\n            fn: function (v, a, parent, index, abilityModel, ability, TalentController) {\n                return v*a;\n            }\n        }\n    ],\n    'axe_battle_hunger': [\n        {\n            label: 'Battle Hungered Enemies',\n            controlType: 'input'\n        },\n        {\n            attributeName: 'speed_bonus',\n            label: 'Movement Speed Bonus',\n            controlType: 'text',\n            noLevel: true,\n            fn: function (v, a, parent, index, abilityModel, ability, TalentController) {\n                return v*a;\n            },\n            returnProperty: 'movementSpeedPct'\n        },\n        {\n            attributeName: 'slow',\n            label: 'Movement Speed Bonus',\n            controlType: 'text',\n            noLevel: true,\n            fn: function (v, a, parent, index, abilityModel, ability, TalentController) {\n                return a;\n            },\n            returnProperty: 'movementSpeedPctReduction'\n        }\n    ],\n    'bane_nightmare': [\n        {\n            label: 'Duration',\n            controlType: 'input'\n        },\n        {\n            label: 'DAMAGE:',\n            controlType: 'text',\n            fn: function (v, a, parent, index, abilityModel, ability, TalentController) {\n                return abilityModel.getAbilityPropertyValue(ability, 'damage')*v;\n            }\n        }\n    ],\n    'bane_fiends_grip': [\n        {\n            label: 'Duration',\n            controlType: 'input'\n        },\n        {\n            label: 'Enemy Max Mana',\n            controlType: 'input'\n        },\n        {\n            attributeName: 'fiend_grip_damage',\n            label: 'Total Damage',\n            controlType: 'text',\n            controls: [0,1],\n            fn: function (v, a, parent, index, abilityModel, ability, TalentController) {\n                if (parent.inventory.hasScepter()) {\n                    return v[0]*abilityModel.getAbilityAttributeValue(ability.attributes, 'fiend_grip_damage_scepter',ability.level());\n                }\n                else {\n                    return v[0]*a;\n                }\n            }\n        },\n        {\n            attributeName: 'fiend_grip_mana_drain',\n            label: 'Total Mana Drain',\n            controlType: 'text',\n            controls: [0,1],\n            noLevel: true,\n            fn: function (v, a, parent, index, abilityModel, ability, TalentController) {\n                if (parent.inventory.hasScepter()) {\n                    return v[0]*v[1]*abilityModel.getAbilityAttributeValue(ability.attributes, 'fiend_grip_mana_drain_scepter',ability.level())/100;\n                }\n                else {\n                    return v[0]*v[1]*a/100;\n                }\n            }\n        }\n    ],\n    'batrider_sticky_napalm': [\n        {\n            label: 'Stacks',\n            controlType: 'input'\n        },\n        {\n            attributeName: 'damage',\n            label: 'Total Bonus Damage',\n            controlType: 'text',\n            fn: function (v, a, parent, index, abilityModel, ability, TalentController) {\n                return v*a;\n            },\n            returnProperty: 'bonusDamage'\n        },\n        {\n            attributeName: 'movement_speed_pct',\n            label: 'Enemy Movement Speed Slow',\n            controlType: 'text',\n            fn: function (v, a, parent, index, abilityModel, ability, TalentController) {\n                return v*a;\n            },\n            returnProperty: 'movementSpeedPctReduction'\n        },\n        {\n            attributeName: 'turn_rate_pct',\n            label: 'Enemy Turn Rate Slow',\n            controlType: 'text',\n            fn: function (v, a, parent, index, abilityModel, ability, TalentController) {\n                return a;\n            },\n            returnProperty: 'turnRateReduction'\n        }\n    ],\n    'batrider_firefly': [\n        {\n            label: 'Duration',\n            controlType: 'input'\n        },\n        {\n            attributeName: 'damage_per_second',\n            label: 'Total Damage',\n            controlType: 'text',\n            fn: function (v, a, parent, index, abilityModel, ability, TalentController) {\n                return v*a;\n            }\n        }\n    ],\n    'bloodseeker_rupture': [\n        {\n            label: 'Enemy Distance Traveled',\n            controlType: 'input'\n        },\n        {\n            attributeName: 'movement_damage_pct',\n            label: 'DAMAGE:',\n            ignoreTooltip: true,\n            controlType: 'text',\n            fn: function (v, a, parent, index, abilityModel, ability, TalentController) {\n                return abilityModel.getAbilityPropertyValue(ability, 'damage') + v*a/100;\n            }\n        }\n    ],\n    'bristleback_viscous_nasal_goo': [\n        {\n            label: 'Stacks',\n            controlType: 'input'\n        },\n        {\n            attributeName: 'armor_per_stack',\n            label: 'Enemy Armor Reduction',\n            controlType: 'text',\n            fn: function (v, a, parent, index, abilityModel, ability, TalentController) {\n                return -v*a;\n            },\n            returnProperty: 'armorReduction'\n        },\n        {\n            attributeName: 'move_slow_per_stack',\n            label: '%SLOW:',\n            ignoreTooltip: true,\n            controlType: 'text',\n            fn: function (v, a, parent, index, abilityModel, ability, TalentController) {\n                return -(abilityModel.getAbilityAttributeValue(ability.attributes, 'base_move_slow',0)+v*a);\n            },\n            returnProperty: 'movementSpeedPctReduction'\n        }\n    ],\n    'bristleback_quill_spray': [\n        {\n            label: 'Stacks',\n            controlType: 'input'\n        },\n        {\n            attributeName: 'quill_stack_damage',\n            label: 'DAMAGE',\n            controlType: 'text',\n            fn: function (v, a, parent, index, abilityModel, ability, TalentController) {\n                var total = abilityModel.getAbilityAttributeValue(ability.attributes, 'quill_base_damage',ability.level())+v*a,\n                damage_cap = abilityModel.getAbilityAttributeValue(ability.attributes, 'max_damage',0);\n                if (total > damage_cap) {\n                    total = damage_cap;\n                }\n                return total;\n            }\n        }\n    ],\n    'bristleback_bristleback': [\n        {\n            label: 'Damage From',\n            controlType: 'radio',\n            controlValueType: 'string',\n            controlOptions: [\n                {text: 'Back', value: 'back'},\n                {text: 'Side', value: 'side'}\n            ]\n        },\n        {\n            attributeName: 'back_damage_reduction',\n            label: '%DAMAGE REDUCTION:',\n            ignoreTooltip: true,\n            controlType: 'text',\n            fn: function (v, a, parent, index, abilityModel, ability, TalentController) {\n                var ability = abilityModel.abilities().find(function(b) {\n                    return b.name == 'bristleback_bristleback';\n                });\n                if (v == 'back') {\n                    var total = abilityModel.getAbilityAttributeValue(ability.attributes, 'back_damage_reduction', ability.level());\n                }\n                else {\n                    var total = abilityModel.getAbilityAttributeValue(ability.attributes, 'side_damage_reduction', ability.level());\n                }\n                return -total;\n            },\n            returnProperty: 'damageReduction'\n        }\n    ],\n    'bristleback_warpath': [\n        {\n            label: 'Stacks',\n            controlType: 'input'\n        },\n        {\n            attributeName: 'damage_per_stack',\n            label: 'BONUS DAMAGE:',\n            ignoreTooltip: true,\n            controlType: 'text',\n            fn: function (v, a, parent, index, abilityModel, ability, TalentController) {\n                if (v < 1) {\n                    return 0;\n                }\n                else {\n                    return abilityModel.getAbilityAttributeValue(ability.attributes, 'base_damage',ability.level())+(v-1)*a;\n                }\n            }\n        },\n        {\n            attributeName: 'move_speed_per_stack',\n            label: '%MOVEMENT:',\n            ignoreTooltip: true,\n            controlType: 'text',\n            fn: function (v, a, parent, index, abilityModel, ability, TalentController) {\n                if (v < 1) {\n                    return 0;\n                }\n                else {\n                    return abilityModel.getAbilityAttributeValue(ability.attributes, 'base_move_speed',ability.level())+(v-1)*a;\n                }\n            },\n            returnProperty: 'movementSpeedPct'\n        }\n    ],\n    'centaur_return': [\n        {\n            label: 'Strength',\n            controlType: 'input'\n        },\n        {\n            attributeName: 'strength_pct',\n            label: 'DAMAGE:',\n            controlType: 'text',\n            fn: function (v, a, parent, index, abilityModel, ability, TalentController) {\n                return abilityModel.getAbilityAttributeValue(ability.attributes, 'return_damage',ability.level()) + v*a/100;\n            }\n        }\n    ],\n    'centaur_stampede': [\n        {\n            label: 'Strength',\n            controlType: 'input'\n        },\n        {\n            attributeName: 'strength_damage',\n            label: 'DAMAGE:',\n            ignoreTooltip: true,\n            controlType: 'text',\n            fn: function (v, a, parent, index, abilityModel, ability, TalentController) {\n                return v*a;\n            }\n        },\n        {\n            attributeName: 'slow_movement_speed',\n            label: 'Enemy Movement Speed Slow',\n            controlType: 'text',\n            fn: function (v, a, parent, index, abilityModel, ability, TalentController) {\n                return -a;\n            },\n            returnProperty: 'movementSpeedPctReduction'\n        }\n    ],\n    'clinkz_death_pact': [\n        {\n            label: 'Consumed Unit HP',\n            controlType: 'input'\n        },\n        {\n            attributeName: 'damage_gain_pct',\n            label: 'BASE DAMAGE GAIN:',\n            ignoreTooltip: true,\n            controlType: 'text',\n            fn: function (v, a, parent, index, abilityModel, ability, TalentController) {\n                return v*a/100;\n            },\n            returnProperty: 'baseDamage'\n        },\n        {\n            attributeName: 'health_gain_pct',\n            label: 'HEALTH GAIN:',\n            ignoreTooltip: true,\n            controlType: 'text',\n            fn: function (v, a, parent, index, abilityModel, ability, TalentController) {\n                return v*a/100;\n            },\n            returnProperty: 'bonusHealth'\n        }\n    ],\n    'crystal_maiden_frostbite': [\n        {\n            label: 'Duration',\n            controlType: 'input'\n        },\n        {\n            label: 'DAMAGE:',\n            controlType: 'text',\n            fn: function (v, a, parent, index, abilityModel, ability, TalentController) {\n                return abilityModel.getAbilityPropertyValue(ability, 'damage')*v;\n            }\n        }\n    ],\n    'dark_seer_ion_shell': [\n        {\n            label: 'Duration',\n            controlType: 'input'\n        },\n        {\n            attributeName: 'damage_per_second',\n            label: 'Total Damage',\n            controlType: 'text',\n            fn: function (v, a, parent, index, abilityModel, ability, TalentController) {\n                return v*a;\n            }\n        }\n    ],\n    'dazzle_shadow_wave': [\n        {\n            label: 'Targets',\n            controlType: 'input'\n        },\n        {\n            label: 'DAMAGE:',\n            controlType: 'text',\n            fn: function (v, a, parent, index, abilityModel, ability, TalentController) {\n                return abilityModel.getAbilityPropertyValue(ability, 'damage')*v;\n            }\n        }\n    ],\n    'dazzle_weave': [\n        {\n            label: 'Duration',\n            controlType: 'input'\n        },\n        {\n            attributeName: 'armor_per_second',\n            label: 'ARMOR',\n            ignoreTooltip: true,\n            controlType: 'text',\n            fn: function (v, a, parent, index, abilityModel, ability, TalentController) {\n                return v*a;\n            },\n            returnProperty: 'armor'\n        },\n        {\n            attributeName: 'armor_per_second',\n            label: 'ARMOR REDUCTION:',\n            ignoreTooltip: true,\n            controlType: 'text',\n            fn: function (v, a, parent, index, abilityModel, ability, TalentController) {\n                return -v*a;\n            },\n            returnProperty: 'armorReduction'\n        }\n    ],\n    'death_prophet_exorcism': [\n        {\n            label: 'Damage Dealt',\n            controlType: 'input'\n        },\n        {\n            attributeName: 'heal_percent',\n            label: 'Total Armor',\n            controlType: 'text',\n            fn: function (v, a, parent, index, abilityModel, ability, TalentController) {\n                return v*a/100;\n            }\n        }\n    ],\n    'disruptor_static_storm': [\n        {\n            label: 'Duration',\n            controlType: 'input'\n        },\n        {\n            label: 'DAMAGE:',\n            controlType: 'text',\n            fn: function (v, a, parent, index, abilityModel, ability, TalentController) {\n                var damagevalue = 0.25 * (130 + 40 * ability.level()) * (1/20),\n                mult = (v*4)*((v*4)+1)/2;\n                return damagevalue * mult;\n            }\n        }\n    ],\n    'doom_bringer_scorched_earth': [\n        {\n            label: 'Duration',\n            controlType: 'input'\n        },\n        {\n            attributeName: 'damage_per_second',\n            label: 'Total Damage',\n            controlType: 'text',\n            fn: function (v, a, parent, index, abilityModel, ability, TalentController) {\n                return v*a;\n            }\n        },\n        {\n            attributeName: 'bonus_movement_speed_pct',\n            label: 'Total Damage',\n            controlType: 'text',\n            fn: function (v, a, parent, index, abilityModel, ability, TalentController) {\n                return a;\n            },\n            returnProperty: 'movementSpeedPct'\n        },\n        {\n            attributeName: 'damage_per_second',\n            label: 'HP REGEN:',\n            ignoreTooltip: true,\n            controlType: 'text',\n            fn: function (v, a, parent, index, abilityModel, ability, TalentController) {\n                return a;\n            },\n            returnProperty: 'healthregen'\n        }\n    ],\n    'doom_bringer_doom': [\n        {\n            label: 'Duration',\n            controlType: 'input'\n        },\n        {\n            attributeName: 'damage',\n            label: 'Total Damage',\n            controlType: 'text',\n            fn: function (v, a, parent, index, abilityModel, ability, TalentController) {\n                if (parent.inventory.hasScepter()) {\n                    return v*abilityModel.getAbilityAttributeValue(ability.attributes, 'damage_scepter',ability.level());\n                }\n                else {\n                    return v*a;\n                }\n            }\n        }\n    ],\n    'dragon_knight_elder_dragon_form': [\n        {\n            label: 'Duration',\n            controlType: 'input'\n        },\n        {\n            attributeName: 'bonus_attack_range',\n            label: 'Total Damage',\n            controlType: 'text',\n            fn: function (v, a, parent, index, abilityModel, ability, TalentController) {\n                return a;\n            },\n            returnProperty: 'attackrange'\n        },\n        {\n            attributeName: 'bonus_movement_speed',\n            label: 'Total Damage',\n            controlType: 'text',\n            fn: function (v, a, parent, index, abilityModel, ability, TalentController) {\n                return a;\n            },\n            returnProperty: 'movementSpeedFlat'\n        }\n    ],\n    'drow_ranger_trueshot': [\n        {\n            label: 'Drow\\'s Agility',\n            controlType: 'input',\n            display: 'buff'\n        },\n        {\n            attributeName: 'trueshot_ranged_damage',\n            label: 'DAMAGE BONUS:',\n            ignoreTooltip: true,\n            controlType: 'text',\n            display: 'buff',\n            fn: function (v, a, parent, index, abilityModel, ability, TalentController) {\n                return v*a/100;\n            },\n            returnProperty: 'bonusDamagePrecisionAura'\n        }\n    ],\n    'earth_spirit_rolling_boulder': [\n        {\n            label: 'Using Stone',\n            controlType: 'checkbox'\n        },\n        {\n            attributeName: 'move_slow',\n            label: 'Total Damage',\n            controlType: 'text',\n            fn: function (v, a, parent, index, abilityModel, ability, TalentController) {\n                if (v) {\n                    return -a;\n                }\n                else {\n                    return 0;\n                }\n            },\n            returnProperty: 'movementSpeedPctReduction'\n        }\n    ],\n    'earthshaker_enchant_totem': [\n        {\n            label: 'Activated',\n            controlType: 'checkbox'\n        },\n        {\n            attributeName: 'totem_damage_percentage',\n            label: 'DAMAGE',\n            controlType: 'text',\n            fn: function (v, a, parent, index, abilityModel, ability, TalentController) {\n                if (v) {\n                    return a;\n                }\n                else {\n                    return 0;\n                }\n            },\n            returnProperty: 'baseDamageMultiplier'\n        }\n    ],\n    'earthshaker_echo_slam': [\n        {\n            label: 'Enemies in Range',\n            controlType: 'input'\n        },\n        {\n            attributeName: 'echo_slam_echo_damage',\n            label: 'Total Damage',\n            controlType: 'text',\n            fn: function (v, a, parent, index, abilityModel, ability, TalentController) {\n                return v*a;\n            }\n        }\n    ],\n    'elder_titan_ancestral_spirit': [\n        {\n            label: 'HEROES PASSED THROUGH',\n            controlType: 'input'\n        },\n        {\n            label: 'CREEPS PASSED THROUGH',\n            controlType: 'input'\n        },\n        {\n            attributeName: 'damage_creeps',\n            label: 'DAMAGE:',\n            ignoreTooltip: true,\n            controlType: 'text',\n            controls: [0,1],\n            fn: function (v, a, parent, index, abilityModel, ability, TalentController) {\n                return v[0]*abilityModel.getAbilityAttributeValue(ability.attributes, 'damage_heroes',ability.level()) + v[1]*a;\n            },\n            returnProperty: 'bonusDamage'\n        },\n        {\n            attributeName: 'move_pct_creeps',\n            label: '%BONUS SPEED:',\n            ignoreTooltip: true,\n            controlType: 'text',\n            controls: [0,1],\n            fn: function (v, a, parent, index, abilityModel, ability, TalentController) {\n                return v[0]*abilityModel.getAbilityAttributeValue(ability.attributes, 'move_pct_heroes',ability.level()) + v[1]*a;\n            },\n            returnProperty: 'movementSpeedPct'\n        }\n    ],\n    'elder_titan_earth_splitter': [\n        {\n            label: 'Enemy Max Health',\n            controlType: 'input'\n        },\n        {\n            attributeName: 'damage_pct',\n            label: 'Total Damage',\n            controlType: 'text',\n            fn: function (v, a, parent, index, abilityModel, ability, TalentController) {\n                return v*a/100;\n            }\n        },\n        {\n            attributeName: 'slow_pct',\n            label: 'Total Damage',\n            controlType: 'text',\n            fn: function (v, a, parent, index, abilityModel, ability, TalentController) {\n                return -a;\n            },\n            returnProperty: 'movementSpeedPctReduction'\n        }\n    ],\n    'enchantress_natures_attendants': [\n        {\n            label: 'Duration',\n            controlType: 'input'\n        },\n        {\n            attributeName: 'heal',\n            label: 'HEAL:',\n            ignoreTooltip: true,\n            controlType: 'text',\n            fn: function (v, a, parent, index, abilityModel, ability, TalentController) {\n                return abilityModel.getAbilityAttributeValue(ability.attributes, 'wisp_count',ability.level())*v*a;\n            }\n        }\n    ],\n    'enigma_malefice': [\n        {\n            label: 'Hits',\n            controlType: 'input'\n        },\n        {\n            attributeName: 'damage',\n            label: 'DAMAGE:',\n            ignoreTooltip: true,\n            controlType: 'text',\n            fn: function (v, a, parent, index, abilityModel, ability, TalentController) {\n                return v*a;\n            }\n        },\n        {\n            attributeName: 'stun_duration',\n            label: 'Total Damage',\n            controlType: 'text',\n            fn: function (v, a, parent, index, abilityModel, ability, TalentController) {\n                return v*a;\n            }\n        }\n    ],\n    'enigma_midnight_pulse': [\n        {\n            label: 'Duration',\n            controlType: 'input'\n        },\n        {\n            label: 'Enemy Max Health',\n            controlType: 'input'\n        },\n        {\n            attributeName: 'damage_percent',\n            label: 'DAMAGE:',\n            ignoreTooltip: true,\n            controlType: 'text',\n            controls: [0,1],\n            fn: function (v, a, parent, index, abilityModel, ability, TalentController) {\n                return v[0]*v[1]*a/100;\n            }\n        }\n    ],\n    'enigma_black_hole': [\n        {\n            label: 'Duration',\n            controlType: 'input'\n        },\n        {\n            attributeName: 'far_damage',\n            label: 'Total Damage',\n            controlType: 'text',\n            fn: function (v, a, parent, index, abilityModel, ability, TalentController) {\n                return v*a;\n            }\n        },\n        {\n            attributeName: 'near_damage',\n            label: 'Total Damage',\n            controlType: 'text',\n            fn: function (v, a, parent, index, abilityModel, ability, TalentController) {\n                return v*a;\n            }\n        }\n    ],\n    'faceless_void_time_lock': [\n        {\n            attributeName: 'bonus_damage',\n            label: '%MOVESPEED AS DAMAGE',\n            controlType: 'text',\n            fn: function (v, a, parent, index, abilityModel, ability, TalentController) {\n                return a;\n            },\n            returnProperty: 'bashBonusDamage'\n        },\n        {\n            attributeName: 'duration',\n            label: 'Total Damage',\n            controlType: 'text',\n            fn: function (v, a, parent, index, abilityModel, ability, TalentController) {\n                return a;\n            }\n        },\n        {\n            attributeName: 'chance_pct',\n            label: 'Total Damage',\n            controlType: 'text',\n            fn: function (v, a, parent, index, abilityModel, ability, TalentController) {\n                return a;\n            },\n            returnProperty: 'bash'\n        }\n    ],\n    'gyrocopter_rocket_barrage': [\n        {\n            label: 'Rockets',\n            controlType: 'input'\n        },\n        {\n            attributeName: 'rockets_per_second',\n            label: 'Total Damage',\n            controlType: 'text',\n            fn: function (v, a, parent, index, abilityModel, ability, TalentController) {\n                return a;\n            }\n        },\n        {\n            label: 'DAMAGE:',\n            controlType: 'text',\n            fn: function (v, a, parent, index, abilityModel, ability, TalentController) {\n                return abilityModel.getAbilityPropertyValue(ability, 'damage')*v;\n            }\n        }\n    ],\n/*        'gyrocopter_homing_missile': [\n        {\n            label: 'Distance Traveled',\n            controlType: 'input'\n        },\n        {\n            attributeName: 'damage',\n            label: 'Total Damage',\n            controlType: 'text',\n            fn: function (v, a, parent, index, abilityModel, ability, TalentController) {\n                return v*a;\n            }\n        }\n    ],\n    'gyrocopter_flak_cannon': [\n        {\n            label: 'Attacks',\n            controlType: 'input'\n        },\n        {\n            attributeName: 'damage',\n            label: 'Total Damage',\n            controlType: 'text',\n            fn: function (v, a, parent, index, abilityModel, ability, TalentController) {\n                return v*a;\n            }\n        }\n    ],*/\n    'huskar_burning_spear': [\n        {\n            label: 'Stacks',\n            controlType: 'input'\n        },\n        {\n            attributeName: 'health_cost',\n            label: 'Total Damage',\n            controlType: 'text',\n            fn: function (v, a, parent, index, abilityModel, ability, TalentController) {\n                return v*a;\n            }\n        },\n        {\n            label: 'DAMAGE:',\n            controlType: 'text',\n            fn: function (v, a, parent, index, abilityModel, ability, TalentController) {\n                return abilityModel.getAbilityPropertyValue(ability, 'damage')*v;\n            }\n        }\n    ],\n    'huskar_berserkers_blood': [\n        {\n            label: '%HP',\n            controlType: 'input'\n        },\n        {\n            attributeName: 'hp_threshold_max',\n            label: 'Health at given %HP:',\n            ignoreTooltip: true,\n            controlType: 'text',\n            fn: function (v, a, parent, index, abilityModel, ability, TalentController) {\n                return parent.health().total*v/100;\n            }\n        },\n        {\n            attributeName: 'hp_threshold_max',\n            label: 'Total Damage',\n            controlType: 'text',\n            fn: function (v, a, parent, index, abilityModel, ability, TalentController) {\n                return a;\n            }\n        },\n        {\n            attributeName: 'maximum_resistance',\n            label: 'MAGIC RESISTANCE BONUS:',\n            ignoreTooltip: true,\n            controlType: 'text',\n            fn: function (v, a, parent, index, abilityModel, ability, TalentController) {\n                var v = Math.min(v, 100);\n                v = Math.max(v, 10);\n                var hp_threshold_max = abilityModel.getAbilityAttributeValue(ability.attributes, 'hp_threshold_max',0);\n                var d = 100 - hp_threshold_max;\n                var c = (v - hp_threshold_max) / d;\n                c = 1 - c;\n                return c*a;\n            },\n            returnProperty: 'magicResist'\n        },\n        {\n            attributeName: 'maximum_attack_speed',\n            label: 'ATTACK SPEED BONUS:',\n            ignoreTooltip: true,\n            controlType: 'text',\n            fn: function (v, a, parent, index, abilityModel, ability, TalentController) {\n                var v = Math.min(v, 100);\n                v = Math.max(v, 10);\n                var hp_threshold_max = abilityModel.getAbilityAttributeValue(ability.attributes, 'hp_threshold_max',0);\n                var d = 100 - hp_threshold_max;\n                var c = (v - hp_threshold_max) / d;\n                c = 1 - c;\n                return c*a;\n            },\n            returnProperty: 'attackspeed'\n        }\n    ],\n    'huskar_life_break': [\n        {\n            label: 'Enemy Current HP',\n            controlType: 'input'\n        },\n        {\n            attributeName: 'health_damage',\n            label: 'DAMAGE:',\n            ignoreTooltip: true,\n            controlType: 'text',\n            fn: function (v, a, parent, index, abilityModel, ability, TalentController) {\n                return v*a;\n            }\n        },\n        {\n            label: 'Huskar Current HP',\n            controlType: 'input'\n        },\n        {\n            attributeName: 'health_cost_percent',\n            label: 'DAMAGE TAKEN:',\n            ignoreTooltip: true,\n            controlType: 'text',\n            fn: function (v, a, parent, index, abilityModel, ability, TalentController) {\n                return v*a;\n            }\n        },\n        {\n            attributeName: 'movespeed',\n            label: 'Total Damage',\n            controlType: 'text',\n            fn: function (v, a, parent, index, abilityModel, ability, TalentController) {\n                return a;\n            },\n            returnProperty: 'movementSpeedPctReduction'\n        }\n    ],\n    'invoker_quas': [\n        {\n            label: 'Instances',\n            controlType: 'input'\n        },\n        /*{\n            attributeName: 'bonus_strength',\n            label: 'Total Damage',\n            controlType: 'text',\n            fn: function (v, a, parent, index, abilityModel, ability, TalentController) {\n                return a;\n            },\n            returnProperty: 'bonusStrength'\n        },*/\n        {\n            attributeName: 'health_regen_per_instance',\n            label: 'HP REGEN:',\n            ignoreTooltip: true,\n            controlType: 'text',\n            fn: function (v, a, parent, index, abilityModel, ability, TalentController) {\n                return v*a;\n            },\n            returnProperty: 'healthregen'\n        }\n    ],\n    'invoker_wex': [\n        {\n            label: 'Instances',\n            controlType: 'input'\n        },\n        /*{\n            attributeName: 'bonus_agility',\n            label: 'Total Damage',\n            controlType: 'text',\n            fn: function (v, a, parent, index, abilityModel, ability, TalentController) {\n                return a;\n            },\n            returnProperty: 'bonusAgility'\n        },*/\n        {\n            attributeName: 'move_speed_per_instance',\n            label: '%MOVE SPEED:',\n            ignoreTooltip: true,\n            controlType: 'text',\n            fn: function (v, a, parent, index, abilityModel, ability, TalentController) {\n                return v*a;\n            },\n            returnProperty: 'movementSpeedPct'\n        },\n        {\n            attributeName: 'attack_speed_per_instance',\n            label: '%ATTACK SPEED:',\n            ignoreTooltip: true,\n            controlType: 'text',\n            fn: function (v, a, parent, index, abilityModel, ability, TalentController) {\n                return v*a;\n            },\n            returnProperty: 'attackspeed'\n        }\n    ],\n    'invoker_exort': [\n        {\n            label: 'Instances',\n            controlType: 'input'\n        },\n        /*{\n            attributeName: 'bonus_intelligence',\n            label: 'Total Damage',\n            controlType: 'text',\n            fn: function (v, a, parent, index, abilityModel, ability, TalentController) {\n                return a;\n            },\n            returnProperty: 'bonusInt'\n        },*/\n        {\n            attributeName: 'bonus_damage_per_instance',\n            label: 'DAMAGE:',\n            ignoreTooltip: true,\n            controlType: 'text',\n            fn: function (v, a, parent, index, abilityModel, ability, TalentController) {\n                return v*a;\n            },\n            returnProperty: 'bonusDamage'\n        }\n    ],\n    'invoker_ghost_walk': [\n        {\n            label: 'Quas Level',\n            controlType: 'input'\n        },\n        {\n            attributeName: 'enemy_slow',\n            label: 'Total Damage',\n            controlType: 'text',\n            fn: function (v, a, parent, index, abilityModel, ability, TalentController) {\n                if (v == 0) {\n                    return 0;\n                }\n                return abilityModel.getAbilityAttributeValue(ability.attributes, 'enemy_slow',v);\n            },\n            returnProperty: 'movementSpeedPctReduction'\n        },\n        {\n            label: 'Wex Level',\n            controlType: 'input',\n            display: 'ability'\n        },\n        {\n            attributeName: 'self_slow',\n            label: 'Total Damage',\n            controlType: 'text',\n            display: 'ability',\n            fn: function (v, a, parent, index, abilityModel, ability, TalentController) {\n                if (v == 0) {\n                    return 0;\n                }\n                return abilityModel.getAbilityAttributeValue(ability.attributes, 'self_slow',v);\n            },\n            returnProperty: 'movementSpeedPct'\n        }\n    ],\n    'invoker_alacrity': [\n        {\n            label: 'Wex Level',\n            controlType: 'input'\n        },\n        {\n            attributeName: 'bonus_attack_speed',\n            label: 'Total Damage',\n            controlType: 'text',\n            fn: function (v, a, parent, index, abilityModel, ability, TalentController) {\n                if (v == 0) {\n                    return 0;\n                }\n                return abilityModel.getAbilityAttributeValue(ability.attributes, 'bonus_attack_speed',v);\n            },\n            returnProperty: 'attackspeed'\n        },\n        {\n            label: 'Exort Level',\n            controlType: 'input',\n        },\n        {\n            attributeName: 'bonus_damage',\n            label: 'Total Damage',\n            controlType: 'text',\n            fn: function (v, a, parent, index, abilityModel, ability, TalentController) {\n                if (v == 0) {\n                    return 0;\n                }\n                return abilityModel.getAbilityAttributeValue(ability.attributes, 'bonus_damage',v);\n            },\n            returnProperty: 'bonusDamage'\n        }\n    ],\n    'invoker_ice_wall': [\n        {\n            label: 'Quas Level',\n            controlType: 'input'\n        },\n        {\n            attributeName: 'slow',\n            label: 'Total Damage',\n            controlType: 'text',\n            fn: function (v, a, parent, index, abilityModel, ability, TalentController) {\n                if (v == 0) {\n                    return 0;\n                }\n                return abilityModel.getAbilityAttributeValue(ability.attributes, 'slow',v);\n            },\n            returnProperty: 'movementSpeedPctReduction'\n        },\n        {\n            label: 'Exort Level',\n            controlType: 'input',\n            display: 'ability'\n        },\n        {\n            label: 'Duration',\n            controlType: 'input',\n            display: 'ability'\n        },\n        {\n            attributeName: 'damage_per_second',\n            label: 'DAMAGE:',\n            ignoreTooltip: true,\n            controlType: 'text',\n            display: 'ability',\n            controls: [1,2],\n            fn: function (v, a, parent, index, abilityModel, ability, TalentController) {\n                if (v[0] == 0) {\n                    return 0;\n                }\n                return abilityModel.getAbilityAttributeValue(ability.attributes, 'damage_per_second',v[0])*v[1];\n            }\n        }\n    ],\n    'jakiro_dual_breath': [\n        {\n            label: 'Duration',\n            controlType: 'input'\n        },\n        {\n            label: 'DAMAGE:',\n            controlType: 'text',\n            fn: function (v, a, parent, index, abilityModel, ability, TalentController) {\n                return abilityModel.getAbilityPropertyValue(ability, 'damage')*2 + \n                abilityModel.getAbilityAttributeValue(ability.attributes, 'burn_damage',ability.level())*v;\n            }\n        },\n        {\n            attributeName: 'slow_movement_speed_pct',\n            label: 'Total Damage',\n            controlType: 'text',\n            fn: function (v, a, parent, index, abilityModel, ability, TalentController) {\n                return a;\n            },\n            returnProperty: 'movementSpeedPctReduction'\n        },\n        {\n            attributeName: 'slow_attack_speed_pct',\n            label: '%ATTACK SLOW:',\n            ignoreTooltip: true,\n            controlType: 'text',\n            fn: function (v, a, parent, index, abilityModel, ability, TalentController) {\n                return a;\n            },\n            returnProperty: 'attackspeedreduction'\n        }\n    ],\n    'jakiro_liquid_fire': [\n        {\n            label: 'Duration',\n            controlType: 'input'\n        },\n        {\n            attributeName: 'damage',\n            label: 'Total Damage',\n            controlType: 'text',\n            fn: function (v, a, parent, index, abilityModel, ability, TalentController) {\n                return v*a;\n            }\n        },\n        {\n            attributeName: 'slow_attack_speed_pct',\n            label: 'Total Damage',\n            controlType: 'text',\n            fn: function (v, a, parent, index, abilityModel, ability, TalentController) {\n                return a;\n            },\n            returnProperty: 'attackspeedreduction'\n        }\n    ],\n    'jakiro_macropyre': [\n        {\n            label: 'Duration',\n            controlType: 'input'\n        },\n        {\n            attributeName: 'damage',\n            label: 'Total Damage',\n            controlType: 'text',\n            fn: function (v, a, parent, index, abilityModel, ability, TalentController) {\n                return v*a;\n            }\n        }\n    ],\n    'juggernaut_blade_fury': [\n        {\n            label: 'Duration',\n            controlType: 'input'\n        },\n        {\n            label: 'DAMAGE:',\n            controlType: 'text',\n            fn: function (v, a, parent, index, abilityModel, ability, TalentController) {\n                return abilityModel.getAbilityPropertyValue(ability, 'damage')*v;\n            }\n        }\n    ],\n    'juggernaut_healing_ward': [\n        {\n            label: 'Duration',\n            controlType: 'input'\n        },\n        {\n            label: 'Max Health',\n            controlType: 'input'\n        },\n        {\n            attributeName: 'healing_ward_heal_amount',\n            label: 'HEAL OVER TIME:',\n            ignoreTooltip: true,\n            controlType: 'text',\n            controls: [0,1],\n            fn: function (v, a, parent, index, abilityModel, ability, TalentController) {\n                return v[0]*v[1]*a/100;\n            }\n        }\n    ],\n    'juggernaut_omni_slash': [\n        {\n            label: 'Jumps',\n            controlType: 'input'\n        },\n        {\n            label: 'MIN DAMAGE:',\n            ignoreTooltip: true,\n            controlType: 'text',\n            fn: function (v, a, parent, index, abilityModel, ability, TalentController) {\n                return abilityModel.getAbilityAttributeValue(ability.attributes, 'omni_slash_damage',1)*v;\n            }\n        },\n        {\n            label: 'MAX DAMAGE:',\n            ignoreTooltip: true,\n            controlType: 'text',\n            fn: function (v, a, parent, index, abilityModel, ability, TalentController) {\n                return abilityModel.getAbilityAttributeValue(ability.attributes, 'omni_slash_damage',2)*v;\n            }\n        }\n    ],\n    'keeper_of_the_light_illuminate': [\n        {\n            label: 'Duration',\n            controlType: 'input'\n        },\n        {\n            attributeName: 'damage_per_second',\n            label: 'DAMAGE:',\n            ignoreTooltip: true,\n            controlType: 'text',\n            fn: function (v, a, parent, index, abilityModel, ability, TalentController) {\n                return v*a;\n            }\n        }\n    ],\n    'keeper_of_the_light_mana_leak': [\n        {\n            label: 'Distance Moved',\n            controlType: 'input'\n        },\n        {\n            label: 'Enemy Max Mana',\n            controlType: 'input'\n        },\n        {\n            attributeName: 'mana_leak_pct',\n            label: 'MANA LEAKED:',\n            ignoreTooltip: true,\n            controlType: 'text',\n            controls: [0,1],\n            fn: function (v, a, parent, index, abilityModel, ability, TalentController) {\n                return v[0]/100*v[1]*a/100;\n            }\n        }\n    ],\n    'legion_commander_duel': [\n        {\n            label: 'Duel Wins',\n            controlType: 'input'\n        },\n        {\n            attributeName: 'reward_damage',\n            label: 'Total Damage:',\n            ignoreTooltip: true,\n            controlType: 'text',\n            fn: function (v, a, parent, index, abilityModel, ability, TalentController) {\n                return v*a;\n            },\n            returnProperty: 'bonusDamage'\n        }\n    ],\n    'leshrac_pulse_nova': [\n        {\n            label: 'Duration',\n            controlType: 'input'\n        },\n        {\n            attributeName: 'damage',\n            label: 'Total Damage',\n            controlType: 'text',\n            fn: function (v, a, parent, index, abilityModel, ability, TalentController) {\n                return v*a;\n            }\n        },\n        {\n            attributeName: 'mana_cost_per_second',\n            label: 'MANA COST:',\n            ignoreTooltip: true,\n            controlType: 'text',\n            fn: function (v, a, parent, index, abilityModel, ability, TalentController) {\n                return v*a;\n            }\n        }\n    ],\n    'lich_chain_frost': [\n        {\n            label: 'Bounce Hits',\n            controlType: 'input'\n        },\n        {\n            attributeName: 'damage',\n            label: 'Total Damage',\n            controlType: 'text',\n            fn: function (v, a, parent, index, abilityModel, ability, TalentController) {\n                return v*a;\n            }\n        },\n        {\n            attributeName: 'slow_movement_speed',\n            label: 'Enemy Movement Speed Slow',\n            controlType: 'text',\n            fn: function (v, a, parent, index, abilityModel, ability, TalentController) {\n                return a;\n            },\n            returnProperty: 'movementSpeedPctReduction'\n        },\n        {\n            attributeName: 'slow_attack_speed',\n            label: 'Total Damage',\n            controlType: 'text',\n            fn: function (v, a, parent, index, abilityModel, ability, TalentController) {\n                return a;\n            },\n            returnProperty: 'attackspeedreduction'\n        }\n    ],\n    'life_stealer_feast': [\n        {\n            label: 'Enemy Current HP',\n            controlType: 'input'\n        },\n        {\n            attributeName: 'hp_leech_percent',\n            label: 'Total Damage',\n            controlType: 'text',\n            fn: function (v, a, parent, index, abilityModel, ability, TalentController) {\n                return v*a/100;\n            },\n            returnProperty: 'bonusDamage'\n        }\n    ],\n    'life_stealer_open_wounds': [\n        {\n            label: 'Duration',\n            controlType: 'input'\n        },\n        {\n            attributeName: 'heal_percent',\n            label: 'Total Damage',\n            controlType: 'text',\n            fn: function (v, a, parent, index, abilityModel, ability, TalentController) {\n                return a;\n            },\n            returnProperty: 'lifesteal'\n        },\n        {\n            attributeName: 'slow_steps',\n            label: '%SLOW:',\n            ignoreTooltip: true,\n            controlType: 'text',\n            noLevel: true,\n            fn: function (v, a, parent, index, abilityModel, ability, TalentController) {\n                return abilityModel.getAbilityAttributeValue(ability.attributes, 'slow_steps',v+1);\n            },\n            returnProperty: 'movementSpeedPctReduction'\n        }\n    ],\n    'lina_fiery_soul': [\n        {\n            label: 'Duration',\n            controlType: 'input'\n        },\n        {\n            attributeName: 'fiery_soul_move_speed_bonus',\n            label: 'Enemy Movement Speed Slow',\n            controlType: 'text',\n            fn: function (v, a, parent, index, abilityModel, ability, TalentController) {\n                return v*a;\n            },\n            returnProperty: 'movementSpeedPct'\n        },\n        {\n            attributeName: 'fiery_soul_attack_speed_bonus',\n            label: 'Total Damage',\n            controlType: 'text',\n            fn: function (v, a, parent, index, abilityModel, ability, TalentController) {\n                return v*a;\n            },\n            returnProperty: 'attackspeed'\n        }\n    ],\n    'lion_mana_drain': [\n        {\n            label: 'Duration',\n            controlType: 'input'\n        },\n        {\n            attributeName: 'mana_per_second',\n            label: 'MANA DRAINED:',\n            ignoreTooltip: true,\n            controlType: 'text',\n            fn: function (v, a, parent, index, abilityModel, ability, TalentController) {\n                return v*a;\n            }\n        }\n    ],\n    'luna_moon_glaive': [\n        {\n            label: 'Damage',\n            controlType: 'input'\n        },\n        {\n            attributeName: 'damage_reduction_percent',\n            label: 'BOUNCE DAMAGE:',\n            ignoreTooltip: true,\n            controlType: 'text',\n            fn: function (v, a, parent, index, abilityModel, ability, TalentController) {\n                var result = [];\n                for (var i = 1; i < 6; i++) {\n                    result.push((v*Math.pow(a/100,i)).toFixed(2))\n                }\n                return result.join('<br>');\n            }\n        }\n    ],\n    'luna_eclipse': [\n        {\n            label: 'Beam Count',\n            controlType: 'input'\n        },\n        {\n            attributeName: 'beams',\n            label: 'Total Damage',\n            controlType: 'text',\n            fn: function (v, a, parent, index, abilityModel, ability, TalentController) {\n                var lucentBeamAbility = abilityModel.abilities().find(function(b) {\n                    return b.name == 'luna_lucent_beam';\n                });\n                if (lucentBeamAbility.level() == 0) return 0;\n                var damage = abilityModel.getAbilityPropertyValue(lucentBeamAbility, 'damage');\n                return v*damage;\n            }\n        }\n    ],\n    'lycan_howl': [\n        {\n            label: 'Is Night',\n            controlType: 'checkbox'\n        },\n        {\n            attributeName: 'hero_bonus_damage',\n            label: '%CHANCE TO MISS:',\n            controlType: 'text',\n            fn: function (v, a, parent, index, abilityModel, ability, TalentController) {\n                if (v) {\n                    return a*2;\n                }\n                else {\n                    return a;\n                }\n            },\n            returnProperty: 'bonusDamage'\n        },\n        {\n            attributeName: 'hero_bonus_hp',\n            label: '%CHANCE TO MISS:',\n            controlType: 'text',\n            fn: function (v, a, parent, index, abilityModel, ability, TalentController) {\n                if (v) {\n                    return a*2;\n                }\n                else {\n                    return a;\n                }\n            },\n            returnProperty: 'bonusHealth'\n        }\n    ],\n    'medusa_mystic_snake': [\n        {\n            label: 'Jump Count',\n            controlType: 'input'\n        },\n        {\n            attributeName: 'snake_damage',\n            label: 'Damage Per Jump:',\n            ignoreTooltip: true,\n            controlType: 'method',\n            display: 'none',\n            fn: function (v, a, parent, index, abilityModel, ability, TalentController) {\n                var snake_jumps = abilityModel.getAbilityAttributeValue(ability.attributes, 'snake_jumps',ability.level());\n                var snake_scale = abilityModel.getAbilityAttributeValue(ability.attributes, 'snake_scale',0);\n                var damage = [];\n                for (var i = 0; i < snake_jumps; i++) {\n                    damage.push(a + a * i * snake_scale/100);\n                }\n                return damage;\n            }\n        },\n        {\n            attributeName: 'snake_damage',\n            label: 'Damage Per Jump:',\n            ignoreTooltip: true,\n            controlType: 'text',\n            controls: [0,1],\n            fn: function (v, a, parent, index, abilityModel, ability, TalentController) {\n                return v[1].join(' / ');\n            }\n        },\n        {\n            attributeName: 'snake_damage',\n            label: 'Total Damage:',\n            ignoreTooltip: true,\n            controlType: 'text',\n            controls: [0,1],\n            fn: function (v, a, parent, index, abilityModel, ability, TalentController) {\n                return v[1].slice(0, v[0]).reduce(function (memo, o) { return memo + o }, 0);\n            }\n        },\n        {\n            attributeName: 'snake_damage',\n            label: 'Max Damage:',\n            ignoreTooltip: true,\n            controlType: 'text',\n            controls: [0,1],\n            fn: function (v, a, parent, index, abilityModel, ability, TalentController) {\n                return v[1].reduce(function (memo, o) { return memo + o }, 0);\n            }\n        }\n    ],\n    'medusa_mana_shield': [\n        {\n            label: 'Damage',\n            controlType: 'input'\n        },\n        {\n            attributeName: 'damage_per_mana',\n            label: 'MANA USED:',\n            ignoreTooltip: true,\n            controlType: 'text',\n            fn: function (v, a, parent, index, abilityModel, ability, TalentController) {\n                return (v/a).toFixed(2);\n            }\n        },\n        {\n            attributeName: 'absorption_tooltip',\n            label: '%DAMAGE REDUCTION:',\n            ignoreTooltip: true,\n            controlType: 'text',\n            fn: function (v, a, parent, index, abilityModel, ability, TalentController) {\n                return -a;\n            },\n            returnProperty: 'damageReduction'\n        }\n    ],\n    'meepo_poof': [\n        {\n            label: 'Meepo Count',\n            controlType: 'input'\n        },\n        {\n            label: 'DAMAGE:',\n            controlType: 'text',\n            fn: function (v, a, parent, index, abilityModel, ability, TalentController) {\n                return abilityModel.getAbilityPropertyValue(ability, 'damage')*v;\n            }\n        }\n    ],\n    'meepo_geostrike': [\n        {\n            label: 'Stacks',\n            controlType: 'input'\n        },\n        {\n            label: 'DAMAGE:',\n            ignoreTooltip: true,\n            controlType: 'text',\n            fn: function (v, a, parent, index, abilityModel, ability, TalentController) {\n                return abilityModel.getAbilityPropertyValue(ability, 'damage')*v;\n            }\n        },\n        {\n            attributeName: 'slow',\n            label: '%SLOW:',\n            ignoreTooltip: true,\n            controlType: 'text',\n            noLevel: true,\n            fn: function (v, a, parent, index, abilityModel, ability, TalentController) {\n                return abilityModel.getAbilityAttributeValue(ability.attributes, 'slow',ability.level())*v;\n            },\n            returnProperty: 'movementSpeedPctReduction'\n        }\n    ],\n    'mirana_arrow': [\n        {\n            label: 'Arrow Travel Distance',\n            controlType: 'input'\n        },\n        {\n            attributeName: 'arrow_max_stun',\n            label: 'STUN DURATION:',\n            ignoreTooltip: true,\n            controlType: 'text',\n            fn: function (v, a, parent, index, abilityModel, ability, TalentController) {\n                var arrow_min_stun = abilityModel.getAbilityAttributeValue(ability.attributes, 'arrow_min_stun',0);\n                var arrow_max_stunrange = abilityModel.getAbilityAttributeValue(ability.attributes, 'arrow_max_stunrange',0);\n                var scale = Math.min(v, arrow_max_stunrange) / arrow_max_stunrange;\n                return Math.max(arrow_min_stun, Math.floor(a * scale / 0.1) * 0.1);\n            }\n        },\n        {\n            attributeName: 'arrow_bonus_damage',\n            label: 'TOTAL DAMAGE:',\n            ignoreTooltip: true,\n            controlType: 'text',\n            fn: function (v, a, parent, index, abilityModel, ability, TalentController) {\n                var ability = ability;\n                var damage = ko.utils.unwrapObservable(ability.damage)[ability.level()-1];\n                var arrow_max_stunrange = abilityModel.getAbilityAttributeValue(ability.attributes, 'arrow_max_stunrange',0);\n                var scale = Math.min(v, arrow_max_stunrange) / arrow_max_stunrange;\n                var bonus_damage = Math.floor(a * scale / 2.8) * 2.8;\n                return damage + ' + ' + bonus_damage + ' = ' + (damage + bonus_damage);\n            }\n        }\n    ],\n    'morphling_morph_agi': [\n        {\n            label: 'Shifts',\n            controlType: 'input'\n        },\n        {\n            attributeName: 'points_per_tick',\n            label: 'AGI SHIFT GAIN:',\n            ignoreTooltip: true,\n            controlType: 'text',\n            fn: function (v, a, parent, index, abilityModel, ability, TalentController) {\n                return v*a;\n            },\n            returnProperty: 'bonusAgility'\n        },\n        {\n            attributeName: 'points_per_tick',\n            label: 'STR SHIFT LOSS:',\n            ignoreTooltip: true,\n            controlType: 'text',\n            fn: function (v, a, parent, index, abilityModel, ability, TalentController) {\n                return -v*a;\n            },\n            returnProperty: 'bonusStrength'\n        },\n        {\n            attributeName: 'bonus_attributes',\n            label: 'SHIFT TIME:',\n            controlType: 'text',\n            fn: function (v, a, parent, index, abilityModel, ability, TalentController) {\n                return a;\n            },\n            returnProperty: 'bonusAgility2'\n        },\n        {\n            attributeName: 'morph_cooldown',\n            label: 'SHIFT TIME:',\n            ignoreTooltip: true,\n            controlType: 'text',\n            fn: function (v, a, parent, index, abilityModel, ability, TalentController) {\n                return v*a;\n            }\n        },\n        {\n            attributeName: 'mana_cost',\n            label: 'SHIFT MANA COST:',\n            ignoreTooltip: true,\n            controlType: 'text',\n            fn: function (v, a, parent, index, abilityModel, ability, TalentController) {\n                return v*a*abilityModel.getAbilityAttributeValue(ability.attributes, 'morph_cooldown',ability.level());\n            }\n        }\n    ],\n    'morphling_morph_str': [\n        {\n            label: 'Shifts',\n            controlType: 'input'\n        },\n        {\n            attributeName: 'points_per_tick',\n            label: 'STR SHIFT GAIN:',\n            ignoreTooltip: true,\n            controlType: 'text',\n            fn: function (v, a, parent, index, abilityModel, ability, TalentController) {\n                return v*a;\n            },\n            returnProperty: 'bonusStrength'\n        },\n        {\n            attributeName: 'points_per_tick',\n            label: 'AGI SHIFT LOSS:',\n            ignoreTooltip: true,\n            controlType: 'text',\n            fn: function (v, a, parent, index, abilityModel, ability, TalentController) {\n                return -v*a;\n            },\n            returnProperty: 'bonusAgility'\n        },\n        {\n            attributeName: 'bonus_attributes',\n            label: 'SHIFT TIME:',\n            controlType: 'text',\n            fn: function (v, a, parent, index, abilityModel, ability, TalentController) {\n                return a;\n            },\n            returnProperty: 'bonusStrength2'\n        },\n        {\n            attributeName: 'morph_cooldown',\n            label: 'SHIFT TIME:',\n            ignoreTooltip: true,\n            controlType: 'text',\n            fn: function (v, a, parent, index, abilityModel, ability, TalentController) {\n                return v*a;\n            }\n        },\n        {\n            attributeName: 'mana_cost',\n            label: 'SHIFT MANA COST:',\n            ignoreTooltip: true,\n            controlType: 'text',\n            fn: function (v, a, parent, index, abilityModel, ability, TalentController) {\n                return v*a*abilityModel.getAbilityAttributeValue(ability.attributes, 'morph_cooldown',ability.level());\n            }\n        }\n    ],\n    'furion_wrath_of_nature': [\n        {\n            label: 'Duration',\n            controlType: 'input'\n        },\n        {\n            attributeName: 'damage',\n            label: 'Total Damage',\n            controlType: 'text',\n            fn: function (v, a, parent, index, abilityModel, ability, TalentController) {\n                return v*a;\n            }\n        }\n    ],\n    'necrolyte_heartstopper_aura': [\n        {\n            label: 'Duration',\n            controlType: 'input'\n        },\n        {\n            label: 'Enemy Max Health',\n            controlType: 'input'\n        },\n        {\n            attributeName: 'aura_damage',\n            label: 'HEALTH LOST:',\n            ignoreTooltip: true,\n            controlType: 'text',\n            controls: [0,1],\n            fn: function (v, a, parent, index, abilityModel, ability, TalentController) {\n                return v[0]*v[1]*a/100;\n            }\n        }\n    ],\n    'necrolyte_sadist': [\n        {\n            label: 'Unit Kills',\n            controlType: 'input'\n        },\n        {\n            label: 'Hero Kills',\n            controlType: 'input'\n        },\n        {\n            attributeName: 'health_regen',\n            label: 'Total Damage',\n            controlType: 'text',\n            controls: [0,1],\n            fn: function (v, a, parent, index, abilityModel, ability, TalentController) {\n                var hero_multiplier = abilityModel.getAbilityAttributeValue(ability.attributes, 'hero_multiplier',0)\n                return (v[0]+v[1]*hero_multiplier)*a;\n            },\n            returnProperty: 'healthregen'\n        },\n        {\n            attributeName: 'mana_regen',\n            label: 'Total Damage',\n            controlType: 'text',\n            controls: [0,1],\n            fn: function (v, a, parent, index, abilityModel, ability, TalentController) {\n                var hero_multiplier = abilityModel.getAbilityAttributeValue(ability.attributes, 'hero_multiplier',0)\n                return (v[0]+v[1]*hero_multiplier)*a;\n            },\n            returnProperty: 'manaregen'\n        }\n    ],\n    'night_stalker_crippling_fear': [\n        {\n            label: 'Is Night',\n            controlType: 'checkbox'\n        },\n        {\n            attributeName: 'miss_rate_night',\n            label: '%CHANCE TO MISS:',\n            ignoreTooltip: true,\n            controlType: 'text',\n            fn: function (v, a, parent, index, abilityModel, ability, TalentController) {\n                if (v) {\n                    return abilityModel.getAbilityAttributeValue(ability.attributes, 'miss_rate_night',ability.level());\n                }\n                else {\n                    return abilityModel.getAbilityAttributeValue(ability.attributes, 'miss_rate_day',ability.level());\n                }\n            },\n            returnProperty: 'missChance'\n        }\n    ],    \n    'night_stalker_hunter_in_the_night': [\n        {\n            label: 'Is Night',\n            controlType: 'checkbox'\n        },\n        {\n            attributeName: 'bonus_attack_speed_night',\n            label: 'Total Damage',\n            controlType: 'text',\n            fn: function (v, a, parent, index, abilityModel, ability, TalentController) {\n                if (v) {\n                    return a;\n                }\n                else {\n                    return 0;\n                }\n            },\n            returnProperty: 'attackspeed'\n        },\n        {\n            attributeName: 'bonus_movement_speed_pct_night',\n            label: 'Total Damage',\n            controlType: 'text',\n            fn: function (v, a, parent, index, abilityModel, ability, TalentController) {\n                if (v) {\n                    return a;\n                }\n                else {\n                    return 0;\n                }\n            },\n            returnProperty: 'movementSpeedPct'\n        }\n    ],    \n    'obsidian_destroyer_arcane_orb': [\n        {\n            label: 'Current Mana',\n            controlType: 'input'\n        },\n        {\n            attributeName: 'mana_pool_damage_pct',\n            label: 'Total Damage',\n            controlType: 'text',\n            fn: function (v, a, parent, index, abilityModel, ability, TalentController) {\n                return v*a/100;\n            },\n            returnProperty: 'bonusDamageOrb'\n        }\n    ],\n    'ogre_magi_ignite': [\n        {\n            label: 'Duration',\n            controlType: 'input'\n        },\n        {\n            attributeName: 'burn_damage',\n            label: 'Total Damage',\n            controlType: 'text',\n            fn: function (v, a, parent, index, abilityModel, ability, TalentController) {\n                return v*a;\n            }\n        },\n        {\n            attributeName: 'slow_movement_speed_pct',\n            label: 'Total Damage',\n            controlType: 'text',\n            fn: function (v, a, parent, index, abilityModel, ability, TalentController) {\n                return a;\n            },\n            returnProperty: 'movementSpeedPctReduction'\n        }\n    ],\n    'pudge_rot': [\n        {\n            label: 'Duration',\n            controlType: 'input'\n        },\n        {\n            label: 'DAMAGE:',\n            controlType: 'text',\n            fn: function (v, a, parent, index, abilityModel, ability, TalentController) {\n                return abilityModel.getAbilityPropertyValue(ability, 'damage')*v;\n            }\n        },\n        {\n            attributeName: 'rot_slow',\n            label: 'Total Damage',\n            controlType: 'text',\n            fn: function (v, a, parent, index, abilityModel, ability, TalentController) {\n                return a;\n            },\n            returnProperty: 'movementSpeedPctReduction'\n        }\n    ],\n    'pudge_flesh_heap': [\n        {\n            label: 'Stacks',\n            controlType: 'input'\n        },\n        {\n            attributeName: 'flesh_heap_strength_buff_amount',\n            label: 'Total Damage',\n            controlType: 'text',\n            fn: function (v, a, parent, index, abilityModel, ability, TalentController) {\n                return v*a;\n            },\n            returnProperty: 'bonusStrength'\n        },\n        {\n            attributeName: 'flesh_heap_magic_resist',\n            label: 'Total Damage',\n            controlType: 'text',\n            fn: function (v, a, parent, index, abilityModel, ability, TalentController) {\n                return a;\n            },\n            returnProperty: 'magicResist'\n        }\n    ],\n    'pudge_dismember': [\n        {\n            label: 'Duration',\n            controlType: 'input'\n        },\n        {\n            attributeName: 'dismember_damage',\n            label: 'Total Damage',\n            controlType: 'text',\n            fn: function (v, a, parent, index, abilityModel, ability, TalentController) {\n                return v*a;\n            }\n        }\n    ],\n    'pugna_nether_ward': [\n        {\n            label: 'Enemy Mana Spent',\n            controlType: 'input'\n        },\n        {\n            attributeName: 'mana_multiplier',\n            label: 'DAMAGE:',\n            ignoreTooltip: true,\n            controlType: 'text',\n            fn: function (v, a, parent, index, abilityModel, ability, TalentController) {\n                return v*a;\n            }\n        },\n        {\n            attributeName: 'mana_regen',\n            label: 'Total Damage',\n            controlType: 'text',\n            fn: function (v, a, parent, index, abilityModel, ability, TalentController) {\n                return a;\n            },\n            returnProperty: 'manaregenreduction'\n        }\n    ],\n    'pugna_life_drain': [\n        {\n            label: 'Duration',\n            controlType: 'input'\n        },\n        {\n            attributeName: 'health_drain',\n            label: 'HEALTH DRAINED:',\n            ignoreTooltip: true,\n            controlType: 'text',\n            fn: function (v, a, parent, index, abilityModel, ability, TalentController) {\n                return v*a;\n            }\n        }\n    ],\n    'queenofpain_shadow_strike': [\n        {\n            label: 'Duration',\n            controlType: 'input'\n        },\n        {\n            attributeName: 'movement_slow',\n            label: 'Total Damage',\n            controlType: 'text',\n            fn: function (v, a, parent, index, abilityModel, ability, TalentController) {\n                return a;\n            },\n            returnProperty: 'movementSpeedPctReduction'\n        },\n        {\n            attributeName: 'strike_damage',\n            label: 'Total Damage:',\n            ignoreTooltip: true,\n            controlType: 'text',\n            fn: function (v, a, parent, index, abilityModel, ability, TalentController) {\n                var duration_damage = abilityModel.getAbilityAttributeValue(ability.attributes, 'duration_damage',ability.level());\n                var ticks = Math.floor(v/3);\n                return a + duration_damage * ticks;\n            }\n        }\n    ],\n    'razor_plasma_field': [\n        {\n            label: 'Distance',\n            controlType: 'input'\n        },\n        {\n            attributeName: 'radius',\n            label: 'MIN DISTANCE:',\n            ignoreTooltip: true,\n            controlType: 'text',\n            fn: function (v, a, parent, index, abilityModel, ability, TalentController) {\n                return 200;\n            }\n        },\n        {\n            attributeName: 'radius',\n            label: 'MAX DISTANCE:',\n            ignoreTooltip: true,\n            controlType: 'text',\n            fn: function (v, a, parent, index, abilityModel, ability, TalentController) {\n                return 200 + a;\n            }\n        },\n        {\n            attributeName: 'radius',\n            label: 'Instance Damage',\n            ignoreTooltip: true,\n            controlType: 'text',\n            fn: function (v, a, parent, index, abilityModel, ability, TalentController) {\n                var max_radius = a + 200;\n                var scale = (Math.min(Math.max(v, 200), max_radius) - 200) / (max_radius - 200);\n                var damage_min = abilityModel.getAbilityAttributeValue(ability.attributes, 'damage_min',ability.level());\n                var damage_max = abilityModel.getAbilityAttributeValue(ability.attributes, 'damage_max',ability.level());\n                return damage_min + (damage_max - damage_min) * scale;\n            }\n        }\n    ],\n    'razor_static_link': [\n        {\n            label: 'Duration',\n            controlType: 'input'\n        },\n        {\n            attributeName: 'drain_length',\n            label: 'Damage Drained:',\n            ignoreTooltip: true,\n            controlType: 'text',\n            fn: function (v, a, parent, index, abilityModel, ability, TalentController) {\n                var tick_duration = Math.floor(v * 4) + 1;\n                var ticks = Math.min(a * 4 + 1, tick_duration);\n                var drain_rate = abilityModel.getAbilityAttributeValue(ability.attributes, 'drain_rate',ability.level());\n                return ticks * drain_rate/4;\n            },\n            returnProperty: 'bonusDamage'\n        },\n        {\n            attributeName: 'drain_length',\n            label: 'Enemy Damage Lost:',\n            ignoreTooltip: true,\n            controlType: 'text',\n            display: 'hidden',\n            fn: function (v, a, parent, index, abilityModel, ability, TalentController) {\n                var tick_duration = Math.floor(v * 4) + 1;\n                var ticks = Math.min(a * 4 + 1, tick_duration);\n                var drain_rate = abilityModel.getAbilityAttributeValue(ability.attributes, 'drain_rate',ability.level());\n                return ticks * drain_rate/4;\n            },\n            returnProperty: 'bonusDamageReduction'\n        }\n    ],\n    'razor_eye_of_the_storm': [\n        {\n            label: 'Duration',\n            controlType: 'input'\n        },\n        {\n            attributeName: 'damage',\n            label: 'Total Damage',\n            controlType: 'text',\n            fn: function (v, a, parent, index, abilityModel, ability, TalentController) {\n                return v*a;\n            }\n        }\n    ],\n    'rubick_fade_bolt': [\n        {\n            label: 'Jumps',\n            controlType: 'input'\n        },\n        {\n            attributeName: 'damage',\n            label: 'Total Damage',\n            controlType: 'text',\n            fn: function (v, a, parent, index, abilityModel, ability, TalentController) {\n                return a * (1 - v*abilityModel.getAbilityAttributeValue(ability.attributes, 'jump_damage_reduction_pct',ability.level())/100);\n            }\n        },\n        {\n            attributeName: 'hero_attack_damage_reduction',\n            label: 'Total Damage',\n            controlType: 'text',\n            fn: function (v, a, parent, index, abilityModel, ability, TalentController) {\n                return a;\n            },\n            returnProperty: 'bonusDamageReduction'\n        }\n    ],\n    'sandking_sand_storm': [\n        {\n            label: 'Duration',\n            controlType: 'input'\n        },\n        {\n            label: 'DAMAGE:',\n            controlType: 'text',\n            fn: function (v, a, parent, index, abilityModel, ability, TalentController) {\n                return abilityModel.getAbilityPropertyValue(ability, 'damage')*v;\n            }\n        }\n    ],\n    'sandking_epicenter': [\n        {\n            label: 'Pulses',\n            controlType: 'input'\n        },\n        {\n            attributeName: 'epicenter_damage',\n            label: 'DAMAGE:',\n            ignoreTooltip: true,\n            controlType: 'text',\n            fn: function (v, a, parent, index, abilityModel, ability, TalentController) {\n                return v*a;\n            }\n        },\n        {\n            attributeName: 'epicenter_slow',\n            label: 'Total Damage',\n            controlType: 'text',\n            fn: function (v, a, parent, index, abilityModel, ability, TalentController) {\n                return a;\n            },\n            returnProperty: 'movementSpeedPctReduction'\n        },\n        {\n            attributeName: 'epicenter_slow_as',\n            label: '%ATTACK SLOW:',\n            ignoreTooltip: true,\n            controlType: 'text',\n            fn: function (v, a, parent, index, abilityModel, ability, TalentController) {\n                return a;\n            },\n            returnProperty: 'attackspeedreduction'\n        }\n    ],\n    'shadow_demon_shadow_poison': [\n        {\n            label: 'Duration',\n            controlType: 'input'\n        },\n        {\n            attributeName: 'stack_damage',\n            label: 'Total Damage',\n            controlType: 'text',\n            fn: function (v, a, parent, index, abilityModel, ability, TalentController) {\n                var stackmult = [1,2,4,8];\n                if (v > 4) {\n                    return a * stackmult[3] + 50 * (v - 4);\n                }\n                else if (v <= 0) {\n                    return 0\n                }\n                else {\n                    return a * stackmult[v-1]\n                }\n            }\n        }\n    ],\n    'nevermore_necromastery': [\n        {\n            label: 'Souls',\n            controlType: 'input'\n        },\n        {\n            attributeName: 'necromastery_damage_per_soul',\n            label: 'DAMAGE:',\n            ignoreTooltip: true,\n            controlType: 'text',\n            fn: function (v, a, parent, index, abilityModel, ability, TalentController) {\n                var talent = TalentController.getTalentById(parent.selectedTalents(), 'special_bonus_unique_nevermore_1');\n                if (talent) {\n                    return v * (a + talent.attributes[0].value[0]);\n                }\n                else {\n                    return v * a;\n                }\n            },\n            returnProperty: 'bonusDamage'\n        }\n    ],\n    'nevermore_requiem': [\n        {\n            label: 'Line Hit Count',\n            controlType: 'input'\n        },\n        {\n            attributeName: 'requiem_reduction_damage',\n            label: 'Damage:',\n            ignoreTooltip: true,\n            controlType: 'text',\n            fn: function (v, a, parent, index, abilityModel, ability, TalentController) {\n                return abilityModel.getAbilityPropertyValue(ability, 'damage')*v;\n            }\n        },\n        {\n            label: 'Return Line Hit Count (Scepter)',\n            controlType: 'input'\n        },\n        {\n            attributeName: 'requiem_damage_pct_scepter',\n            label: 'Damage/Heal:',\n            ignoreTooltip: true,\n            controlType: 'text',\n            fn: function (v, a, parent, index, abilityModel, ability, TalentController) {\n                return abilityModel.getAbilityPropertyValue(ability, 'damage')*v*a/100;\n            }\n        },\n        {\n            attributeName: 'requiem_damage_pct_scepter',\n            label: 'Total Damage:',\n            ignoreTooltip: true,\n            controlType: 'text',\n            controls: [0,1],\n            fn: function (v, a, parent, index, abilityModel, ability, TalentController) {\n                var damage = abilityModel.getAbilityPropertyValue(ability, 'damage');\n                return damage*v[0] + damage*v[1]*a/100;\n            }\n        },\n        {\n            attributeName: 'requiem_reduction_damage',\n            label: '%DAMAGE REDUCTION:',\n            ignoreTooltip: true,\n            controlType: 'text',\n            fn: function (v, a, parent, index, abilityModel, ability, TalentController) {\n                return a;\n            },\n            returnProperty: 'baseDamageReductionPct'\n        },\n        {\n            attributeName: 'requiem_reduction_ms',\n            label: '%DAMAGE REDUCTION:',\n            controlType: 'text',\n            fn: function (v, a, parent, index, abilityModel, ability, TalentController) {\n                return a;\n            },\n            returnProperty: 'movementSpeedPctReduction'\n        }\n    ],\n    'shadow_shaman_shackles': [\n        {\n            label: 'Duration',\n            controlType: 'input'\n        },\n        {\n            label: 'DAMAGE:',\n            controlType: 'text',\n            fn: function (v, a, parent, index, abilityModel, ability, TalentController) {\n                return abilityModel.getAbilityPropertyValue(ability, 'damage')*v;\n            }\n        }\n    ],\n    'silencer_curse_of_the_silent': [\n        {\n            label: 'Duration',\n            controlType: 'input'\n        },\n        {\n            attributeName: 'damage',\n            label: 'Total Damage',\n            controlType: 'text',\n            fn: function (v, a, parent, index, abilityModel, ability, TalentController) {\n                return Math.floor(v)*a;\n            }\n        },\n        {\n            attributeName: 'movespeed',\n            label: 'Total Damage',\n            controlType: 'text',\n            fn: function (v, a, parent, index, abilityModel, ability, TalentController) {\n                return a;\n            },\n            returnProperty: 'movementSpeedPctReduction'\n        }\n    ],\n/*        'silencer_glaives_of_wisdom': [\n        {\n            label: 'Duration',\n            controlType: 'input'\n        },\n        {\n            attributeName: 'damage',\n            label: 'Total Damage',\n            controlType: 'text',\n            fn: function (v, a, parent, index, abilityModel, ability, TalentController) {\n                return v*a;\n            }\n        }\n    ],*/\n    'skywrath_mage_mystic_flare': [\n        {\n            label: 'Duration',\n            controlType: 'input'\n        },\n        {\n            attributeName: 'damage',\n            label: 'Total Damage',\n            controlType: 'text',\n            fn: function (v, a, parent, index, abilityModel, ability, TalentController) {\n                return v*a;\n            }\n        }\n    ],\n    'slark_essence_shift': [\n        {\n            label: 'Attacks',\n            controlType: 'input'\n        },\n        {\n            attributeName: 'agi_gain',\n            label: 'Total Damage',\n            controlType: 'text',\n            display: 'ability',\n            fn: function (v, a, parent, index, abilityModel, ability, TalentController) {\n                return v*a;\n            },\n            returnProperty: 'bonusAgility'\n        },\n        {\n            attributeName: 'stat_loss',\n            label: 'Total Damage',\n            controlType: 'text',\n            fn: function (v, a, parent, index, abilityModel, ability, TalentController) {\n                return -v*a;\n            },\n            returnProperty: 'bonusAllStatsReduction'\n        }\n    ],\n    'slark_shadow_dance': [\n        {\n            label: 'Duration',\n            controlType: 'input'\n        },\n        {\n            attributeName: 'bonus_regen_pct',\n            label: 'TOTAL HEALTH REGENERATED:',\n            ignoreTooltip: true,\n            controlType: 'text',\n            fn: function (v, a, parent, index, abilityModel, ability, TalentController) {\n                return v*parent.health().total*a/100;\n            }\n        },\n        {\n            attributeName: 'bonus_regen_pct',\n            label: 'HEALTH GAINED PER SECOND:',\n            ignoreTooltip: true,\n            controlType: 'text',\n            fn: function (v, a, parent, index, abilityModel, ability, TalentController) {\n                return parent.health().total*a/100;\n            },\n            returnProperty: 'healthregen'\n        },\n        {\n            attributeName: 'bonus_movement_speed',\n            label: '%MOVE SPEED:',\n            ignoreTooltip: true,\n            controlType: 'text',\n            fn: function (v, a, parent, index, abilityModel, ability, TalentController) {\n                return a;\n            },\n            returnProperty: 'movementSpeedPct'\n        }\n    ],\n    'sniper_shrapnel': [\n        {\n            label: 'Duration',\n            controlType: 'input'\n        },\n        {\n            attributeName: 'shrapnel_damage',\n            label: 'DAMAGE:',\n            ignoreTooltip: true,\n            controlType: 'text',\n            fn: function (v, a, parent, index, abilityModel, ability, TalentController) {\n                return v*a;\n            }\n        },\n        {\n            attributeName: 'slow_movement_speed',\n            label: 'Enemy Movement Speed Slow',\n            controlType: 'text',\n            fn: function (v, a, parent, index, abilityModel, ability, TalentController) {\n                return a;\n            },\n            returnProperty: 'movementSpeedPctReduction'\n        }\n    ],\n    'spectre_desolate': [\n        {\n            label: 'Enemy Alone',\n            controlType: 'checkbox'\n        },\n        {\n            attributeName: 'bonus_damage',\n            label: 'Total Damage',\n            controlType: 'text',\n            fn: function (v, a, parent, index, abilityModel, ability, TalentController) {\n                if (v) {\n                    return a;\n                }\n                else {\n                    return 0;\n                }\n            },\n            returnProperty: 'bonusDamage'\n        }\n    ],\n    'spectre_dispersion': [\n        {\n            label: 'Damage Taken',\n            controlType: 'input'\n        },\n        {\n            attributeName: 'damage_reflection_pct',\n            label: 'DAMAGE REFLECTED:',\n            controlType: 'text',\n            fn: function (v, a, parent, index, abilityModel, ability, TalentController) {\n                return -a;\n            },\n            returnProperty: 'damageReduction'\n        },\n        {\n            attributeName: 'damage_reflection_pct',\n            label: 'DAMAGE REFLECTED:',\n            ignoreTooltip: true,\n            controlType: 'text',\n            fn: function (v, a, parent, index, abilityModel, ability, TalentController) {\n                return v*a/100;\n            }\n        }\n    ],\n    'storm_spirit_ball_lightning': [\n        {\n            label: 'MAX MANA',\n            controlType: 'input'\n        },\n        {\n            label: 'Distance',\n            controlType: 'input'\n        },\n        {\n            attributeName: 'ball_lightning_initial_mana_base',\n            label: 'Total Damage:',\n            ignoreTooltip: true,\n            controlType: 'text',\n            controls: [0, 1],\n            fn: function (v, a, parent, index, abilityModel, ability, TalentController) {\n                return abilityModel.getAbilityPropertyValue(ability, 'damage')/100*v[1];\n            }\n        },\n        {\n            attributeName: 'ball_lightning_initial_mana_base',\n            label: 'FLAT MANA COST:',\n            ignoreTooltip: true,\n            controlType: 'method',\n            controls: [0, 1],\n            fn: function (v, a, parent, index, abilityModel, ability, TalentController) {\n                var distance_intervals = Math.floor(v[1]/100);\n                var travel_cost_base = abilityModel.getAbilityAttributeValue(ability.attributes, 'ball_lightning_travel_cost_base',0);\n                return a + distance_intervals * travel_cost_base;\n            }\n        },\n        {\n            attributeName: 'ball_lightning_initial_mana_percentage',\n            label: '%MAX MANA COST:',\n            ignoreTooltip: true,\n            controlType: 'method',\n            controls: [0, 1],\n            fn: function (v, a, parent, index, abilityModel, ability, TalentController) {\n                var distance_intervals = Math.floor(v[1]/100);\n                var travel_cost_percent = abilityModel.getAbilityAttributeValue(ability.attributes, 'ball_lightning_travel_cost_percent',0);\n                return a + distance_intervals * travel_cost_percent;\n            }\n        },\n        {\n            attributeName: 'ball_lightning_initial_mana_base',\n            label: 'TOTAL MANA COST:',\n            ignoreTooltip: true,\n            controlType: 'text',\n            controls: [0, 1, 2, 3],\n            fn: function (v, a, parent, index, abilityModel, ability, TalentController) {\n                return v[2] + ' + ' + (v[3]/100 * v[0]) + ' (' + v[3] + '% of max) = ' + (v[2] + v[3]/100 * v[0]);\n            }\n        }\n    ],\n    'templar_assassin_psionic_trap': [\n        {\n            label: 'Charge Time',\n            controlType: 'input'\n        },\n        {\n            attributeName: 'movement_speed_min_tooltip',\n            label: '%MOVE SLOW:',\n            ignoreTooltip: true,\n            controlType: 'text',\n            fn: function (v, a, parent, index, abilityModel, ability, TalentController) {\n                var max_slow = abilityModel.getAbilityAttributeValue(ability.attributes, 'movement_speed_max_tooltip',0);\n                var slow_per_tick = (max_slow - a)/40;\n                return -(a + slow_per_tick * Math.min(Math.max(0, v), 4) * 10);\n            },\n            returnProperty: 'movementSpeedPctReduction'\n        }\n    ],\n    'shredder_reactive_armor': [\n        {\n            label: 'Stacks',\n            controlType: 'input'\n        },\n        {\n            attributeName: 'bonus_armor',\n            label: 'Total Armor Bonus',\n            controlType: 'text',\n            fn: function (v, a, parent, index, abilityModel, ability, TalentController) {\n                return v*a;\n            },\n            returnProperty: 'armor'\n        },\n        {\n            attributeName: 'bonus_hp_regen',\n            label: 'Total HP Regen Bonus',\n            controlType: 'text',\n            fn: function (v, a, parent, index, abilityModel, ability, TalentController) {\n                return v*a;\n            },\n            returnProperty: 'healthregen'\n        }\n    ],\n    'shredder_chakram': [\n        {\n            label: 'Duration',\n            controlType: 'input'\n        },\n        {\n            attributeName: 'damage_per_second',\n            label: 'DAMAGE:',\n            ignoreTooltip: true,\n            controlType: 'text',\n            fn: function (v, a, parent, index, abilityModel, ability, TalentController) {\n                var interval = abilityModel.getAbilityAttributeValue(ability.attributes, 'damage_interval',0);\n                var ticks = Math.floor(v / interval);\n                return a*interval*ticks;\n            }\n        },\n        {\n            attributeName: 'mana_per_second',\n            label: 'MANA COST:',\n            ignoreTooltip: true,\n            controlType: 'text',\n            fn: function (v, a, parent, index, abilityModel, ability, TalentController) {\n                var interval = abilityModel.getAbilityAttributeValue(ability.attributes, 'damage_interval',0);\n                var ticks = Math.floor(v / interval);\n                return a*interval*ticks;\n            }\n        },\n        {\n            label: 'ENEMY %HP',\n            controlType: 'input'\n        },\n        {\n            attributeName: 'slow',\n            label: 'MANA COST:',\n            controlType: 'text',\n            fn: function (v, a, parent, index, abilityModel, ability, TalentController) {\n                var ticks = 20 - Math.floor(Math.min(Math.max(v-1, 0), 99) / 5);\n                return -a*ticks;\n            },\n            returnProperty: 'movementSpeedPctReduction'\n        }\n    ],\n    'spirit_breaker_greater_bash': [\n        {\n            label: 'Bash Proc',\n            controlType: 'checkbox'\n        },\n        {\n            attributeName: 'damage',\n            label: '%MOVESPEED AS DAMAGE',\n            controlType: 'text',\n            fn: function (v, a, parent, index, abilityModel, ability, TalentController) {\n                if (v) {\n                    return a;\n                }\n                else {\n                    return 0;\n                }\n            },\n            returnProperty: 'bashBonusDamage'\n        },\n        {\n            attributeName: 'bonus_movespeed_pct',\n            label: 'Total Damage',\n            controlType: 'text',\n            fn: function (v, a, parent, index, abilityModel, ability, TalentController) {\n                if (v) {\n                    return a;\n                }\n                else {\n                    return 0;\n                }\n            },\n            returnProperty: 'movementSpeedPct'\n        },\n        {\n            attributeName: 'chance_pct',\n            label: 'Total Damage',\n            controlType: 'text',\n            fn: function (v, a, parent, index, abilityModel, ability, TalentController) {\n                return a\n            },\n            returnProperty: 'bash'\n        }\n    ],\n    'techies_land_mines': [\n        {\n            label: 'Number of Mines',\n            controlType: 'input'\n        },\n        {\n            attributeName: 'damage',\n            label: 'Total Damage',\n            controlType: 'text',\n            fn: function (v, a, parent, index, abilityModel, ability, TalentController) {\n                return v*a;\n            }\n        },\n        {\n            attributeName: 'damage',\n            label: 'AFTER REDUCTIONS:',\n            ignoreTooltip: true,\n            controlType: 'text',\n            fn: function (v, a, parent, index, abilityModel, ability, TalentController) {\n                var phys_reduction = parent.enemy().totalArmorPhysicalReduction(),\n                    magic_reduction = parent.enemy().totalMagicResistance();\n                return (v * a * (1 - phys_reduction / 100) * (1 - magic_reduction / 100)).toFixed(2);\n            }\n        }\n    ],\n    'techies_suicide': [\n        {\n            attributeName: 'damage',\n            label: 'FULL DAMAGE AFTER REDUCTIONS:',\n            ignoreTooltip: true,\n            controlType: 'text',\n            fn: function (v, a, parent, index, abilityModel, ability, TalentController) {\n                var phys_reduction = parent.enemy().totalArmorPhysicalReduction(),\n                    magic_reduction = parent.enemy().totalMagicResistance();\n                return (a * (1 - phys_reduction / 100) * (1 - magic_reduction / 100)).toFixed(2);\n            }\n        },\n        {\n            attributeName: 'partial_damage',\n            label: 'PARTIAL DAMAGE AFTER REDUCTIONS:',\n            ignoreTooltip: true,\n            controlType: 'text',\n            fn: function (v, a, parent, index, abilityModel, ability, TalentController) {\n                var phys_reduction = parent.enemy().totalArmorPhysicalReduction(),\n                    magic_reduction = parent.enemy().totalMagicResistance();\n                return (a * (1 - phys_reduction / 100) * (1 - magic_reduction / 100)).toFixed(2);\n            }\n        },\n        {\n            attributeName: 'damage',\n            label: 'RESPAWN TIME:',\n            ignoreTooltip: true,\n            controlType: 'text',\n            fn: function (v, a, parent, index, abilityModel, ability, TalentController) {\n                return (parent.respawnTime() / 2).toFixed(0) + ' seconds';\n            }\n        }\n    ],\n    'techies_remote_mines': [\n        {\n            label: 'Number of Mines',\n            controlType: 'input'\n        },\n        {\n            attributeName: 'damage',\n            label: 'Total Damage',\n            controlType: 'text',\n            fn: function (v, a, parent, index, abilityModel, ability, TalentController) {\n                return v*a;\n            }\n        },\n        {\n            attributeName: 'damage',\n            label: 'AFTER REDUCTIONS:',\n            ignoreTooltip: true,\n            controlType: 'text',\n            fn: function (v, a, parent, index, abilityModel, ability, TalentController) {\n                var magic_reduction = parent.enemy().totalMagicResistance();\n                return (v * a * (1 - magic_reduction / 100)).toFixed(2);\n            }\n        }\n    ],\n    'tinker_march_of_the_machines': [\n        {\n            label: 'Robot Explosions',\n            controlType: 'input'\n        },\n        {\n            attributeName: 'machines_per_sec',\n            label: 'TOTAL DAMAGE:',\n            ignoreTooltip: true,\n            controlType: 'text',\n            fn: function (v, a, parent, index, abilityModel, ability, TalentController) {\n                return abilityModel.getAbilityPropertyValue(ability, 'damage')*v;\n            }\n        }\n    ],\n    'treant_leech_seed': [\n        {\n            label: 'Pulses',\n            controlType: 'input'\n        },\n        {\n            attributeName: 'leech_damage',\n            label: 'DAMAGE/HEAL:',\n            ignoreTooltip: true,\n            controlType: 'text',\n            fn: function (v, a, parent, index, abilityModel, ability, TalentController) {\n                return v*a;\n            }\n        },\n        {\n            attributeName: 'movement_slow',\n            label: 'Total Damage',\n            controlType: 'text',\n            fn: function (v, a, parent, index, abilityModel, ability, TalentController) {\n                return a;\n            },\n            returnProperty: 'movementSpeedPctReduction'\n        }\n    ],\n    'troll_warlord_fervor': [\n        {\n            label: 'Stacks',\n            controlType: 'input'\n        },\n        {\n            attributeName: 'attack_speed',\n            label: 'ATTACK SPEED:',\n            ignoreTooltip: true,\n            controlType: 'text',\n            fn: function (v, a, parent, index, abilityModel, ability, TalentController) {\n                return v*a;\n            },\n            returnProperty: 'attackspeed'\n        }\n    ],\n    'undying_decay': [\n        {\n            label: 'Stacks',\n            controlType: 'input'\n        },\n        {\n            attributeName: 'str_steal',\n            label: 'STRENGTH STOLEN:',\n            ignoreTooltip: true,\n            controlType: 'text',\n            fn: function (v, a, parent, index, abilityModel, ability, TalentController) {\n                if (parent.inventory.hasScepter()) {\n                    var str_steal_scepter = abilityModel.getAbilityAttributeValue(ability.attributes, 'str_steal_scepter',0);\n                    return v*str_steal_scepter;\n                }\n                else {\n                    return v*a;\n                }\n            },\n            returnProperty: 'bonusStrength'\n        },\n    ],\n    'undying_soul_rip': [\n        {\n            label: 'Units',\n            controlType: 'input'\n        },\n        {\n            attributeName: 'damage_per_unit',\n            label: 'DAMAGE/HEAL:',\n            ignoreTooltip: true,\n            controlType: 'text',\n            fn: function (v, a, parent, index, abilityModel, ability, TalentController) {\n                return v*a;\n            }\n        }\n    ],\n    'undying_flesh_golem': [\n        {\n            label: 'Distance',\n            controlType: 'input'\n        },\n        {\n            attributeName: 'max_speed_slow',\n            label: '%MOVE SLOW:',\n            ignoreTooltip: true,\n            controlType: 'text',\n            fn: function (v, a, parent, index, abilityModel, ability, TalentController) {\n                var min_speed_slow = abilityModel.getAbilityAttributeValue(ability.attributes, 'min_speed_slow', 0);\n                var radius = abilityModel.getAbilityAttributeValue(ability.attributes, 'radius', 0);\n                var full_power_radius = abilityModel.getAbilityAttributeValue(ability.attributes, 'full_power_radius', 0);\n                var distance = Math.min(Math.max(v, full_power_radius), radius);\n                var scale = 1 - (distance - full_power_radius) / (radius - full_power_radius);\n                return -Math.max(scale * a, min_speed_slow);\n            },\n            returnProperty: 'movementSpeedPctReduction'\n        },\n        {\n            attributeName: 'max_damage_amp',\n            label: '%DAMAGE AMP:',\n            ignoreTooltip: true,\n            controlType: 'text',\n            fn: function (v, a, parent, index, abilityModel, ability, TalentController) {\n                var min_damage_amp = abilityModel.getAbilityAttributeValue(ability.attributes, 'min_damage_amp', 0);\n                var radius = abilityModel.getAbilityAttributeValue(ability.attributes, 'radius', 0);\n                var full_power_radius = abilityModel.getAbilityAttributeValue(ability.attributes, 'full_power_radius', 0);\n                var distance = Math.min(Math.max(v, full_power_radius), radius);\n                var scale = 1 - (distance - full_power_radius) / (radius - full_power_radius);\n                return Math.max(scale * a, min_damage_amp);\n            },\n            returnProperty: 'damageAmplification'\n        },\n        {\n            label: 'MAX HP',\n            controlType: 'input'\n        },\n        {\n            label: 'Hero Death Count',\n            controlType: 'input'\n        },\n        {\n            label: 'Creep Death Count',\n            controlType: 'input'\n        },\n        {\n            attributeName: 'death_heal',\n            label: 'DEATH HEAL (HEROES):',\n            ignoreTooltip: true,\n            controlType: 'method',\n            controls: [1, 2],\n            fn: function (v, a, parent, index, abilityModel, ability, TalentController) {\n                return v[0]*v[1]*a/100;\n            }\n        },\n        {\n            attributeName: 'death_heal_creep',\n            label: 'DEATH HEAL (CREEPS):',\n            ignoreTooltip: true,\n            controlType: 'method',\n            controls: [1, 3],\n            fn: function (v, a, parent, index, abilityModel, ability, TalentController) {\n                return v[0]*v[1]*a/100;\n            }\n        },\n        {\n            attributeName: 'death_heal_creep',\n            label: 'TOTAL DEATH HEAL:',\n            ignoreTooltip: true,\n            controlType: 'text',\n            controls: [4, 5],\n            fn: function (v, a, parent, index, abilityModel, ability, TalentController) {\n                return v[0]+v[1];\n            }\n        }\n    ],\n    'ursa_fury_swipes': [\n        {\n            label: 'Stacks',\n            controlType: 'input'\n        },\n        {\n            attributeName: 'damage_per_stack',\n            label: 'Total Damage',\n            controlType: 'text',\n            fn: function (v, a, parent, index, abilityModel, ability, TalentController) {\n                var enrageAbility = abilityModel.abilities().find(function(b) {\n                    return b.name == 'ursa_enrage';\n                });\n                if (enrageAbility.isActive() && enrageAbility.level() > 0) {\n                    var enrage_multiplier = abilityModel.getAbilityAttributeValue(enrageAbility.attributes, 'enrage_multiplier', enrageAbility.level());\n                    return v*a*enrage_multiplier;\n                }\n                return v*a;\n            },\n            returnProperty: 'bonusDamage'\n        }\n    ],\n    'ursa_enrage': [\n        {\n            attributeName: 'damage_reduction',\n            label: 'Total Damage',\n            controlType: 'text',\n            fn: function (v, a, parent, index, abilityModel, ability, TalentController) {\n                return -a;\n            },\n            returnProperty: 'damageReduction'\n        }\n    ],\n    'venomancer_venomous_gale': [\n        {\n            label: 'Duration',\n            controlType: 'input'\n        },\n        {\n            attributeName: 'tick_damage',\n            label: 'Total Damage',\n            controlType: 'text',\n            fn: function (v, a, parent, index, abilityModel, ability, TalentController) {\n                return abilityModel.getAbilityAttributeValue(ability.attributes, 'strike_damage',ability.level()) + Math.floor(v/3)*a;\n            }\n        },\n        {\n            attributeName: 'movement_slow',\n            label: 'Total Damage',\n            controlType: 'text',\n            fn: function (v, a, parent, index, abilityModel, ability, TalentController) {\n                return a;\n            },\n            returnProperty: 'movementSpeedPctReduction'\n        }\n    ],\n    'venomancer_poison_sting': [\n        {\n            label: 'Duration',\n            controlType: 'input'\n        },\n        {\n            attributeName: 'damage',\n            label: 'Total Damage',\n            controlType: 'text',\n            fn: function (v, a, parent, index, abilityModel, ability, TalentController) {\n                return v*a;\n            }\n        },\n        {\n            attributeName: 'movement_speed',\n            label: 'Total Damage',\n            controlType: 'text',\n            fn: function (v, a, parent, index, abilityModel, ability, TalentController) {\n                return a;\n            },\n            returnProperty: 'movementSpeedPctReduction'\n        }\n    ],\n    'venomancer_poison_nova': [\n        {\n            label: 'Duration',\n            controlType: 'input'\n        },\n        {\n            attributeName: 'damage',\n            label: 'Total Damage',\n            controlType: 'text',\n            fn: function (v, a, parent, index, abilityModel, ability, TalentController) {\n                return v*a;\n            }\n        }\n    ],\n    'viper_poison_attack': [\n        {\n            label: 'Duration',\n            controlType: 'input'\n        },\n        {\n            attributeName: 'damage',\n            label: 'Total Damage',\n            controlType: 'text',\n            fn: function (v, a, parent, index, abilityModel, ability, TalentController) {\n                return v*a;\n            }\n        },\n        {\n            attributeName: 'bonus_movement_speed',\n            label: 'Total Damage',\n            controlType: 'text',\n            fn: function (v, a, parent, index, abilityModel, ability, TalentController) {\n                return a;\n            },\n            returnProperty: 'movementSpeedPctReduction'\n        },\n        {\n            attributeName: 'bonus_attack_speed',\n            label: 'Total Damage',\n            controlType: 'text',\n            fn: function (v, a, parent, index, abilityModel, ability, TalentController) {\n                return a;\n            },\n            returnProperty: 'attackspeedreduction'\n        }\n    ],\n    'viper_corrosive_skin': [\n        {\n            label: 'Duration',\n            controlType: 'input'\n        },\n        {\n            attributeName: 'damage',\n            label: 'Total Damage',\n            controlType: 'text',\n            fn: function (v, a, parent, index, abilityModel, ability, TalentController) {\n                return v*a;\n            }\n        },\n        {\n            attributeName: 'bonus_movement_speed',\n            label: 'Total Damage',\n            controlType: 'text',\n            fn: function (v, a, parent, index, abilityModel, ability, TalentController) {\n                return a;\n            },\n            returnProperty: 'movementSpeedPctReduction'\n        },\n        {\n            attributeName: 'bonus_attack_speed',\n            label: 'Total Damage',\n            controlType: 'text',\n            fn: function (v, a, parent, index, abilityModel, ability, TalentController) {\n                return a;\n            },\n            returnProperty: 'attackspeedreduction'\n        },\n        {\n            attributeName: 'bonus_magic_resistance',\n            label: 'Total Damage',\n            controlType: 'text',\n            fn: function (v, a, parent, index, abilityModel, ability, TalentController) {\n                return a;\n            },\n            returnProperty: 'magicResist'\n        }\n    ],\n    'viper_viper_strike': [\n        {\n            label: 'Duration',\n            controlType: 'input'\n        },\n        {\n            attributeName: 'damage',\n            label: 'Total Damage',\n            controlType: 'text',\n            fn: function (v, a, parent, index, abilityModel, ability, TalentController) {\n                return v*a;\n            }\n        },\n        {\n            attributeName: 'bonus_movement_speed',\n            label: 'Total Damage',\n            controlType: 'text',\n            fn: function (v, a, parent, index, abilityModel, ability, TalentController) {\n                return a;\n            },\n            returnProperty: 'movementSpeedPctReduction'\n        },\n        {\n            attributeName: 'bonus_attack_speed',\n            label: 'Total Damage',\n            controlType: 'text',\n            fn: function (v, a, parent, index, abilityModel, ability, TalentController) {\n                return a;\n            },\n            returnProperty: 'attackspeedreduction'\n        }\n    ],\n    'visage_soul_assumption': [\n        {\n            label: 'Charges',\n            controlType: 'input'\n        },\n        {\n            attributeName: 'soul_charge_damage',\n            label: 'Total Damage:',\n            ignoreTooltip: true,\n            controlType: 'text',\n            fn: function (v, a, parent, index, abilityModel, ability, TalentController) {\n                var soul_base_damage = abilityModel.getAbilityAttributeValue(ability.attributes, 'soul_base_damage',0);\n                var stack_limit = abilityModel.getAbilityAttributeValue(ability.attributes, 'stack_limit', ability.level());\n                stack_limit = Math.max(Math.min(v, stack_limit), 0);\n                return soul_base_damage + stack_limit*a;\n            }\n        }\n    ],\n    'visage_gravekeepers_cloak': [\n        {\n            label: 'Layers',\n            controlType: 'input'\n        },\n        {\n            attributeName: 'damage_reduction',\n            label: 'DAMAGE REDUCTION:',\n            ignoreTooltip: true,\n            controlType: 'text',\n            fn: function (v, a, parent, index, abilityModel, ability, TalentController) {\n                return -v*a;\n            },\n            returnProperty: 'damageReduction'\n        }\n    ],\n    'warlock_shadow_word': [\n        {\n            label: 'Duration',\n            controlType: 'input'\n        },\n        {\n            label: 'DAMAGE:',\n            ignoreTooltip: true,\n            controlType: 'text',\n            fn: function (v, a, parent, index, abilityModel, ability, TalentController) {\n                return abilityModel.getAbilityPropertyValue(ability, 'damage')*v;\n            }\n        }\n    ],\n    'warlock_upheaval': [\n        {\n            label: 'Channel Duration',\n            controlType: 'input'\n        },\n        {\n            attributeName: 'slow_rate_duration',\n            label: '%MOVE SLOW:',\n            ignoreTooltip: true,\n            controlType: 'text',\n            fn: function (v, a, parent, index, abilityModel, ability, TalentController) {\n                var max_slow = abilityModel.getAbilityAttributeValue(ability.attributes, 'max_slow',0);\n                var slow_per_tick = max_slow / (a - 0.5) / 2;\n                var ticks = Math.max(Math.floor(v * 2) - 1, 0);\n                return -Math.min(ticks * slow_per_tick, max_slow);\n            },\n            returnProperty: 'movementSpeedPctReduction'\n        }\n    ],\n    'weaver_the_swarm': [\n        {\n            label: 'Attacks',\n            controlType: 'input'\n        },\n        {\n            attributeName: 'damage',\n            label: 'DAMAGE:',\n            controlType: 'text',\n            fn: function (v, a, parent, index, abilityModel, ability, TalentController) {\n                return v*a;\n            }\n        },\n        {\n            attributeName: 'armor_reduction',\n            label: 'DAMAGE:',\n            controlType: 'text',\n            fn: function (v, a, parent, index, abilityModel, ability, TalentController) {\n                return -v*a;\n            },\n            returnProperty: 'armorReduction'\n        }\n    ],\n    'windrunner_powershot': [\n        {\n            label: 'Duration',\n            controlType: 'input'\n        },\n        {\n            label: 'DAMAGE:',\n            ignoreTooltip: true,\n            controlType: 'text',\n            fn: function (v, a, parent, index, abilityModel, ability, TalentController) {\n                return abilityModel.getAbilityPropertyValue(ability, 'damage')*v;\n            }\n        }\n    ],\n    'winter_wyvern_cold_embrace': [\n        {\n            label: 'Duration',\n            controlType: 'input'\n        },\n        {\n            label: 'Ally Max Health',\n            controlType: 'input'\n        },\n        {\n            attributeName: 'heal_percentage',\n            label: 'TOTAL HEAL:',\n            ignoreTooltip: true,\n            controlType: 'text',\n            controls: [0,1],\n            fn: function (v, a, parent, index, abilityModel, ability, TalentController) {\n                var base_heal = abilityModel.getAbilityAttributeValue(ability.attributes, 'heal_additive',ability.level());\n                return (base_heal + v[1] * a/100) * v[0];\n            }\n        }\n    ],\n    'wisp_spirits': [\n        {\n            label: 'Collision Count',\n            controlType: 'input'\n        },\n        {\n            attributeName: 'hero_damage',\n            label: 'Total Damage',\n            controlType: 'text',\n            fn: function (v, a, parent, index, abilityModel, ability, TalentController) {\n                return v*a;\n            }\n        },\n        {\n            attributeName: 'creep_damage',\n            label: 'Total Damage',\n            controlType: 'text',\n            fn: function (v, a, parent, index, abilityModel, ability, TalentController) {\n                return v*a;\n            }\n        }\n    ],\n    'wisp_overcharge': [\n        {\n            label: 'Current HP',\n            controlType: 'input'\n        },\n        {\n            attributeName: 'drain_pct',\n            label: 'HP DRAINED:',\n            ignoreTooltip: true, \n            controlType: 'text',\n            fn: function (v, a, parent, index, abilityModel, ability, TalentController) {\n                return v*a;\n            }\n        },\n        {\n            label: 'Current MP',\n            controlType: 'input'\n        },\n        {\n            attributeName: 'drain_pct',\n            label: 'MP DRAINED:',\n            ignoreTooltip: true, \n            controlType: 'text',\n            fn: function (v, a, parent, index, abilityModel, ability, TalentController) {\n                return v*a;\n            }\n        },\n        {\n            attributeName: 'bonus_attack_speed',\n            label: 'Total Damage',\n            controlType: 'text',\n            fn: function (v, a, parent, index, abilityModel, ability, TalentController) {\n                return a;\n            },\n            returnProperty: 'attackspeed'\n        },\n        {\n            attributeName: 'bonus_damage_pct',\n            label: 'Total Damage',\n            controlType: 'text',\n            fn: function (v, a, parent, index, abilityModel, ability, TalentController) {\n                return a;\n            },\n            returnProperty: 'damageReduction'\n        }\n    ],\n    'witch_doctor_paralyzing_cask': [\n        {\n            label: 'Hero Bounce Count',\n            controlType: 'input'\n        },\n        {\n            attributeName: 'hero_damage',\n            label: 'Total Damage',\n            controlType: 'text',\n            fn: function (v, a, parent, index, abilityModel, ability, TalentController) {\n                var bounces = abilityModel.getAbilityAttributeValue(ability.attributes, 'bounces',ability.level());\n                return Math.min(Math.max(v, 0), bounces)*a;\n            }\n        },\n        {\n            label: 'Creep Bounce Count',\n            controlType: 'input'\n        },\n        {\n            attributeName: 'hero_damage',\n            label: 'CREEP DAMAGE:',\n            ignoreTooltip: true,\n            controlType: 'text',\n            fn: function (v, a, parent, index, abilityModel, ability, TalentController) {\n                var bounces = abilityModel.getAbilityAttributeValue(ability.attributes, 'bounces',ability.level());\n                var damage = abilityModel.getAbilityPropertyValue(ability, 'damage');\n                return Math.min(Math.max(v, 0), bounces)*damage;\n            }\n        }\n    ],\n    'witch_doctor_voodoo_restoration': [\n        {\n            label: 'Duration',\n            controlType: 'input'\n        },\n        {\n            attributeName: 'heal',\n            label: 'Total Damage',\n            controlType: 'text',\n            fn: function (v, a, parent, index, abilityModel, ability, TalentController) {\n                var interval = abilityModel.getAbilityAttributeValue(ability.attributes, 'heal_interval',ability.level());\n                var heal_per_tick = a * interval;\n                var ticks = Math.max(Math.floor(v / interval) - 1, 0);\n                return heal_per_tick * ticks;\n            }\n        },\n        {\n            attributeName: 'mana_per_second',\n            label: 'MANA COST:',\n            ignoreTooltip: true,\n            controlType: 'text',\n            fn: function (v, a, parent, index, abilityModel, ability, TalentController) {\n                var interval = abilityModel.getAbilityAttributeValue(ability.attributes, 'heal_interval',ability.level());\n                var mana_per_tick = a * interval;\n                var ticks = Math.max(Math.floor(v / interval) - 1, 0);\n                return mana_per_tick * ticks;\n            }\n        }\n    ],\n    'witch_doctor_maledict': [\n        {\n            label: 'damage 0-4s',\n            controlType: 'input'\n        },\n        {\n            label: 'damage 4-8s',\n            controlType: 'input'\n        },\n        {\n            label: 'damage 8-12s',\n            controlType: 'input'\n        },\n        {\n            attributeName: 'bonus_damage',\n            label: 'Dot Damage after 3s:',\n            ignoreTooltip: true,\n            controlType: 'method',\n            fn: function (v, a, parent, index, abilityModel, ability, TalentController) {\n                var damage = abilityModel.getAbilityPropertyValue(ability, 'damage');\n                return 3*damage;\n            }\n        },\n        {\n            attributeName: 'bonus_damage',\n            label: 'Burst Damage at 4s:',\n            ignoreTooltip: true,\n            controlType: 'method',\n            controls: [0, 3],\n            fn: function (v, a, parent, index, abilityModel, ability, TalentController) {\n                var damage = abilityModel.getAbilityPropertyValue(ability, 'damage');\n                var d = v.reduce(function (memo, o) { return memo + o }, 0);\n                return Math.max(d, 0) * a/100;\n            }\n        },\n        {\n            attributeName: 'bonus_damage',\n            label: 'Dot Damage after 7s:',\n            ignoreTooltip: true,\n            controlType: 'method',\n            fn: function (v, a, parent, index, abilityModel, ability, TalentController) {\n                var damage = abilityModel.getAbilityPropertyValue(ability, 'damage');\n                return 7*damage;\n            }\n        },\n        {\n            attributeName: 'bonus_damage',\n            label: 'Burst Damage at 8s:',\n            ignoreTooltip: true,\n            controlType: 'method',\n            controls: [0, 1, 4, 5],\n            fn: function (v, a, parent, index, abilityModel, ability, TalentController) {\n                var damage = abilityModel.getAbilityPropertyValue(ability, 'damage');\n                var d = v.reduce(function (memo, o) { return memo + o }, 0);\n                return Math.max(d, 0) * a/100;\n            }\n        },\n        {\n            attributeName: 'bonus_damage',\n            label: 'Dot Damage after 11s:',\n            ignoreTooltip: true,\n            controlType: 'method',\n            fn: function (v, a, parent, index, abilityModel, ability, TalentController) {\n                var damage = abilityModel.getAbilityPropertyValue(ability, 'damage');\n                return 11*damage;\n            }\n        },\n        {\n            attributeName: 'bonus_damage',\n            label: 'Burst Damage at 12s:',\n            ignoreTooltip: true,\n            controlType: 'method',\n            controls: [0, 1, 2, 4, 6, 7],\n            fn: function (v, a, parent, index, abilityModel, ability, TalentController) {\n                var damage = abilityModel.getAbilityPropertyValue(ability, 'damage');\n                var d = v.reduce(function (memo, o) { return memo + o }, 0);\n                return Math.max(d, 0) * a/100;\n            }\n        },\n        {\n            attributeName: 'bonus_damage',\n            label: 'Total Burst Damage:',\n            ignoreTooltip: true,\n            controlType: 'method',\n            controls: [4, 6, 8],\n            fn: function (v, a, parent, index, abilityModel, ability, TalentController) {\n                return v.reduce(function (memo, o) { return memo + o }, 0);\n            }\n        },\n        {\n            attributeName: 'bonus_damage',\n            label: 'Total Maledict Damage:',\n            ignoreTooltip: true,\n            controlType: 'method',\n            controls: [9],\n            fn: function (v, a, parent, index, abilityModel, ability, TalentController) {\n                var duration = abilityModel.getAbilityAttributeValue(ability.attributes, 'duration_tooltip',0);\n                var damage = abilityModel.getAbilityPropertyValue(ability, 'damage');\n                return damage * duration + v[0];\n            }\n        },\n        {\n            label: 'Duration',\n            controlType: 'input'\n        },\n        {\n            attributeName: 'bonus_damage',\n            label: 'DOT Damage',\n            controlType: 'text',\n            fn: function (v, a, parent, index, abilityModel, ability, TalentController) {\n                var duration = abilityModel.getAbilityAttributeValue(ability.attributes, 'duration_tooltip',0);\n                return abilityModel.getAbilityPropertyValue(ability, 'damage')*Math.min(Math.max(v, 0), duration);\n            }\n        }\n    ],\n    'witch_doctor_death_ward': [\n        {\n            label: 'Duration',\n            controlType: 'input'\n        },\n        {\n            attributeName: 'damage',\n            label: 'Total Damage',\n            controlType: 'text',\n            fn: function (v, a, parent, index, abilityModel, ability, TalentController) {\n                return v*a;\n            }\n        }\n    ],\n    'zuus_static_field': [\n        {\n            label: 'Enemy HP',\n            controlType: 'input'\n        },\n        {\n            attributeName: 'damage_health_pct',\n            label: 'DAMAGE:',\n            ignoreTooltip: true,\n            controlType: 'text',\n            fn: function (v, a, parent, index, abilityModel, ability, TalentController) {\n                return v*a/100;\n            }\n        }\n    ]\n}\n\nmodule.exports = abilityData;",
    "'use strict';\nvar ko = (typeof window !== \"undefined\" ? window['ko'] : typeof global !== \"undefined\" ? global['ko'] : null);\n\nko.mapping = require('./lib/knockout.mapping');\nko.wrap = require('./lib/knockout.wrap');\n\nko.extenders.numeric = function(target, opts) {\n    //create a writable computed observable to intercept writes to our observable\n    var result = ko.pureComputed({\n        read: target,  //always return the original observables value\n        write: function(newValue) {\n            var current = target(),\n                roundingMultiplier = Math.pow(10, (opts === Object(opts) ? opts.precision : opts) || 0),\n                newValueAsNum = isNaN(newValue) ? (opts.defaultValue || 0) : +newValue,\n                valueToWrite = Math.round(newValueAsNum * roundingMultiplier) / roundingMultiplier;\n \n            //only write if it changed\n            if (valueToWrite !== current) {\n                target(valueToWrite);\n            } else {\n                //if the rounded value is the same, but a different value was written, force a notification for the current field\n                if (newValue !== current) {\n                    target.notifySubscribers(valueToWrite);\n                }\n            }\n        }\n    }).extend({ notify: 'always' });\n \n    //initialize with current value to make sure it is rounded appropriately\n    result(target());\n \n    //return the new computed observable\n    return result;\n};\n\nmodule.exports = ko;",
    "var illusionData = {\n    chaos_knight_phantasm: {\n        hero: 'chaos_knight',\n        displayName: 'Chaos Knight Phantasm',\n        use_selected_hero: false,\n        max_level: 3,\n        outgoing_damage: 'outgoing_damage',\n        incoming_damage: 'incoming_damage'\n    },\n    naga_siren_mirror_image: {\n        hero: 'naga_siren',\n        displayName: 'Naga Siren Mirror Image',\n        use_selected_hero: false,\n        max_level: 4,\n        outgoing_damage: 'outgoing_damage',\n        incoming_damage: 'incoming_damage'\n    },\n    dark_seer_wall_of_replica: {\n        hero: 'dark_seer',\n        displayName: 'Dark Seer Wall of Replica',\n        use_selected_hero: true,\n        max_level: 3,\n        outgoing_damage: 'replica_damage_outgoing',\n        incoming_damage: 'replica_damage_incoming',\n        outgoing_damage_scepter: 'replica_damage_outgoing_scepter'\n    },\n    morphling_replicate: {\n        hero: 'morphling',\n        displayName: 'Morphling Replicate',\n        use_selected_hero: true,\n        max_level: 3,\n        outgoing_damage: 'illusion_damage_out_pct',\n        incoming_damage: 'illusion_damage_in_pct',\n        outgoing_damage_sign: -1\n    },\n    phantom_lancer_doppelwalk_1: {\n        hero: 'phantom_lancer',\n        displayName: 'Phantom Lancer Doppelwalk 1',\n        use_selected_hero: false,\n        max_level: 4,\n        outgoing_damage: 'illusion_1_damage_out_pct',\n        incoming_damage: 'illusion_1_damage_in_pct'\n    },\n    phantom_lancer_doppelwalk_2: {\n        hero: 'phantom_lancer',\n        displayName: 'Phantom Lancer Doppelwalk 2',\n        use_selected_hero: false,\n        max_level: 4,\n        outgoing_damage: 'illusion_2_damage_out_pct',\n        incoming_damage: 'illusion_2_damage_in_pct'\n    },\n    phantom_lancer_juxtapose: {\n        hero: 'phantom_lancer',\n        displayName: 'Phantom Lancer Juxtapose',\n        use_selected_hero: false,\n        max_level: 4,\n        outgoing_damage: 'illusion_damage_out_pct',\n        incoming_damage: 'illusion_damage_in_pct'\n    },\n    phantom_lancer_spirit_lance: {\n        hero: 'phantom_lancer',\n        displayName: 'Phantom Lancer Spirit Lance',\n        use_selected_hero: false,\n        max_level: 4,\n        outgoing_damage: 'illusion_damage_out_pct',\n        incoming_damage: 'illusion_damage_in_pct'\n    },\n    shadow_demon_disruption: {\n        hero: 'shadow_demon',\n        displayName: 'Shadow Demon Disruption',\n        use_selected_hero: true,\n        max_level: 4,\n        outgoing_damage: 'illusion_outgoing_damage',\n        incoming_damage: 'illusion_incoming_damage',\n        outgoing_damage_sign: -1\n    },\n    spectre_haunt: {\n        hero: 'spectre',\n        displayName: 'Spectre Haunt',\n        use_selected_hero: false,\n        max_level: 3,\n        outgoing_damage: 'illusion_damage_outgoing',\n        incoming_damage: 'illusion_damage_incoming',\n        outgoing_damage_sign: -1\n    },\n    terrorblade_conjure_image: {\n        hero: 'terrorblade',\n        displayName: 'Terrorblade Conjure Image',\n        use_selected_hero: false,\n        max_level: 4,\n        outgoing_damage: 'illusion_outgoing_damage',\n        incoming_damage: 'illusion_incoming_damage',\n        outgoing_damage_sign: -1\n    },\n    terrorblade_reflection: {\n        hero: 'terrorblade',\n        displayName: 'Terrorblade Reflection',\n        use_selected_hero: true,\n        max_level: 4,\n        outgoing_damage: 'illusion_outgoing_damage',\n        outgoing_damage_sign: -1\n    },\n    item_manta: {\n        hero: '',\n        is_item: true,\n        displayName: 'Manta Style Illusion',\n        use_selected_hero: true,\n        max_level: 1,\n        outgoing_damage_melee: 'images_do_damage_percent_melee',\n        incoming_damage_melee: 'images_take_damage_percent_melee',\n        outgoing_damage_ranged: 'images_do_damage_percent_ranged',\n        incoming_damage_ranged: 'images_take_damage_percent_ranged'\n    }\n}\n\nmodule.exports = illusionData;",
    "var ko = (typeof window !== \"undefined\" ? window['ko'] : typeof global !== \"undefined\" ? global['ko'] : null);\nvar stackableItems = require(\"./stackableItems\");\nvar levelItems = require(\"./levelItems\");\nvar itemsWithActive = require(\"./itemsWithActive\");\n\nvar BasicInventoryViewModel = function (h) {\n    var self = this;\n    self.items = ko.observableArray([]);\n    self.activeItems = ko.observableArray([]);\n    self.addItem = function (data, event) {\n        if (data.selectedItem() != undefined) {\n            var new_item = {\n                item: data.selectedItem().split('|')[0],\n                state: ko.observable(0),\n                size: data.itemInputValue(),\n                enabled: ko.observable(true)\n            }\n            switch (new_item.item) {\n                case 'dagon':\n                    new_item.size = Math.min(new_item.size, 5);\n                break;\n                break;\n                case 'travel_boots':\n                    new_item.size = Math.min(new_item.size, 2);\n                break;\n                case 'necronomicon':\n                    new_item.size = Math.min(new_item.size, 3);\n                break;\n            }\n            this.items.push(new_item);\n            if (data.selectedItem() === 'ring_of_aquila' || data.selectedItem() === 'ring_of_basilius' || data.selectedItem() === 'heart') {\n                this.toggleItem(undefined, new_item, undefined);\n            }\n        }\n    }.bind(this);\n    self.toggleItem = function (index, data, event) {\n        if (itemsWithActive.indexOf(data.item) >= 0) {\n            if (this.activeItems.indexOf(data) < 0) {\n                this.activeItems.push(data);\n            }\n            else {\n                this.activeItems.remove(data);\n            }\n            switch (data.item) {\n                case 'power_treads':\n                    if (data.state() < 2) {\n                        data.state(data.state() + 1);\n                    }\n                    else {\n                        data.state(0);\n                    }                \n                break;\n                default:\n                    if (data.state() == 0) {\n                        data.state(1);\n                    }\n                    else {\n                        data.state(0);\n                    }                \n                break;\n            }\n        }\n    }.bind(this);\n    self.removeItem = function (item) {\n        this.activeItems.remove(item);\n        this.items.remove(item);\n    }.bind(this);\n    self.toggleMuteItem = function (item) {\n        item.enabled(!item.enabled());\n    }.bind(this);\n    self.removeAll = function () {\n        this.activeItems.removeAll();\n        this.items.removeAll();\n    }.bind(this);\n}\nBasicInventoryViewModel.prototype.getItemImage = function (data) {\n    var state = ko.utils.unwrapObservable(data.state);\n    switch (data.item) {\n        case 'power_treads':\n            if (state == 0) {\n                return '/media/images/items/' + data.item + '_str.png';\n            }\n            else if (state == 1) {\n                return '/media/images/items/' + data.item + '_int.png';\n            }\n            else {\n                return '/media/images/items/' + data.item + '_agi.png';\n            }\n        break;\n        case 'tranquil_boots':\n        case 'ring_of_basilius':\n            if (state == 0) {\n                return '/media/images/items/' + data.item + '.png';\n            }\n            else {\n                return '/media/images/items/' + data.item + '_active.png';\n            }\n        break;\n        case 'armlet':\n            if (state == 0) {\n                return '/media/images/items/' + data.item + '.png';\n            }\n            else {\n                return '/media/images/items/' + data.item + '_active.png';\n            }\n        break;\n        case 'ring_of_aquila':\n            if (state == 0) {\n                return '/media/images/items/' + data.item + '_active.png';\n            }\n            else {\n                return '/media/images/items/' + data.item + '.png';\n            }\n        break;\n        case 'dagon':\n        case 'travel_boots':\n        case 'necronomicon':\n            if (data.size > 1) {\n                return '/media/images/items/' + data.item + '_' + data.size + '.png';\n            }\n            else {\n                return '/media/images/items/' + data.item + '.png';\n            }\n        break;\n        default:\n            return '/media/images/items/' + data.item + '.png';            \n        break;\n    }\n};\nBasicInventoryViewModel.prototype.getItemSizeLabel = function (data) {\n    if (stackableItems.indexOf(data.item) != -1) {\n        return '<span style=\"font-size:10px\">Qty: </span>' + data.size;\n    }\n    else if (levelItems.indexOf(data.item) != -1) {\n        return '<span style=\"font-size:10px\">Lvl: </span>' + data.size;\n    }\n    else if (data.item == 'bloodstone') {\n        return '<span style=\"font-size:10px\">Charges: </span>' + data.size;\n    }\n    else {\n        return '';\n    }\n};\nBasicInventoryViewModel.prototype.getActiveBorder = function (data) {\n    switch (data.item) {\n        case 'power_treads':\n        case 'tranquil_boots':\n        case 'ring_of_basilius':\n        case 'ring_of_aquila':\n        case 'armlet':\n            return 0;\n        break;\n        default:\n            return ko.utils.unwrapObservable(data.state);    \n        break;\n    }\n}\nBasicInventoryViewModel.prototype.getItemAttributeValue = function (attributes, attributeName, level) {\n    for (var i = 0; i < attributes.length; i++) {\n        if (attributes[i].name == attributeName) {\n            if (level == 0) {\n                return parseFloat(attributes[i].value[0]);\n            }\n            else if (level > attributes[i].value.length) {\n                return parseFloat(attributes[i].value[0]);\n            }\n            else {\n                return parseFloat(attributes[i].value[level - 1]);\n            }\n        }\n    }\n}\n\nmodule.exports = BasicInventoryViewModel;",
    "'use strict';\nvar ko = require('../herocalc_knockout');\n\nvar StatModel = require(\"../StatModel\");\nvar stackableItems = require(\"./stackableItems\");\nvar levelItems = require(\"./levelItems\");\nvar BasicInventoryViewModel = require(\"./BasicInventoryViewModel\");\nvar itemOptionsArray = require(\"./itemOptionsArray\");\nvar itemBuffOptions = require(\"./itemBuffOptions\");\nvar itemDebuffOptions = require(\"./itemDebuffOptions\");\n\nvar InventoryViewModel = function (itemData, h) {\n    var self = this;\n    BasicInventoryViewModel.call(this, h);\n    self.hero = h;\n    self.hasInventory = ko.observable(true);\n    self.items = ko.observableArray([]);\n    self.activeItems = ko.observableArray([]);\n    self.hasScepter = ko.pureComputed(function () {\n        for (var i = 0; i < self.items().length; i++) {\n            var item = self.items()[i].item;\n            if (item === 'ultimate_scepter' && self.items()[i].enabled()) {\n                return true;\n            }\n        }\n        return false;\n    }, this);\n    self.isEthereal = ko.pureComputed(function () {\n        for (var i = 0; i < self.items().length; i++) {\n            var item = self.items()[i].item;\n            var isActive = self.activeItems.indexOf(self.items()[i]) >= 0 ? true : false;\n            if ((item === 'ghost' || item === 'ethereal_blade') && self.items()[i].enabled() && isActive) {\n                return true;\n            }\n        }\n        return false;\n    }, this);\n    self.isSheeped = ko.pureComputed(function () {\n        for (var i = 0; i < self.items().length; i++) {\n            var item = self.items()[i].item;\n            var isActive = self.activeItems.indexOf(self.items()[i]) >= 0 ? true : false;\n            if (item === 'sheepstick' && self.items()[i].enabled() && isActive) {\n                return true;\n            }\n        }\n        return false;\n    }, this);\n    self.totalCost = ko.pureComputed(function () {\n        var c = 0;\n        for (var i = 0; i < self.items().length; i++) {\n            var item = self.items()[i].item;\n            if (!self.items()[i].enabled()) continue;\n            if (stackableItems.indexOf(item) != -1) {\n                c += itemData['item_' + item].itemcost * self.items()[i].size;\n            }\n            else if (levelItems.indexOf(item) != -1) {\n                switch(item) {\n                    case 'travel_boots':\n                    case 'necronomicon':\n                    case 'dagon':\n                        c += itemData['item_' + item].itemcost + (self.items()[i].size - 1) * itemData['item_recipe_' + item].itemcost;\n                    break;\n                    default:\n                        c += itemData['item_' + item].itemcost;\n                    break;\n                }\n            }\n            else {\n                c += itemData['item_' + item].itemcost;\n            }\n            \n        }\n        return c;\n    }, this);\n    self.addItemBuff = function (data, event) {\n        if (self.hasInventory() && self.selectedItemBuff() != undefined) {\n            var new_item = {\n                item: self.selectedItemBuff().split('|')[0],\n                state: ko.observable(0),\n                size: 1,\n                enabled: ko.observable(true)\n            }\n            if (self.selectedItemBuff().split('|').length == 2) {\n                new_item.buff = self.selectedItemBuff().split('|')[1]\n            }\n            self.items.push(new_item);\n            if (self.selectedItemBuff() === 'ring_of_aquila' || self.selectedItemBuff() === 'ring_of_basilius') {\n                self.toggleItem(undefined, new_item, undefined);\n            }\n        }\n    };\n    self.addItemDebuff = function (data, event) {\n        if (self.hasInventory() && self.selectedItemDebuff() != undefined) {\n            var new_item = {\n                item: self.selectedItemDebuff().split('|')[0],\n                state: ko.observable(0),\n                size: 1,\n                enabled: ko.observable(true)\n            }\n            if (self.selectedItemDebuff().split('|').length == 2) {\n                new_item.debuff = self.selectedItemDebuff().split('|')[1]\n            }\n            self.items.push(new_item);\n            if (self.selectedItemDebuff() === 'ring_of_aquila' || self.selectedItemDebuff() === 'ring_of_basilius') {\n                self.toggleItem(undefined, new_item, undefined);\n            }\n        }\n    };\n    \n    self.getAttributes = function (attributeType) {\n        var sources = new StatModel();\n        for (var i = 0; i < self.items().length; i++) {\n            var itemId = self.items()[i].item;\n            var isActive = self.activeItems.indexOf(self.items()[i]) >= 0 ? true : false;\n            if (!self.items()[i].enabled()) continue;\n            var size = self.items()[i].size;\n            var item = itemData['item_' + itemId];\n            for (var j = 0; j < item.attributes.length; j++) {\n                var attribute = item.attributes[j];\n                switch(attribute.name) {\n                    case 'bonus_all_stats':\n                        sources.add(parseInt(attribute.value[0]), item.displayname);\n                    break;\n                    case 'bonus_stats':\n                        sources.add(parseInt(attribute.value[0]), item.displayname);\n                    break;\n                }\n                switch(attributeType) {\n                    case 'agi':\n                        switch(attribute.name) {\n                            case 'bonus_agility':\n                            case 'bonus_agi':\n                                sources.add(parseInt(attribute.value[0]), item.displayname);\n                            break;\n                            case 'bonus_stat':\n                                if (self.items()[i].state() == 2) {\n                                    sources.add(parseInt(attribute.value[0]), item.displayname);\n                                }\n                            break;\n                        }\n                    break;\n                    case 'int':\n                        switch(attribute.name) {\n                            case 'bonus_intellect':\n                                if (itemId == 'necronomicon') {\n                                    sources.add(parseInt(attribute.value[size-1]), item.displayname);\n                                }\n                                else if (itemId == 'dagon') {\n                                    sources.add(parseInt(attribute.value[size-1]), item.displayname);\n                                }\n                                else {\n                                    sources.add(parseInt(attribute.value[0]), item.displayname);\n                                }\n                            break;\n                            case 'bonus_intelligence':\n                            case 'bonus_int':\n                                sources.add(parseInt(attribute.value[0]), item.displayname);\n                            break;\n                            case 'bonus_stat':\n                                if (self.items()[i].state() == 1) {\n                                    sources.add(parseInt(attribute.value[0]), item.displayname);\n                                }\n                            break;\n                        }\n                    break;\n                    case 'str':\n                        switch(attribute.name) {\n                            case 'bonus_strength':\n                                if (itemId == 'necronomicon') {\n                                    sources.add(parseInt(attribute.value[size-1]), item.displayname);\n                                }\n                                else {\n                                    sources.add(parseInt(attribute.value[0]), item.displayname);\n                                }\n                            break;\n                            case 'bonus_str':\n                                sources.add(parseInt(attribute.value[0]), item.displayname);\n                            break;\n                            case 'bonus_stat':\n                                if (self.items()[i].state() == 0) {\n                                    sources.add(parseInt(attribute.value[0]), item.displayname);\n                                }\n                            break;\n                            case 'unholy_bonus_strength':\n                                if (isActive) {\n                                    sources.add(parseInt(attribute.value[0]), item.displayname);\n                                }\n                            break;\n                        }\n                    break;\n                }\n            }\n        }\n        console.log('getAttributes', sources);\n        return sources;\n    };\n    \n    self.getBash = function (attacktype) {\n        var totalAttribute = 1;\n        for (var i = 0; i < self.items().length; i++) {\n            var item = self.items()[i].item;\n            if (!self.items()[i].enabled()) continue;\n            for (var j = 0; j < itemData['item_' + item].attributes.length; j++) {\n                var attribute = itemData['item_' + item].attributes[j];\n                switch(attribute.name) {\n                    case 'bash_chance':\n                        totalAttribute *= (1 - parseInt(attribute.value[0]) / 100);\n                    break;\n                    case 'bash_chance_melee':\n                        if (attacktype == 'DOTA_UNIT_CAP_MELEE_ATTACK') { totalAttribute *= (1 - parseInt(attribute.value[0]) / 100); };\n                    break;\n                    case 'bash_chance_ranged':\n                        if (attacktype == 'DOTA_UNIT_CAP_RANGED_ATTACK') { totalAttribute *= (1 - parseInt(attribute.value[0]) / 100); };\n                    break;\n                }\n            }\n        }\n        return totalAttribute;\n    };\n    \n    self.getCritChance = function () {\n        var totalAttribute = 1;\n        for (var i = 0; i < self.items().length; i++) {\n            var item = self.items()[i].item;\n            var isActive = self.activeItems.indexOf(self.items()[i]) >= 0 ? true : false;\n            if (!self.items()[i].enabled()) continue;\n            for (var j = 0; j < itemData['item_' + item].attributes.length; j++) {\n                var attribute = itemData['item_' + item].attributes[j];\n                switch(attribute.name) {\n                    case 'crit_chance':\n                        totalAttribute *= (1 - parseInt(attribute.value[0]) / 100);\n                    break;\n                }\n            }\n        }\n        return totalAttribute;\n    };\n    \n    self.getCritSource = function () {\n        var sources = {};\n        for (var i = 0; i < self.items().length; i++) {\n            var item = self.items()[i].item;\n            var isActive = self.activeItems.indexOf(self.items()[i]) >= 0 ? true : false;\n            if (!self.items()[i].enabled()) continue;\n            switch (item) {\n                case 'lesser_crit':\n                case 'greater_crit':\n                case 'bloodthorn':\n                    if (sources[item] == undefined) {\n                        sources[item] = {\n                            'chance': self.getItemAttributeValue(itemData['item_' + item].attributes, 'crit_chance', 0) / 100,\n                            'multiplier': self.getItemAttributeValue(itemData['item_' + item].attributes, 'crit_multiplier', 0) / 100,\n                            'count': 1,\n                            'displayname': itemData['item_' + item].displayname\n                        }\n                    }\n                    else {\n                        sources[item].count += 1;\n                    }\n                break;\n            }\n            if (item === 'bloodthorn' && isActive) {\n                if (sources['soul_rend'] == undefined) {\n                    sources['soul_rend'] = {\n                        'chance': 1,\n                        'multiplier': self.getItemAttributeValue(itemData['item_' + item].attributes, 'target_crit_multiplier', 0) / 100,\n                        'count': 1,\n                        'displayname': 'Soul Rend'\n                    }\n                }\n                else {\n                    sources['soul_rend'].count += 1;\n                }\n            }\n        }\n        return sources;\n    };\n\n    self.getCleaveSource = function () {\n        var sources = {};\n        for (var i = 0; i < self.items().length; i++) {\n            var item = self.items()[i].item;\n            var isActive = self.activeItems.indexOf(self.items()[i]) >= 0 ? true : false;\n            if (!self.items()[i].enabled()) continue;\n            switch (item) {\n                case 'bfury':\n                    if (sources[item] == undefined) {\n                        sources[item] = {\n                            'radius': self.getItemAttributeValue(itemData['item_' + item].attributes, 'cleave_radius', 0),\n                            'magnitude': self.getItemAttributeValue(itemData['item_' + item].attributes, 'cleave_damage_percent', 0) / 100,\n                            'count': 1,\n                            'displayname': itemData['item_' + item].displayname\n                        }\n                    }\n                    else {\n                        sources[item].count += 1;\n                    }\n                break;\n            }\n\n        }\n        return sources;\n    };\n    \n    self.getAccuracyDebuffSource = function () {\n        var sources = {};\n        for (var i = 0; i < self.items().length; i++) {\n            var item = self.items()[i].item;\n            var isActive = self.activeItems.indexOf(self.items()[i]) >= 0 ? true : false;\n            if (!self.items()[i].enabled()) continue;\n            switch (item) {\n                case 'bloodthorn':\n                    if (sources[item] == undefined) {\n                        sources[item] = {\n                            'chance': 1,\n                            'count': 1,\n                            'displayname': 'Soul Rend'\n                        }\n                    }\n                break;\n                case 'solar_crest':\n                    if (sources[item] == undefined) {\n                        sources[item] = {\n                            'chance': self.getItemAttributeValue(itemData['item_' + item].attributes, 'truestrike_chance', 0) / 100,\n                            'count': 1,\n                            'displayname': 'Shine'\n                        }\n                    }\n                break;\n            }\n\n        }\n        return sources;\n    };\n    \n    self.getAccuracySource = function (attacktype) {\n        var sources = {};\n        for (var i = 0; i < self.items().length; i++) {\n            var item = self.items()[i].item;\n            var isActive = self.activeItems.indexOf(self.items()[i]) >= 0 ? true : false;\n            if (!self.items()[i].enabled()) continue;\n            switch (item) {\n                case 'javelin':\n                    if (sources[item] == undefined) {\n                        sources[item] = {\n                            'chance': self.getItemAttributeValue(itemData['item_' + item].attributes, 'bonus_chance', 0) / 100,\n                            'count': 1,\n                            'displayname': itemData['item_' + item].displayname + ' Pierce'\n                        }\n                    }\n                    else {\n                        sources[item].count += 1;\n                    }\n                break;\n                case 'monkey_king_bar':\n                    if (sources[item] == undefined) {\n                        sources[item] = {\n                            'chance': self.getItemAttributeValue(itemData['item_' + item].attributes, 'bonus_chance', 0) / 100,\n                            'count': 1,\n                            'displayname': itemData['item_' + item].displayname + ' Pierce'\n                        }\n                    }\n                break;\n                case 'abyssal_blade':\n                case 'basher':\n                    if (!sources.hasOwnProperty('bash')) {\n                        sources['bash'] = {\n                            'chance': self.getItemAttributeValue(itemData['item_' + item].attributes, (attacktype == 'DOTA_UNIT_CAP_MELEE_ATTACK') ?'bash_chance_melee' : 'bash_chance_ranged', 0) / 100,\n                            'count': 1,\n                            'displayname': 'Bash'\n                        }\n                    }\n                break;\n            }\n\n        }\n        return sources;\n    };\n    \n    self.getBashSource = function (attacktype) {\n        var sources = {};\n        for (var i = 0; i < self.items().length; i++) {\n            var item = self.items()[i].item;\n            var isActive = self.activeItems.indexOf(self.items()[i]) >= 0 ? true : false;\n            if (!self.items()[i].enabled()) continue;\n            switch (item) {\n                case 'abyssal_blade':\n                case 'basher':\n                    if (!sources.hasOwnProperty('bash')) {\n                        sources['bash'] = {\n                            'item': item,\n                            'chance': self.getItemAttributeValue(itemData['item_' + item].attributes, (attacktype == 'DOTA_UNIT_CAP_MELEE_ATTACK') ?'bash_chance_melee' : 'bash_chance_ranged', 0) / 100,\n                            'damage': self.getItemAttributeValue(itemData['item_' + item].attributes, 'bonus_chance_damage', 0),\n                            'duration': self.getItemAttributeValue(itemData['item_' + item].attributes, 'bash_duration', 0),\n                            'count': 1,\n                            'damageType': 'physical',\n                            'displayname': 'Bash' //itemData['item_' + item].displayname\n                        }\n                    }\n                    else {\n                        //sources[item].count += 1;\n                    }\n                break;\n            }\n\n        }\n        return sources;\n    };\n    \n    self.getOrbProcSource = function () {\n        var sources = {};\n        for (var i = 0; i < self.items().length; i++) {\n            var item = self.items()[i].item;\n            var isActive = self.activeItems.indexOf(self.items()[i]) >= 0 ? true : false;\n            if (!self.items()[i].enabled()) continue;\n            switch (item) {\n                case 'javelin':\n                    if (sources[item] == undefined) {\n                        sources[item] = {\n                            'chance': self.getItemAttributeValue(itemData['item_' + item].attributes, 'bonus_chance', 0) / 100,\n                            'damage': self.getItemAttributeValue(itemData['item_' + item].attributes, 'bonus_chance_damage', 0),\n                            'damageType': 'magic',\n                            'count': 1,\n                            'displayname': itemData['item_' + item].displayname + ' Pierce'\n                        }\n                    }\n                    else {\n                        sources[item].count += 1;\n                    }\n                break;\n                case 'monkey_king_bar':\n                    if (sources[item] == undefined) {\n                        sources[item] = {\n                            'chance': self.getItemAttributeValue(itemData['item_' + item].attributes, 'bonus_chance', 0) / 100,\n                            'damage': self.getItemAttributeValue(itemData['item_' + item].attributes, 'bonus_chance_damage', 0),\n                            'count': 1,\n                            'damageType': 'pure',\n                            'displayname': itemData['item_' + item].displayname + ' Pierce'\n                        }\n                    }\n                break;\n                case 'maelstrom':\n                case 'mjollnir':\n                    if (sources[item] == undefined) {\n                        sources[item] = {\n                            'chance': self.getItemAttributeValue(itemData['item_' + item].attributes, 'chain_chance', 0) / 100,\n                            'damage': self.getItemAttributeValue(itemData['item_' + item].attributes, 'chain_damage', 0),\n                            'count': 1,\n                            'damageType': 'magic',\n                            'displayname': 'Chain Lightning'\n                        }\n                    }\n                break;\n            }\n\n        }\n        return sources;\n    };\n\n    self.getOrbSource = function () {\n        var sources = {};\n        for (var i = 0; i < self.items().length; i++) {\n            var item = self.items()[i].item;\n            var isActive = self.activeItems.indexOf(self.items()[i]) >= 0 ? true : false;\n            if (!self.items()[i].enabled()) continue;\n            switch (item) {\n                case 'diffusal_blade':\n                    if (sources[item] == undefined) {\n                        sources[item] = {\n                            'chance': 1,\n                            'damage': self.getItemAttributeValue(itemData['item_' + item].attributes, 'feedback_mana_burn', self.items()[i].size),\n                            'count': 1,\n                            'damageType': 'physical',\n                            'displayname': itemData['item_' + item].displayname\n                        }\n                    }\n                    else {\n                        sources[item].count += 1;\n                    }\n                break;\n            }\n\n        }\n        return sources;\n    };\n    \n    self.getHealth = function () {\n        var sources = new StatModel();\n        for (var i = 0; i < self.items().length; i++) {\n            var itemId = self.items()[i].item;\n            if (!self.items()[i].enabled()) continue;\n            var item = itemData['item_' + itemId];\n            for (var j = 0; j < item.attributes.length; j++) {\n                var attribute = item.attributes[j];\n                switch(attribute.name) {\n                    case 'bonus_health':\n                        sources.add(parseInt(attribute.value[0]), item.displayname);\n                    break;\n                }\n            }\n        }\n        return sources;\n    };\n    self.getHealthRegen = function () {\n        var sources = new StatModel();\n        for (var i = 0; i < self.items().length; i++) {\n            var itemId = self.items()[i].item;\n            var isActive = self.activeItems.indexOf(self.items()[i]) >= 0 ? true : false;\n            if (!self.items()[i].enabled()) continue;\n            var item = itemData['item_' + itemId];\n            for (var j = 0; j < item.attributes.length; j++) {\n                var attribute = item.attributes[j];\n                switch(attribute.name) {\n                    case 'health_regen':\n                    case 'bonus_regen':\n                    case 'hp_regen':\n                        sources.add(parseInt(attribute.value[0]), item.displayname);\n                    break;\n                    case 'bonus_health_regen':\n                        if (itemId == 'tranquil_boots' && !isActive) {\n                            sources.add(parseInt(attribute.value[0]), item.displayname);\n                        }\n                        else if (itemId != 'tranquil_boots') {\n                            sources.add(parseInt(attribute.value[0]), item.displayname);\n                        }\n                    break;\n                    case 'health_regen_rate':\n                        if (itemId == 'heart' && isActive) {\n                            sources.add((parseInt(attribute.value[0]) / 100) * self.hero.health().total, item.displayname);\n                        }\n                    break;\n                }\n            }\n        }\n        return sources;\n    };\n    self.getHealthRegenAura = function (sources, e) {\n        var excludeList = e || [];\n        sources = sources || new StatModel();\n        for (var i = 0; i < self.items().length; i++) {\n            var itemId = self.items()[i].item;\n            var isActive = self.activeItems.indexOf(self.items()[i]) >= 0 ? true : false;\n            if (!self.items()[i].enabled()) continue;\n            var item = itemData['item_' + itemId];\n            for (var j = 0; j < item.attributes.length; j++) {\n                var attribute = item.attributes[j];\n                if (excludeList.indexOf(itemId + attribute.name) > -1) continue;\n                switch(attribute.name) {\n                    case 'aura_health_regen':\n                    case 'hp_regen_aura':\n                        sources.add(parseInt(attribute.value[0]), item.displayname);\n                        excludeList.push(itemId + attribute.name);\n                    break;\n                }\n            }\n        }\n        return { sources: sources, excludeList: excludeList };\n    };\n    \n    self.getMana = function () {\n        var sources = new StatModel();\n        for (var i = 0; i < self.items().length; i++) {\n            var itemId = self.items()[i].item;\n            if (!self.items()[i].enabled()) continue;\n            var item = itemData['item_' + itemId];\n            for (var j = 0; j < item.attributes.length; j++) {\n                var attribute = item.attributes[j];\n                switch(attribute.name) {\n                    case 'bonus_mana':\n                        sources.add(parseInt(attribute.value[0]), item.displayname);\n                    break;\n                }\n            }\n        }\n        return sources;\n    };\n    \n    self.getManaRegen = function () {\n        var sources = new StatModel();\n        for (var i = 0; i < self.items().length; i++) {\n            var itemId = self.items()[i].item;\n            if (!self.items()[i].enabled()) continue;\n            var item = itemData['item_' + itemId];\n            for (var j = 0; j < item.attributes.length; j++) {\n                var attribute = item.attributes[j];\n                switch(attribute.name) {\n                    case 'aura_mana_regen':\n                    case 'mana_regen_aura':\n                        sources.add(parseInt(attribute.value[0]), item.displayname);\n                    break;\n                    case 'mana_regen':\n                        if (itemId == 'infused_raindrop') {\n                            sources.add(parseInt(attribute.value[0]), item.displayname);\n                        }\n                    break;\n                }\n            }\n        }\n        return sources;\n    };\n    self.getManaRegenPercent = function () {\n        var totalAttribute = 0;\n        for (var i = 0; i < self.items().length; i++) {\n            var item = self.items()[i].item;\n            if (!self.items()[i].enabled()) continue;\n            for (var j = 0; j < itemData['item_' + item].attributes.length; j++) {\n                var attribute = itemData['item_' + item].attributes[j];\n                switch(attribute.name) {\n                    case 'bonus_mana_regen':\n                    case 'mana_regen':\n                    case 'bonus_mana_regen_pct':\n                        if (item != 'infused_raindrop') totalAttribute += parseFloat(attribute.value[0]);\n                    break;\n                }\n            }\n        }\n        return totalAttribute / 100;    \n    };\n    self.getManaRegenBloodstone = function () {\n        for (var i = 0; i < self.items().length; i++) {\n            var item = self.items()[i].item;\n            if (!self.items()[i].enabled()) continue;\n            if (item.indexOf('bloodstone') != -1) {\n                return new StatModel(parseInt(self.items()[i].size), itemData['item_' + item].displayname);\n            }\n        }\n        return new StatModel();\n    };\n    \n    self.getArmor = function () {\n        var sources = new StatModel();\n        for (var i = 0; i < self.items().length; i++) {\n            var itemId = self.items()[i].item;\n            var isActive = self.activeItems.indexOf(self.items()[i]) >= 0 ? true : false;\n            if (!self.items()[i].enabled()) continue;\n            var item = itemData['item_' + itemId];\n            for (var j = 0; j < item.attributes.length; j++) {\n                var attribute = item.attributes[j];\n                switch(attribute.name) {\n                    case 'bonus_armor':\n                        if (!isActive || (itemId != 'medallion_of_courage' && itemId != 'solar_crest')) {\n                            sources.add(parseInt(attribute.value[0]), item.displayname, attribute.name);\n                        };\n                    break;\n                    case 'unholy_bonus_armor':\n                        if (isActive && itemId == 'armlet') {\n                            sources.add(parseInt(attribute.value[0]), item.displayname, attribute.name);\n                        };\n                    break;\n                }\n            }\n        }\n        \n        return sources;\n    };\n    \n    self.getArmorAura = function (sources) {     \n        sources = sources || new StatModel();\n        for (var i = 0; i < self.items().length; i++) {\n            var itemId = self.items()[i].item;\n            var isActive = self.activeItems.indexOf(self.items()[i]) >= 0 ? true : false;\n            if (!self.items()[i].enabled()) continue;\n            var item = itemData['item_' + itemId];\n            for (var j = 0;j < item.attributes.length; j++) {\n                var attribute = item.attributes[j];\n                if (sources.components.find(function (a) { return attribute.name == a.id; })) continue;\n                switch(attribute.name) {\n                    // buckler\n                    case 'bonus_aoe_armor':\n                        if (isActive) {\n                            sources.push(parseInt(attribute.value[0]), item.displayname, attribute.name);\n                        }\n                    break;\n                    // assault\n                    case 'aura_positive_armor':\n                        sources.push(parseInt(attribute.value[0]), item.displayname, attribute.name);\n                    break;\n                    // ring_of_aquila,ring_of_basilius\n                    case 'aura_bonus_armor':\n                        if (isActive) {\n                            sources.push(parseInt(attribute.value[0]), item.displayname, attribute.name);\n                        }\n                    break;\n                    // vladmir\n                    case 'armor_aura':\n                        sources.push(parseInt(attribute.value[0]), item.displayname, attribute.name);\n                    break;\n                    // mekansm\n                    case 'heal_bonus_armor':\n                        if (isActive) {\n                            sources.push(parseInt(attribute.value[0]), item.displayname, attribute.name);\n                        }\n                    break;\n                }\n            }\n        }\n        // remove buckler if there is a mekansm\n        if (sources.components.find(function (attribute) { return attribute.id == 'heal_bonus_armor'; })) {\n            sources.components = sources.components.filter(function (attribute) {\n                return attribute.id !== 'bonus_aoe_armor';\n            });\n        }\n        // remove ring_of_aquila,ring_of_basilius if there is a vladmir\n        if (sources.components.find(function (attribute) { return attribute.id == 'armor_aura'; })) {\n            sources.components = sources.components.filter(function (attribute) {\n                return attribute.id !== 'aura_bonus_armor';\n            });\n        }\n        \n        sources.total = sources.components.reduce(function (memo, attribute) {\n            return memo += attribute.value;\n        }, 0);\n        \n        return sources;\n    };\n    self.getArmorReduction = function (sources) {\n        sources = sources || new StatModel();\n        for (var i = 0; i < self.items().length; i++) {\n            var itemId = self.items()[i].item;\n            var isActive = self.activeItems.indexOf(self.items()[i]) >= 0 ? true : false;\n            if (!self.items()[i].enabled()) continue;\n            var item = itemData['item_' + itemId];\n            for (var j = 0; j < item.attributes.length; j++) {\n                var attribute = item.attributes[j];\n                if (sources.components.find(function (component) { return component.id == attribute.name }) || sources.components.find(function (component) { return component.id == itemId + '_' + attribute.name })) continue;\n                switch(attribute.name) {\n                    case 'armor_reduction':\n                        if (isActive || (itemId != 'medallion_of_courage' && itemId != 'solar_crest')) {\n                            sources.push(parseInt(attribute.value[0]), item.displayname, itemId + '_' + attribute.name);\n                        }\n                    break;\n                    case 'corruption_armor':\n                        sources.push(parseInt(attribute.value[0]), item.displayname, itemId + '_' + attribute.name);\n                    break;\n                }\n            }\n        }\n        \n        sources.total = sources.components.reduce(function (memo, attribute) {\n            return memo += attribute.value;\n        }, 0);\n        \n        return sources;\n    };\n    self.getArmorReductionAura = function (sources) {\n        sources = sources || new StatModel();\n        for (var i = 0; i < self.items().length; i++) {\n            var itemId = self.items()[i].item;\n            var isActive = self.activeItems.indexOf(self.items()[i]) >= 0 ? true : false;\n            if (!self.items()[i].enabled()) continue;\n            var item = itemData['item_' + itemId];\n            for (var j = 0; j < item.attributes.length; j++) {\n                var attribute = item.attributes[j];\n                if (sources.components.find(function (component) { return component.id == attribute.name }) || sources.components.find(function (component) { return component.id == itemId + '_' + attribute.name })) continue;\n                switch(attribute.name) {\n                    case 'aura_negative_armor':\n                        sources.push(parseInt(attribute.value[0]), item.displayname, itemId + '_' + attribute.name);\n                    break;\n                }\n            }\n        }\n        \n        sources.total = sources.components.reduce(function (memo, attribute) {\n            return memo += attribute.value;\n        }, 0);\n        \n        return sources;\n    };\n    self.getEvasion = function () {\n        var totalAttribute = 1;\n        for (var i = 0; i < self.items().length; i++) {\n            var item = self.items()[i].item;\n            var isActive = self.activeItems.indexOf(self.items()[i]) >= 0 ? true : false;\n            if (!self.items()[i].enabled()) continue;\n            for (var j = 0; j < itemData['item_' + item].attributes.length; j++) {\n                var attribute = itemData['item_' + item].attributes[j];\n                switch(attribute.name) {\n                    case 'bonus_evasion':\n                        if (!isActive || (item != 'solar_crest')) { totalAttribute *= (1 - parseInt(attribute.value[0]) / 100); }\n                    break;\n                }\n            }\n        }\n        return totalAttribute;\n    };\n    self.getMovementSpeedFlat = function (e) {\n        var totalAttribute = 0,\n        excludeList = e || [],\n        hasBoots = false,\n        hasEuls = false,\n        hasWindLace = false,\n        hasDrums = false,\n        bootItems = ['boots','phase_boots','arcane_boots','travel_boots','power_treads','tranquil_boots','guardian_greaves'];\n        for (var i = 0; i < self.items().length; i++) {\n            var item = self.items()[i].item;\n            var isActive = self.activeItems.indexOf(self.items()[i]) >= 0 ? true : false;\n            if (!self.items()[i].enabled()) continue;\n            for (var j = 0; j < itemData['item_' + item].attributes.length; j++) {\n                var attribute = itemData['item_' + item].attributes[j];\n                if (excludeList.indexOf(attribute.name) > -1) continue;\n                switch(attribute.name) {\n                    case 'bonus_movement_speed':\n                        if (!hasBoots && bootItems.indexOf(item) >= 0) {\n                            if (item != 'tranquil_boots' || (item == 'tranquil_boots' && !isActive)) {\n                                totalAttribute += parseInt(attribute.value[0]);\n                                hasBoots = true;\n                            }\n                        }\n                        //else if (!hasEuls && item == 'cyclone') {\n                        else if (item == 'cyclone') {\n                            totalAttribute += parseInt(attribute.value[0]);\n                            hasEuls = true;\n                        }\n                    break;\n                    case 'broken_movement_speed':\n                        if (!hasBoots && bootItems.indexOf(item) >= 0) {\n                            if (item == 'tranquil_boots' && isActive) {\n                                totalAttribute += parseInt(attribute.value[0]);\n                                hasBoots = true;\n                            }\n                        }\n                    break;\n                    case 'bonus_movement':\n                        if (!hasBoots && bootItems.indexOf(item) >= 0) {\n                            totalAttribute += parseInt(attribute.value[0]);\n                            hasBoots = true;\n                        }\n                    break;\n                    case 'movement_speed':\n                        if (!hasWindLace && item == 'wind_lace') {\n                            totalAttribute += parseInt(attribute.value[0]);\n                            hasWindLace = true;\n                        }\n                    break;\n                    case 'bonus_aura_movement_speed':\n                        if (!hasDrums && item == 'ancient_janggo') {\n                            totalAttribute += parseInt(attribute.value[0]);\n                            hasDrums = true;\n                            excludeList.push(attribute.name);\n                        }\n                    break;\n                }\n            }\n        }\n        return {value: totalAttribute, excludeList: excludeList};\n    };\n    self.getMovementSpeedPercent = function (e) {\n        var totalAttribute = 0,\n            excludeList = e || [],\n            hasYasha = false,\n            hasDrumsActive = false,\n            hasPhaseActive = false,\n            hasShadowBladeActive = false,\n            hasButterflyActive = false,\n            hasMoMActive = false,\n            yashaItems = ['manta','yasha','sange_and_yasha'];\n        for (var i = 0; i < self.items().length; i++) {\n            var item = self.items()[i].item;\n            var isActive = self.activeItems.indexOf(self.items()[i]) >= 0 ? true : false;\n            if (!self.items()[i].enabled()) continue;\n            for (var j = 0; j < itemData['item_' + item].attributes.length; j++) {\n                var attribute = itemData['item_' + item].attributes[j];\n                if (excludeList.indexOf(attribute.name) > -1) continue;\n                switch(attribute.name) {\n                    case 'movement_speed_percent_bonus':\n                        if (!hasYasha && yashaItems.indexOf(item) >= 0) {\n                            totalAttribute += parseInt(attribute.value[0]);\n                            hasYasha = true;\n                        }\n                    break;\n                    case 'phase_movement_speed':\n                        if (isActive && !hasPhaseActive) {\n                            totalAttribute += parseInt(attribute.value[0]);\n                            hasPhaseActive = true;\n                        }\n                    break;\n                    case 'bonus_movement_speed_pct':\n                        if (isActive && !hasDrumsActive && item == 'ancient_janggo') {\n                            totalAttribute += parseInt(attribute.value[0]);\n                            hasDrumsActive = true;\n                            excludeList.push(attribute.name);\n                        }\n                    break;\n                    case 'windwalk_movement_speed':\n                        if (isActive && !hasShadowBladeActive && (item == 'invis_sword' || item == 'silver_edge')) {\n                            totalAttribute += parseInt(attribute.value[0]);\n                            hasShadowBladeActive = true;\n                        }\n                    break;\n                    case 'berserk_bonus_movement_speed':\n                        if (isActive && !hasMoMActive && item == 'mask_of_madness') {\n                            totalAttribute += parseInt(attribute.value[0]);\n                            hasMoMActive = true;\n                        }\n                    break;\n                    case 'bonus_movement_speed': //manta\n                        if (!hasYasha && item == 'manta') {\n                            totalAttribute += parseInt(attribute.value[0]);\n                            hasYasha = true;\n                        }\n                        else if (item == 'smoke_of_deceit' && isActive) {\n                            totalAttribute += parseInt(attribute.value[0]);\n                        }\n                    break;\n                    case 'bonus_move_speed':\n                        if (isActive && !hasButterflyActive && item == 'butterfly') {\n                            totalAttribute += parseInt(attribute.value[0]);\n                            hasButterflyActive = true;\n                        }\n                    break;\n                }\n            }\n        }\n        return {value: totalAttribute/100, excludeList: excludeList};\n    };\n    \n    self.getMovementSpeedPercentReduction = function (e) {\n        var totalAttribute = 0,\n            excludeList = e || [];\n        for (var i = 0; i < self.items().length; i++) {\n            var item = self.items()[i].item;\n            var isActive = self.activeItems.indexOf(self.items()[i]) >= 0 ? true : false;\n            if (!self.items()[i].enabled()) continue;\n            for (var j = 0; j < itemData['item_' + item].attributes.length; j++) {\n                var attribute = itemData['item_' + item].attributes[j];\n                if (excludeList.indexOf(attribute.name) > -1) continue;\n                switch(attribute.name) {\n                    case 'movespeed':\n                        if (item == 'dust' && isActive) {\n                            totalAttribute += parseInt(attribute.value[0]);\n                        }\n                    case 'blast_movement_speed':\n                        if (item == 'shivas_guard' && isActive) {\n                            totalAttribute += parseInt(attribute.value[0]);\n                            excludeList.push(attribute.name);\n                        }\n                    case 'cold_movement_speed':\n                        if (item == 'skadi') {\n                            totalAttribute += parseInt(attribute.value[0]);\n                        }\n                    break;\n                    case 'maim_movement_speed':\n                        if (self.items()[i].debuff && self.items()[i].debuff == 'maim') {\n                            totalAttribute += parseInt(attribute.value[0]);\n                            excludeList.push(attribute.name);\n                        }\n                    break;\n                }\n            }\n        }\n        return {value: totalAttribute/100, excludeList: excludeList};\n    };\n    \n    self.getBonusDamage = function () {\n        var totalAttribute = 0;\n        var sources = {};\n        for (var i = 0; i < self.items().length; i++) {\n            var item = self.items()[i].item;\n            var isActive = self.activeItems.indexOf(self.items()[i]) >= 0 ? true : false;\n            if (!self.items()[i].enabled()) continue;\n            for (var j = 0; j < itemData['item_' + item].attributes.length; j++) {\n                var attribute = itemData['item_' + item].attributes[j];\n                switch(attribute.name) {\n                    case 'bonus_damage':\n                        totalAttribute += parseInt(attribute.value[0]);\n                        if (sources[item] == undefined) {\n                            sources[item] = {\n                                'damage': parseInt(attribute.value[0]),\n                                'damageType': 'physical',\n                                'count':1,\n                                'displayname': itemData['item_' + item].displayname\n                            }                            \n                        }\n                        else {\n                            sources[item].count += 1;\n                        }\n                    break;\n                    case 'unholy_bonus_damage':\n                        if (isActive) {\n                            totalAttribute += parseInt(attribute.value[0]);\n                            if (sources[item + '_active'] == undefined) {\n                                sources[item + '_active'] = {\n                                    'damage': parseInt(attribute.value[0]),\n                                    'damageType': 'physical',\n                                    'count':1,\n                                    'displayname': itemData['item_' + item].displayname + ' Unholy Strength'\n                                }                            \n                            }\n                            else {\n                                sources[item].count += 1;\n                            }\n                        }\n                    break;\n                }\n            }\n        }\n        return { sources: sources, total: totalAttribute };\n    };\n    self.getBonusDamagePercent = function (s) {\n        s = s || {sources:{},total:0};\n        var totalAttribute = s.total || 0;\n        var sources = s.sources || {};\n        for (var i = 0; i < self.items().length; i++) {\n            var item = self.items()[i].item;\n            var isActive = self.activeItems.indexOf(self.items()[i]) >= 0 ? true : false;\n            if (!self.items()[i].enabled()) continue;\n            for (var j = 0; j < itemData['item_' + item].attributes.length; j++) {\n                var attribute = itemData['item_' + item].attributes[j];\n                switch(attribute.name) {\n                    case 'damage_aura':\n                        if (sources[item] == undefined) {\n                            totalAttribute += parseInt(attribute.value[0]) / 100;\n                            sources[item] = {\n                                'damage': parseInt(attribute.value[0]) / 100,\n                                'damageType': 'physical',\n                                'count':1,\n                                'displayname': itemData['item_' + item].displayname\n                            }\n                        }\n                        // else {\n                            // sources[item].count += 1;\n                        // }\n                    break;\n                    case 'bottle_doubledamage':\n                        if (sources[item] == undefined) {\n                            totalAttribute += parseInt(attribute.value[0]) / 100;\n                            sources[item] = {\n                                'damage': parseInt(attribute.value[0]) / 100,\n                                'damageType': 'physical',\n                                'count':1,\n                                'displayname': itemData['item_' + item].displayname\n                            }\n                        }\n                    break;\n                }\n            }\n        }\n        return { sources: sources, total: totalAttribute };\n    };\n    self.getAttackSpeed = function (e) {\n        var totalAttribute = 0,\n            hasPowerTreads = false,\n            excludeList = e || [];\n        for (var i = 0; i < self.items().length; i++) {\n            var item = self.items()[i].item;\n            var isActive = self.activeItems.indexOf(self.items()[i]) >= 0 ? true : false;\n            if (!self.items()[i].enabled()) continue;\n            for (var j = 0; j < itemData['item_' + item].attributes.length; j++) {\n                var attribute = itemData['item_' + item].attributes[j];\n                if (excludeList.indexOf(attribute.name) > -1) continue;\n                switch(attribute.name) {\n                    case 'bonus_attack_speed':\n                        if (item == 'power_treads') {\n                            if (!hasPowerTreads) {\n                                totalAttribute += parseInt(attribute.value[0]);\n                                hasPowerTreads = true;\n                            }\n                        }\n                        else if (item == 'moon_shard') {\n                            if (!isActive) {\n                                totalAttribute += parseInt(attribute.value[0]);\n                            }\n                        }\n                        else if (item == 'hurricane_pike') {\n                            if (isActive) {\n                                totalAttribute += parseInt(attribute.value[0]);\n                            }\n                        }\n                        else {\n                            totalAttribute += parseInt(attribute.value[0]);\n                        }\n                    break;\n                    case 'consumed_bonus':\n                        if (item == 'moon_shard' && isActive) {\n                            totalAttribute += parseInt(attribute.value[0]);\n                        }\n                    break;\n                    break;\n                    case 'bonus_speed':\n                        totalAttribute += parseInt(attribute.value[0]);\n                    break;\n                    // helm_of_the_dominator\n                    case 'attack_speed':\n                        totalAttribute += parseInt(attribute.value[0]);\n                        excludeList.push(attribute.name);\n                    break;\n                    case 'unholy_bonus_attack_speed':\n                        if (isActive) { totalAttribute += parseInt(attribute.value[0]); };\n                    break;\n                    case 'berserk_bonus_attack_speed':\n                        if (isActive) { totalAttribute += parseInt(attribute.value[0]); };\n                    break;\n                }\n            }\n        }\n        return {value: totalAttribute, excludeList: excludeList};\n    };\n    \n    self.getAttackSpeedAura = function (e) {\n        var totalAttribute = 0,\n            excludeList = e || [];\n        for (var i = 0; i < self.items().length; i++) {\n            var item = self.items()[i].item;\n            var isActive = self.activeItems.indexOf(self.items()[i]) >= 0 ? true : false;\n            if (!self.items()[i].enabled()) continue;\n            for (var j = 0; j < itemData['item_' + item].attributes.length; j++) {\n                var attribute = itemData['item_' + item].attributes[j];\n                if (excludeList.indexOf(item + attribute.name) > -1) continue;\n                switch(attribute.name) {\n                    // helm_of_the_dominator\n                    case 'attack_speed_aura':\n                        totalAttribute += parseInt(attribute.value[0]);\n                        excludeList.push(item + attribute.name);\n                    break;\n                    // assault_cuirass\n                    case 'aura_attack_speed':\n                        if (item != 'shivas_guard') { totalAttribute += parseInt(attribute.value[0]); };\n                        excludeList.push(item + attribute.name);\n                    break;\n                    // ancient_janggo\n                    case 'bonus_attack_speed_pct':\n                        if (isActive) {\n                            totalAttribute += parseInt(attribute.value[0]);\n                            excludeList.push(attribute.name);\n                        }\n                    break;\n                }\n            }\n        }\n        return {value: totalAttribute, excludeList: excludeList};\n    };\n    \n    self.getAttackSpeedReduction = function (e) {\n        var totalAttribute = 0,\n            excludeList = e || [];\n        for (var i = 0; i < self.items().length; i++) {\n            var item = self.items()[i].item;\n            var isActive = self.activeItems.indexOf(self.items()[i]) >= 0 ? true : false;\n            if (!self.items()[i].enabled()) continue;\n            for (var j = 0; j < itemData['item_' + item].attributes.length; j++) {\n                var attribute = itemData['item_' + item].attributes[j];\n                if (excludeList.indexOf(attribute.name) > -1) continue;\n                switch(attribute.name) {\n                    case 'aura_attack_speed':\n                        if (item == 'shivas_guard') {\n                            totalAttribute += parseInt(attribute.value[0]);\n                            excludeList.push(attribute.name);\n                        }\n                    break;\n                    case 'cold_attack_speed':\n                        if (item == 'skadi') {\n                            totalAttribute += parseInt(attribute.value[0]);\n                            excludeList.push(attribute.name);\n                        }\n                    break;\n                    case 'maim_attack_speed':\n                        if (self.items()[i].debuff && self.items()[i].debuff == 'maim') {\n                            totalAttribute += parseInt(attribute.value[0]);\n                            excludeList.push(attribute.name);\n                        }\n                    break;\n                }\n            }\n        }\n        return {value: totalAttribute, excludeList: excludeList};\n    };\n    self.getLifesteal = function () {\n        var totalAttribute = 0;\n        for (var i = 0; i < self.items().length; i++) {\n            var item = self.items()[i].item;\n            var isActive = self.activeItems.indexOf(self.items()[i]) >= 0 ? true : false;\n            if (!self.items()[i].enabled()) continue;\n            for (var j = 0; j < itemData['item_' + item].attributes.length; j++) {\n                var attribute = itemData['item_' + item].attributes[j];\n                switch(attribute.name) {\n                    case 'lifesteal_percent':\n                        if (item == 'satanic') {\n                            if (!isActive) { return parseInt(attribute.value[0]); };\n                        }\n                        else {\n                            return parseInt(attribute.value[0]);\n                        }\n                    break;\n                    case 'unholy_lifesteal_percent':\n                        if (isActive) { return parseInt(attribute.value[0]); };\n                    break;\n                }\n            }\n        }\n        return totalAttribute;\n    };\n    self.getLifestealAura = function (e) {\n        var totalAttribute = 0,\n            excludeList = e || [];\n        for (var i = 0; i < self.items().length; i++) {\n            var item = self.items()[i].item;\n            var isActive = self.activeItems.indexOf(self.items()[i]) >= 0 ? true : false;\n            if (!self.items()[i].enabled()) continue;\n            for (var j = 0; j < itemData['item_' + item].attributes.length; j++) {\n                var attribute = itemData['item_' + item].attributes[j];\n                if (excludeList.indexOf(attribute.name) > -1) continue;\n                switch(attribute.name) {\n                    case 'vampiric_aura':\n                        totalAttribute += parseInt(attribute.value[0]);\n                        excludeList.push(attribute.name);\n                    break;\n                }\n            }\n        }\n        return {value: totalAttribute, excludeList: excludeList};\n    };\n    self.getSpellAmp = ko.computed(function () {\n        var sources = new StatModel();\n        for (var i = 0; i < self.items().length; i++) {\n            var itemId = self.items()[i].item;\n            var isActive = self.activeItems.indexOf(self.items()[i]) >= 0 ? true : false;\n            if (!self.items()[i].enabled()) continue;\n            var item = itemData['item_' + itemId];\n            for (var j = 0; j < item.attributes.length; j++) {\n                var attribute = item.attributes[j];\n                switch(attribute.name) {\n                    case 'spell_amp':\n                        sources.add(parseInt(attribute.value[0])/100, item.displayname);\n                    break;\n                }\n            }\n        }\n        return sources;\n    });\n    self.getCooldownReductionFlat = ko.computed(function () {\n        var totalAttribute = 0;\n        /*for (var i = 0; i < self.items().length; i++) {\n            var item = self.items()[i].item;\n            var isActive = self.activeItems.indexOf(self.items()[i]) >= 0 ? true : false;\n            if (!self.items()[i].enabled()) continue;\n            for (var j = 0; j < itemData['item_' + item].attributes.length; j++) {\n                var attribute = itemData['item_' + item].attributes[j];\n                switch(attribute.name) {\n                    case 'bonus_night_vision':\n                        if (item != 'moon_shard' || !isActive) {\n                            totalAttribute += parseInt(attribute.value[0]);\n                        }\n                    break;\n                }\n            }\n        }*/\n        return totalAttribute;\n    });\n    self.getCooldownReductionPercent = function (aList) {        \n        var totalAttribute = 1,\n            attributeList = aList || [];\n        for (var i = 0; i < self.items().length; i++) {\n            var item = self.items()[i].item;\n            var isActive = self.activeItems.indexOf(self.items()[i]) >= 0 ? true : false;\n            if (!self.items()[i].enabled()) continue;\n            for (var j = 0;j < itemData['item_' + item].attributes.length; j++) {\n                var attribute = itemData['item_' + item].attributes[j];\n                if (attributeList.find(function (a) { return attribute.name == a.name; })) continue;\n                switch(attribute.name) {\n                    // octarine_core\n                    case 'bonus_cooldown':\n                        attributeList.push({'name':attribute.name, 'value': parseInt(attribute.value[0])});\n                    break;\n                }\n            }\n        }\n        \n        totalAttribute = attributeList.reduce(function (memo, attribute) {\n            return memo *= (1 - attribute.value / 100);\n        }, 1);\n        return {value: totalAttribute, attributes: attributeList};\n    };\n    self.getCooldownIncreaseFlat = ko.computed(function () {\n        var totalAttribute = 0;\n        return totalAttribute;\n    });\n    self.getCooldownIncreasePercent = function () {\n        var totalAttribute = 1;\n        return totalAttribute;\n    };\n    self.getMagicResist = function () {\n        var totalAttribute = 1;\n        for (var i = 0; i < self.items().length; i++) {\n            var item = self.items()[i].item;\n            var isActive = self.activeItems.indexOf(self.items()[i]) >= 0 ? true : false;\n            if (!self.items()[i].enabled()) continue;\n            for (var j = 0; j < itemData['item_' + item].attributes.length; j++) {\n                var attribute = itemData['item_' + item].attributes[j];\n                switch(attribute.name) {\n                    case 'bonus_magical_armor':\n                        totalAttribute *= (1 - parseInt(attribute.value[0]) / 100);\n                    break;\n                    case 'bonus_spell_resist':\n                        totalAttribute *= (1 - parseInt(attribute.value[0]) / 100);\n                    break;\n                    case 'magic_resistance':\n                        totalAttribute *= (1 - parseInt(attribute.value[0]) / 100);\n                    break;\n                }\n            }\n        }\n        return totalAttribute;\n    };\n    self.getMagicResistReductionSelf = function () {\n        var totalAttribute = 1;\n        for (var i = 0; i < self.items().length; i++) {\n            var item = self.items()[i].item;\n            var isActive = self.activeItems.indexOf(self.items()[i]) >= 0 ? true : false;\n            if (!self.items()[i].enabled()) continue;\n            if (isActive) {\n                for (var j = 0; j < itemData['item_' + item].attributes.length; j++) {\n                    var attribute = itemData['item_' + item].attributes[j];\n                    switch(attribute.name) {\n                        case 'extra_spell_damage_percent':\n                        case 'ethereal_damage_bonus':\n                            return (1 - parseInt(attribute.value[0]) / 100);\n                        break;\n                    }\n                }\n            }\n        }\n        return totalAttribute;\n    };   \n    self.getMagicResistReduction = function () {\n        var totalAttribute = 1;\n        for (var i = 0; i < self.items().length; i++) {\n            var item = self.items()[i].item;\n            var isActive = self.activeItems.indexOf(self.items()[i]) >= 0 ? true : false;\n            if (!self.items()[i].enabled()) continue;\n            if (isActive) {\n                for (var j = 0; j < itemData['item_' + item].attributes.length; j++) {\n                    var attribute = itemData['item_' + item].attributes[j];\n                    switch(attribute.name) {\n                        case 'ethereal_damage_bonus':\n                            if (!self.isEthereal()) totalAttribute *= (1 - parseInt(attribute.value[0]) / 100);\n                        case 'resist_debuff':\n                            totalAttribute *= (1 - parseInt(attribute.value[0]) / 100);\n                        break;\n                    }\n                }\n            }\n        }\n        return totalAttribute;\n    };        \n\n    self.getVisionRangeNight = ko.computed(function () {\n        var totalAttribute = 0;\n        for (var i = 0; i < self.items().length; i++) {\n            var item = self.items()[i].item;\n            var isActive = self.activeItems.indexOf(self.items()[i]) >= 0 ? true : false;\n            if (!self.items()[i].enabled()) continue;\n            for (var j = 0; j < itemData['item_' + item].attributes.length; j++) {\n                var attribute = itemData['item_' + item].attributes[j];\n                switch(attribute.name) {\n                    case 'bonus_night_vision':\n                        if (item != 'moon_shard' || !isActive) {\n                            totalAttribute += parseInt(attribute.value[0]);\n                        }\n                    break;\n                    // moon_shard\n                    case 'consumed_bonus_night_vision':\n                        if (item == 'moon_shard' && isActive) {\n                            totalAttribute += parseInt(attribute.value[0]);\n                        }\n                    break;\n                }\n            }\n        }\n        return totalAttribute;\n    });\n    \n    self.getAttackRange = function (attacktype, aList) {\n        var totalAttribute = 0,\n            attributeList = aList || [];\n        for (var i = 0; i < self.items().length; i++) {\n            var item = self.items()[i].item;\n            var isActive = self.activeItems.indexOf(self.items()[i]) >= 0 ? true : false;\n            if (!self.items()[i].enabled()) continue;\n            for (var j = 0;j < itemData['item_' + item].attributes.length; j++) {\n                var attribute = itemData['item_' + item].attributes[j];\n                if (attributeList.find(function (a) { return attribute.name == a.name; })) continue;\n                switch(attribute.name) {\n                    // dragon_lance\n                    case 'base_attack_range':\n                        if (attacktype == 'DOTA_UNIT_CAP_RANGED_ATTACK') attributeList.push({'name':attribute.name, 'value': parseInt(attribute.value[0])});\n                    break;\n                }\n            }\n        }\n        \n        totalAttribute = attributeList.reduce(function (memo, attribute) {\n            return memo += attribute.value;\n        }, 0);\n        return {value: totalAttribute, attributes: attributeList};\n    };\n    \n    self.getBlindSource = function (e) {\n        var totalAttribute = 0,\n            sources = [],\n            excludeList = e || [];\n        for (var i = 0; i < self.items().length; i++) {\n            var item = self.items()[i].item;\n            var isActive = self.activeItems.indexOf(self.items()[i]) >= 0 ? true : false;\n            if (!self.items()[i].enabled()) continue;\n            for (var j = 0; j < itemData['item_' + item].attributes.length; j++) {\n                var attribute = itemData['item_' + item].attributes[j];\n                if (excludeList.indexOf(attribute.name) > -1) continue;\n                switch(attribute.name) {\n                    case 'blind_pct':\n                        var value = parseInt(attribute.value[0]) / 100;\n                        totalAttribute += value;\n                        sources.push({\n                            'value': value,\n                            'displayname': itemData['item_' + item].displayname\n                        });\n                        excludeList.push(attribute.name);\n                    break;\n                }\n            }\n        }\n        return {sources: sources, total: totalAttribute, excludeList: excludeList};\n    };\n    \n    self.getBaseDamageReductionPct = function () {\n        var totalAttribute = 1;\n        for (var i = 0; i < self.items().length; i++) {\n            var item = self.items()[i].item;\n            var isActive = self.activeItems.indexOf(self.items()[i]) >= 0 ? true : false;\n            if (!self.items()[i].enabled()) continue;\n            for (var j = 0; j < itemData['item_' + item].attributes.length; j++) {\n                var attribute = itemData['item_' + item].attributes[j];\n                switch(attribute.name) {\n                    case 'backstab_reduction':\n                        if (self.items()[i].debuff && self.items()[i].debuff == 'shadow_walk') {\n                            totalAttribute *= (1 + parseInt(attribute.value[0]) / 100);\n                        }\n                    break;\n                }\n            }\n        }\n        return totalAttribute;\n    };    \n    self.getBonusDamageReductionPct = function () {\n        var totalAttribute = 1;\n        for (var i = 0; i < self.items().length; i++) {\n            var item = self.items()[i].item;\n            var isActive = self.activeItems.indexOf(self.items()[i]) >= 0 ? true : false;\n            if (!self.items()[i].enabled()) continue;\n            for (var j = 0; j < itemData['item_' + item].attributes.length; j++) {\n                var attribute = itemData['item_' + item].attributes[j];\n                switch(attribute.name) {\n                    case 'backstab_reduction':\n                        if (self.items()[i].debuff && self.items()[i].debuff == 'shadow_walk') {\n                            totalAttribute *= (1 + parseInt(attribute.value[0]) / 100);\n                        }\n                    break;\n                }\n            }\n        }\n        return totalAttribute;\n    };\n    \n    self.itemOptions = ko.observableArray(itemOptionsArray.items);\n    \n    self.itemBuffOptions = ko.observableArray(itemBuffOptions.items);\n    self.selectedItemBuff = ko.observable('assault');\n\n    self.itemDebuffOptions = ko.observableArray(itemDebuffOptions.items);\n    self.selectedItemDebuff = ko.observable('assault');\n    \n    return self;\n};\nInventoryViewModel.prototype = Object.create(BasicInventoryViewModel.prototype);\nInventoryViewModel.prototype.constructor = InventoryViewModel;\n\nmodule.exports = InventoryViewModel;",
    "var ko = (typeof window !== \"undefined\" ? window['ko'] : typeof global !== \"undefined\" ? global['ko'] : null);\n\nvar ItemInput = function (itemData, value, name, debuff, buff) {\n    if (itemData['item_' + value].ItemAliases instanceof Array) {\n        var itemAlias = itemData['item_' + value].ItemAliases.join(' ');\n    }\n    else {\n        var itemAlias = itemData['item_' + value].ItemAliases;\n    }\n    this.value = ko.observable(value);\n    this.debuff = ko.observable(debuff);\n    this.buff = ko.observable(buff);\n    if (this.debuff()) {\n        this.value = ko.observable(value + '|' + debuff.id);\n        this.name = ko.observable(name + ' (' + debuff.name + ')');\n        this.displayname = ko.observable(name + ' (' + debuff.name + ') <span style=\"display:none\">' + ';' + itemAlias + '</span>');\n    }\n    else if (this.buff()) {\n        this.value = ko.observable(value + '|' + buff.id);\n        this.name = ko.observable(name + ' (' + buff.name + ')');\n        this.displayname = ko.observable(name + ' (' + buff.name + ') <span style=\"display:none\">' + ';' + itemAlias + '</span>');\n    }\n    else {\n        this.value = ko.observable(value);\n        this.name = ko.observable(name);\n        this.displayname = ko.observable(name + ' <span style=\"display:none\">' + ';' + itemAlias + '</span>');\n    }\n};\n\nmodule.exports = ItemInput;",
    "var ItemInput = require(\"./ItemInput\");\nvar itemBuffs = [\n    {item: 'assault', buff: null},\n    {item: 'ancient_janggo', buff: null},\n    {item: 'guardian_greaves', buff: {id: 'guardian_aura', name: 'Guardian Aura'}},\n    {item: 'headdress', buff: null},\n    {item: 'mekansm', buff: null},\n    {item: 'pipe', buff: null},\n    {item: 'ring_of_aquila', buff: null},\n    {item: 'vladmir', buff: null},\n    {item: 'ring_of_basilius', buff: null},\n    {item: 'buckler', buff: null},\n    {item: 'solar_crest', buff: null},\n    {item: 'bottle_doubledamage', buff: null},\n    {item: 'helm_of_the_dominator', buff: null}\n];\n\nvar itemBuffOptions = {};\n\nvar init = function (itemData) {\n    itemBuffOptions.items = itemBuffs.map(function(item) {\n        return new ItemInput(itemData, item.item, itemData['item_' + item.item].displayname, null, item.buff);\n    }).sort(function (a, b) {\n        if (a.displayname() < b.displayname()) return -1;\n        if (a.displayname() > b.displayname()) return 1;\n        return 0;\n    });\n    return itemBuffOptions.items;\n}\n\nitemBuffOptions.init = init;\n\nmodule.exports = itemBuffOptions;",
    "var ItemInput = require(\"./ItemInput\");\nvar itemDebuffs = [\n    {item: 'assault', debuff: null},\n    {item: 'shivas_guard', debuff: null},\n    {item: 'desolator', debuff: null},\n    {item: 'blight_stone', debuff: null},\n    {item: 'medallion_of_courage', debuff: null},\n    {item: 'radiance', debuff: null},\n    {item: 'sheepstick', debuff: null},\n    {item: 'veil_of_discord', debuff: null},\n    {item: 'solar_crest', debuff: null},\n    {item: 'silver_edge', debuff: {id: 'shadow_walk', name: 'Shadow Walk'}},\n    {item: 'silver_edge', debuff: {id: 'maim', name: 'Lesser Maim'}}\n]\nvar itemDebuffOptions = {};\n\nvar init = function (itemData) {\n    itemDebuffOptions.items = itemDebuffs.map(function(item) {\n        return new ItemInput(itemData, item.item, itemData['item_' + item.item].displayname, item.debuff);\n    }).sort(function (a, b) {\n        if (a.displayname() < b.displayname()) return -1;\n        if (a.displayname() > b.displayname()) return 1;\n        return 0;\n    });\n    return itemDebuffOptions.items;\n}\n\nitemDebuffOptions.init = init;\n\nmodule.exports = itemDebuffOptions;",
    "var validItems = require(\"./validItems\");\nvar ItemInput = require(\"./ItemInput\");\n\nvar itemOptionsArray = {};\n\nvar init = function (itemData) {\n    itemOptionsArray.items = [];\n    for (var i = 0; i < validItems.length; i++) {\n        itemOptionsArray.items.push(new ItemInput(itemData, validItems[i], itemData['item_' + validItems[i]].displayname));\n    }\n    return itemOptionsArray.items;\n}\n\nitemOptionsArray.init = init;\n\nmodule.exports = itemOptionsArray;",
    "module.exports = ['solar_crest', 'heart','smoke_of_deceit','dust','ghost','tranquil_boots','phase_boots','power_treads','buckler','medallion_of_courage','ancient_janggo','mekansm','pipe','veil_of_discord','rod_of_atos','orchid','sheepstick','armlet','invis_sword','ethereal_blade','shivas_guard','manta','mask_of_madness','diffusal_blade','mjollnir','satanic','ring_of_basilius','ring_of_aquila', 'butterfly', 'moon_shard', 'silver_edge','bloodthorn','hurricane_pike'];",
    "module.exports = ['necronomicon','dagon','travel_boots'];",
    "module.exports = ['clarity','flask','dust','ward_observer','ward_sentry','tango','tpscroll','smoke_of_deceit'];",
    "module.exports = [\"abyssal_blade\",\"ultimate_scepter\",\"courier\",\"arcane_boots\",\"armlet\",\"assault\",\"boots_of_elves\",\"bfury\",\"belt_of_strength\",\"black_king_bar\",\"blade_mail\",\"blade_of_alacrity\",\"blades_of_attack\",\"blink\",\"bloodstone\",\"boots\",\"travel_boots\",\"bottle\",\"bracer\",\"broadsword\",\"buckler\",\"butterfly\",\"chainmail\",\"circlet\",\"clarity\",\"claymore\",\"cloak\",\"lesser_crit\",\"greater_crit\",\"dagon\",\"demon_edge\",\"desolator\",\"diffusal_blade\",\"rapier\",\"ancient_janggo\",\"dust\",\"eagle\",\"energy_booster\",\"ethereal_blade\",\"cyclone\",\"skadi\",\"force_staff\",\"gauntlets\",\"gem\",\"ghost\",\"gloves\",\"hand_of_midas\",\"headdress\",\"flask\",\"heart\",\"heavens_halberd\",\"helm_of_iron_will\",\"helm_of_the_dominator\",\"hood_of_defiance\",\"hyperstone\",\"branches\",\"javelin\",\"sphere\",\"maelstrom\",\"magic_stick\",\"magic_wand\",\"manta\",\"mantle\",\"mask_of_madness\",\"medallion_of_courage\",\"mekansm\",\"mithril_hammer\",\"mjollnir\",\"monkey_king_bar\",\"lifesteal\",\"mystic_staff\",\"necronomicon\",\"null_talisman\",\"oblivion_staff\",\"ward_observer\",\"ogre_axe\",\"orb_of_venom\",\"orchid\",\"pers\",\"phase_boots\",\"pipe\",\"platemail\",\"point_booster\",\"power_treads\",\"quarterstaff\",\"quelling_blade\",\"radiance\",\"reaver\",\"refresher\",\"ring_of_aquila\",\"ring_of_basilius\",\"ring_of_health\",\"ring_of_protection\",\"ring_of_regen\",\"robe\",\"rod_of_atos\",\"relic\",\"sobi_mask\",\"sange\",\"sange_and_yasha\",\"satanic\",\"sheepstick\",\"ward_sentry\",\"shadow_amulet\",\"invis_sword\",\"shivas_guard\",\"basher\",\"slippers\",\"smoke_of_deceit\",\"soul_booster\",\"soul_ring\",\"staff_of_wizardry\",\"stout_shield\",\"talisman_of_evasion\",\"tango\",\"tpscroll\",\"tranquil_boots\",\"ultimate_orb\",\"urn_of_shadows\",\"vanguard\",\"veil_of_discord\",\"vitality_booster\",\"vladmir\",\"void_stone\",\"wraith_band\",\"yasha\",\"crimson_guard\",\"enchanted_mango\",\"lotus_orb\",\"glimmer_cape\",\"guardian_greaves\",\"moon_shard\",\"silver_edge\",\"solar_crest\",\"octarine_core\",\"aether_lens\",\"faerie_fire\",\"dragon_lance\",\"echo_sabre\",\"infused_raindrop\",\"blight_stone\",\"wind_lace\",\"tome_of_knowledge\",\"bloodthorn\",\"hurricane_pike\",\"kaya\",\"aeon_disk\",\"meteor_hammer\",\"nullifier\",\"spirit_vessel\",\"refresher_shard\"];",
    "(function (factory) {\n\t// Module systems magic dance.\n\n\tif (typeof require === \"function\" && typeof exports === \"object\" && typeof module === \"object\") {\n\t\t// CommonJS or Node: hard-coded dependency on \"knockout\"\n\t\tfactory((typeof window !== \"undefined\" ? window['ko'] : typeof global !== \"undefined\" ? global['ko'] : null), exports);\n\t} else if (typeof define === \"function\" && define[\"amd\"]) {\n\t\t// AMD anonymous module with hard-coded dependency on \"knockout\"\n\t\tdefine([\"knockout\", \"exports\"], factory);\n\t} else {\n\t\t// <script> tag: use the global `ko` object, attaching a `mapping` property\n\t\tfactory(ko, ko.mapping = {});\n\t}\n}(function (ko, exports) {\n\tvar DEBUG=true;\n\tvar mappingProperty = \"__ko_mapping__\";\n\tvar realKoDependentObservable = ko.dependentObservable;\n\tvar mappingNesting = 0;\n\tvar dependentObservables;\n\tvar visitedObjects;\n\tvar recognizedRootProperties = [\"create\", \"update\", \"key\", \"arrayChanged\"];\n\tvar emptyReturn = {};\n\n\tvar _defaultOptions = {\n\t\tinclude: [\"_destroy\"],\n\t\tignore: [],\n\t\tcopy: [],\n\t\tobserve: []\n\t};\n\tvar defaultOptions = _defaultOptions;\n\n\t// Author: KennyTM @ StackOverflow\n\tfunction unionArrays (x, y) {\n\t\tvar obj = {};\n\t\tfor (var i = x.length - 1; i >= 0; -- i) obj[x[i]] = x[i];\n\t\tfor (var i = y.length - 1; i >= 0; -- i) obj[y[i]] = y[i];\n\t\tvar res = [];\n\n\t\tfor (var k in obj) {\n\t\t\tres.push(obj[k]);\n\t\t};\n\n\t\treturn res;\n\t}\n\n\tfunction extendObject(destination, source) {\n\t\tvar destType;\n\n\t\tfor (var key in source) {\n\t\t\tif (source.hasOwnProperty(key) && source[key]) {\n\t\t\t\tdestType = exports.getType(destination[key]);\n\t\t\t\tif (key && destination[key] && destType !== \"array\" && destType !== \"string\") {\n\t\t\t\t\textendObject(destination[key], source[key]);\n\t\t\t\t} else {\n\t\t\t\t\tvar bothArrays = exports.getType(destination[key]) === \"array\" && exports.getType(source[key]) === \"array\";\n\t\t\t\t\tif (bothArrays) {\n\t\t\t\t\t\tdestination[key] = unionArrays(destination[key], source[key]);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdestination[key] = source[key];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction merge(obj1, obj2) {\n\t\tvar merged = {};\n\t\textendObject(merged, obj1);\n\t\textendObject(merged, obj2);\n\n\t\treturn merged;\n\t}\n\n\texports.isMapped = function (viewModel) {\n\t\tvar unwrapped = ko.utils.unwrapObservable(viewModel);\n\t\treturn unwrapped && unwrapped[mappingProperty];\n\t}\n\n\texports.fromJS = function (jsObject /*, inputOptions, target*/ ) {\n\t\tif (arguments.length == 0) throw new Error(\"When calling ko.fromJS, pass the object you want to convert.\");\n\n\t\ttry {\n\t\t\tif (!mappingNesting++) {\n\t\t\t\tdependentObservables = [];\n\t\t\t\tvisitedObjects = new objectLookup();\n\t\t\t}\n\n\t\t\tvar options;\n\t\t\tvar target;\n\n\t\t\tif (arguments.length == 2) {\n\t\t\t\tif (arguments[1][mappingProperty]) {\n\t\t\t\t\ttarget = arguments[1];\n\t\t\t\t} else {\n\t\t\t\t\toptions = arguments[1];\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (arguments.length == 3) {\n\t\t\t\toptions = arguments[1];\n\t\t\t\ttarget = arguments[2];\n\t\t\t}\n\n\t\t\tif (target) {\n\t\t\t\toptions = merge(options, target[mappingProperty]);\n\t\t\t}\n\t\t\toptions = fillOptions(options);\n\n\t\t\tvar result = updateViewModel(target, jsObject, options);\n\t\t\tif (target) {\n\t\t\t\tresult = target;\n\t\t\t}\n\n\t\t\t// Evaluate any dependent observables that were proxied.\n\t\t\t// Do this after the model's observables have been created\n\t\t\tif (!--mappingNesting) {\n\t\t\t\twhile (dependentObservables.length) {\n\t\t\t\t\tvar DO = dependentObservables.pop();\n\t\t\t\t\tif (DO) {\n\t\t\t\t\t\tDO();\n\t\t\t\t\t\t\n\t\t\t\t\t\t// Move this magic property to the underlying dependent observable\n\t\t\t\t\t\tDO.__DO[\"throttleEvaluation\"] = DO[\"throttleEvaluation\"];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Save any new mapping options in the view model, so that updateFromJS can use them later.\n\t\t\tresult[mappingProperty] = merge(result[mappingProperty], options);\n\n\t\t\treturn result;\n\t\t} catch(e) {\n\t\t\tmappingNesting = 0;\n\t\t\tthrow e;\n\t\t}\n\t};\n\n\texports.fromJSON = function (jsonString /*, options, target*/ ) {\n\t\tvar parsed = ko.utils.parseJson(jsonString);\n\t\targuments[0] = parsed;\n\t\treturn exports.fromJS.apply(this, arguments);\n\t};\n\n\texports.updateFromJS = function (viewModel) {\n\t\tthrow new Error(\"ko.mapping.updateFromJS, use ko.mapping.fromJS instead. Please note that the order of parameters is different!\");\n\t};\n\n\texports.updateFromJSON = function (viewModel) {\n\t\tthrow new Error(\"ko.mapping.updateFromJSON, use ko.mapping.fromJSON instead. Please note that the order of parameters is different!\");\n\t};\n\n\texports.toJS = function (rootObject, options) {\n\t\tif (!defaultOptions) exports.resetDefaultOptions();\n\n\t\tif (arguments.length == 0) throw new Error(\"When calling ko.mapping.toJS, pass the object you want to convert.\");\n\t\tif (exports.getType(defaultOptions.ignore) !== \"array\") throw new Error(\"ko.mapping.defaultOptions().ignore should be an array.\");\n\t\tif (exports.getType(defaultOptions.include) !== \"array\") throw new Error(\"ko.mapping.defaultOptions().include should be an array.\");\n\t\tif (exports.getType(defaultOptions.copy) !== \"array\") throw new Error(\"ko.mapping.defaultOptions().copy should be an array.\");\n\n\t\t// Merge in the options used in fromJS\n\t\toptions = fillOptions(options, rootObject[mappingProperty]);\n\n\t\t// We just unwrap everything at every level in the object graph\n\t\treturn exports.visitModel(rootObject, function (x) {\n\t\t\treturn ko.utils.unwrapObservable(x)\n\t\t}, options);\n\t};\n\n\texports.toJSON = function (rootObject, options) {\n\t\tvar plainJavaScriptObject = exports.toJS(rootObject, options);\n\t\treturn ko.utils.stringifyJson(plainJavaScriptObject);\n\t};\n\n\texports.defaultOptions = function () {\n\t\tif (arguments.length > 0) {\n\t\t\tdefaultOptions = arguments[0];\n\t\t} else {\n\t\t\treturn defaultOptions;\n\t\t}\n\t};\n\n\texports.resetDefaultOptions = function () {\n\t\tdefaultOptions = {\n\t\t\tinclude: _defaultOptions.include.slice(0),\n\t\t\tignore: _defaultOptions.ignore.slice(0),\n\t\t\tcopy: _defaultOptions.copy.slice(0)\n\t\t};\n\t};\n\n\texports.getType = function(x) {\n\t\tif ((x) && (typeof (x) === \"object\")) {\n\t\t\tif (x.constructor === Date) return \"date\";\n\t\t\tif (x.constructor === Array) return \"array\";\n\t\t}\n\t\treturn typeof x;\n\t}\n\n\tfunction fillOptions(rawOptions, otherOptions) {\n\t\tvar options = merge({}, rawOptions);\n\n\t\t// Move recognized root-level properties into a root namespace\n\t\tfor (var i = recognizedRootProperties.length - 1; i >= 0; i--) {\n\t\t\tvar property = recognizedRootProperties[i];\n\t\t\t\n\t\t\t// Carry on, unless this property is present\n\t\t\tif (!options[property]) continue;\n\t\t\t\n\t\t\t// Move the property into the root namespace\n\t\t\tif (!(options[\"\"] instanceof Object)) options[\"\"] = {};\n\t\t\toptions[\"\"][property] = options[property];\n\t\t\tdelete options[property];\n\t\t}\n\n\t\tif (otherOptions) {\n\t\t\toptions.ignore = mergeArrays(otherOptions.ignore, options.ignore);\n\t\t\toptions.include = mergeArrays(otherOptions.include, options.include);\n\t\t\toptions.copy = mergeArrays(otherOptions.copy, options.copy);\n\t\t\toptions.observe = mergeArrays(otherOptions.observe, options.observe);\n\t\t}\n\t\toptions.ignore = mergeArrays(options.ignore, defaultOptions.ignore);\n\t\toptions.include = mergeArrays(options.include, defaultOptions.include);\n\t\toptions.copy = mergeArrays(options.copy, defaultOptions.copy);\n\t\toptions.observe = mergeArrays(options.observe, defaultOptions.observe);\n\n\t\toptions.mappedProperties = options.mappedProperties || {};\n\t\toptions.copiedProperties = options.copiedProperties || {};\n\t\treturn options;\n\t}\n\n\tfunction mergeArrays(a, b) {\n\t\tif (exports.getType(a) !== \"array\") {\n\t\t\tif (exports.getType(a) === \"undefined\") a = [];\n\t\t\telse a = [a];\n\t\t}\n\t\tif (exports.getType(b) !== \"array\") {\n\t\t\tif (exports.getType(b) === \"undefined\") b = [];\n\t\t\telse b = [b];\n\t\t}\n\n\t\treturn ko.utils.arrayGetDistinctValues(a.concat(b));\n\t}\n\n\t// When using a 'create' callback, we proxy the dependent observable so that it doesn't immediately evaluate on creation.\n\t// The reason is that the dependent observables in the user-specified callback may contain references to properties that have not been mapped yet.\n\tfunction withProxyDependentObservable(dependentObservables, callback) {\n\t\tvar localDO = ko.dependentObservable;\n\t\tko.dependentObservable = function (read, owner, options) {\n\t\t\toptions = options || {};\n\n\t\t\tif (read && typeof read == \"object\") { // mirrors condition in knockout implementation of DO's\n\t\t\t\toptions = read;\n\t\t\t}\n\n\t\t\tvar realDeferEvaluation = options.deferEvaluation;\n\n\t\t\tvar isRemoved = false;\n\n\t\t\t// We wrap the original dependent observable so that we can remove it from the 'dependentObservables' list we need to evaluate after mapping has\n\t\t\t// completed if the user already evaluated the DO themselves in the meantime.\n\t\t\tvar wrap = function (DO) {\n\t\t\t\t// Temporarily revert ko.dependentObservable, since it is used in ko.isWriteableObservable\n\t\t\t\tvar tmp = ko.dependentObservable;\n\t\t\t\tko.dependentObservable = realKoDependentObservable;\n\t\t\t\tvar isWriteable = ko.isWriteableObservable(DO);\n\t\t\t\tko.dependentObservable = tmp;\n\n\t\t\t\tvar wrapped = realKoDependentObservable({\n\t\t\t\t\tread: function () {\n\t\t\t\t\t\tif (!isRemoved) {\n\t\t\t\t\t\t\tko.utils.arrayRemoveItem(dependentObservables, DO);\n\t\t\t\t\t\t\tisRemoved = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn DO.apply(DO, arguments);\n\t\t\t\t\t},\n\t\t\t\t\twrite: isWriteable && function (val) {\n\t\t\t\t\t\treturn DO(val);\n\t\t\t\t\t},\n\t\t\t\t\tdeferEvaluation: true\n\t\t\t\t});\n\t\t\t\tif (DEBUG) wrapped._wrapper = true;\n\t\t\t\twrapped.__DO = DO;\n\t\t\t\treturn wrapped;\n\t\t\t};\n\t\t\t\n\t\t\toptions.deferEvaluation = true; // will either set for just options, or both read/options.\n\t\t\tvar realDependentObservable = new realKoDependentObservable(read, owner, options);\n\n\t\t\tif (!realDeferEvaluation) {\n\t\t\t\trealDependentObservable = wrap(realDependentObservable);\n\t\t\t\tdependentObservables.push(realDependentObservable);\n\t\t\t}\n\n\t\t\treturn realDependentObservable;\n\t\t}\n\t\tko.dependentObservable.fn = realKoDependentObservable.fn;\n\t\tko.computed = ko.dependentObservable;\n\t\tvar result = callback();\n\t\tko.dependentObservable = localDO;\n\t\tko.computed = ko.dependentObservable;\n\t\treturn result;\n\t}\n\n\tfunction updateViewModel(mappedRootObject, rootObject, options, parentName, parent, parentPropertyName, mappedParent) {\n\t\tvar isArray = exports.getType(ko.utils.unwrapObservable(rootObject)) === \"array\";\n\n\t\tparentPropertyName = parentPropertyName || \"\";\n\n\t\t// If this object was already mapped previously, take the options from there and merge them with our existing ones.\n\t\tif (exports.isMapped(mappedRootObject)) {\n\t\t\tvar previousMapping = ko.utils.unwrapObservable(mappedRootObject)[mappingProperty];\n\t\t\toptions = merge(previousMapping, options);\n\t\t}\n\n\t\tvar callbackParams = {\n\t\t\tdata: rootObject,\n\t\t\tparent: mappedParent || parent\n\t\t};\n\n\t\tvar hasCreateCallback = function () {\n\t\t\treturn options[parentName] && options[parentName].create instanceof Function;\n\t\t};\n\n\t\tvar createCallback = function (data) {\n\t\t\treturn withProxyDependentObservable(dependentObservables, function () {\n\t\t\t\t\n\t\t\t\tif (ko.utils.unwrapObservable(parent) instanceof Array) {\n\t\t\t\t\treturn options[parentName].create({\n\t\t\t\t\t\tdata: data || callbackParams.data,\n\t\t\t\t\t\tparent: callbackParams.parent,\n\t\t\t\t\t\tskip: emptyReturn\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\treturn options[parentName].create({\n\t\t\t\t\t\tdata: data || callbackParams.data,\n\t\t\t\t\t\tparent: callbackParams.parent\n\t\t\t\t\t});\n\t\t\t\t}\t\t\t\t\n\t\t\t});\n\t\t};\n\n\t\tvar hasUpdateCallback = function () {\n\t\t\treturn options[parentName] && options[parentName].update instanceof Function;\n\t\t};\n\n\t\tvar updateCallback = function (obj, data) {\n\t\t\tvar params = {\n\t\t\t\tdata: data || callbackParams.data,\n\t\t\t\tparent: callbackParams.parent,\n\t\t\t\ttarget: ko.utils.unwrapObservable(obj)\n\t\t\t};\n\n\t\t\tif (ko.isWriteableObservable(obj)) {\n\t\t\t\tparams.observable = obj;\n\t\t\t}\n\n\t\t\treturn options[parentName].update(params);\n\t\t}\n\n\t\tvar alreadyMapped = visitedObjects.get(rootObject);\n\t\tif (alreadyMapped) {\n\t\t\treturn alreadyMapped;\n\t\t}\n\n\t\tparentName = parentName || \"\";\n\n\t\tif (!isArray) {\n\t\t\t// For atomic types, do a direct update on the observable\n\t\t\tif (!canHaveProperties(rootObject)) {\n\t\t\t\tswitch (exports.getType(rootObject)) {\n\t\t\t\tcase \"function\":\n\t\t\t\t\tif (hasUpdateCallback()) {\n\t\t\t\t\t\tif (ko.isWriteableObservable(rootObject)) {\n\t\t\t\t\t\t\trootObject(updateCallback(rootObject));\n\t\t\t\t\t\t\tmappedRootObject = rootObject;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tmappedRootObject = updateCallback(rootObject);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tmappedRootObject = rootObject;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tif (ko.isWriteableObservable(mappedRootObject)) {\n\t\t\t\t\t\tif (hasUpdateCallback()) {\n\t\t\t\t\t\t\tvar valueToWrite = updateCallback(mappedRootObject);\n\t\t\t\t\t\t\tmappedRootObject(valueToWrite);\n\t\t\t\t\t\t\treturn valueToWrite;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tvar valueToWrite = ko.utils.unwrapObservable(rootObject);\n\t\t\t\t\t\t\tmappedRootObject(valueToWrite);\n\t\t\t\t\t\t\treturn valueToWrite;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvar hasCreateOrUpdateCallback = hasCreateCallback() || hasUpdateCallback();\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (hasCreateCallback()) {\n\t\t\t\t\t\t\tmappedRootObject = createCallback();\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tmappedRootObject = ko.observable(ko.utils.unwrapObservable(rootObject));\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (hasUpdateCallback()) {\n\t\t\t\t\t\t\tmappedRootObject(updateCallback(mappedRootObject));\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (hasCreateOrUpdateCallback) return mappedRootObject;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t} else {\n\t\t\t\tmappedRootObject = ko.utils.unwrapObservable(mappedRootObject);\n\t\t\t\tif (!mappedRootObject) {\n\t\t\t\t\tif (hasCreateCallback()) {\n\t\t\t\t\t\tvar result = createCallback();\n\n\t\t\t\t\t\tif (hasUpdateCallback()) {\n\t\t\t\t\t\t\tresult = updateCallback(result);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn result;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (hasUpdateCallback()) {\n\t\t\t\t\t\t\treturn updateCallback(result);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tmappedRootObject = {};\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (hasUpdateCallback()) {\n\t\t\t\t\tmappedRootObject = updateCallback(mappedRootObject);\n\t\t\t\t}\n\n\t\t\t\tvisitedObjects.save(rootObject, mappedRootObject);\n\t\t\t\tif (hasUpdateCallback()) return mappedRootObject;\n\n\t\t\t\t// For non-atomic types, visit all properties and update recursively\n\t\t\t\tvisitPropertiesOrArrayEntries(rootObject, function (indexer) {\n\t\t\t\t\tvar fullPropertyName = parentPropertyName.length ? parentPropertyName + \".\" + indexer : indexer;\n\n\t\t\t\t\tif (ko.utils.arrayIndexOf(options.ignore, fullPropertyName) != -1) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (ko.utils.arrayIndexOf(options.copy, fullPropertyName) != -1) {\n\t\t\t\t\t\tmappedRootObject[indexer] = rootObject[indexer];\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tif(typeof rootObject[indexer] != \"object\" && typeof rootObject[indexer] != \"array\" && options.observe.length > 0 && ko.utils.arrayIndexOf(options.observe, fullPropertyName) == -1)\n\t\t\t\t\t{\n\t\t\t\t\t\tmappedRootObject[indexer] = rootObject[indexer];\n\t\t\t\t\t\toptions.copiedProperties[fullPropertyName] = true;\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t// In case we are adding an already mapped property, fill it with the previously mapped property value to prevent recursion.\n\t\t\t\t\t// If this is a property that was generated by fromJS, we should use the options specified there\n\t\t\t\t\tvar prevMappedProperty = visitedObjects.get(rootObject[indexer]);\n\t\t\t\t\tvar retval = updateViewModel(mappedRootObject[indexer], rootObject[indexer], options, indexer, mappedRootObject, fullPropertyName, mappedRootObject);\n\t\t\t\t\tvar value = prevMappedProperty || retval;\n\t\t\t\t\t\n\t\t\t\t\tif(options.observe.length > 0 && ko.utils.arrayIndexOf(options.observe, fullPropertyName) == -1)\n\t\t\t\t\t{\n\t\t\t\t\t\tmappedRootObject[indexer] = value();\n\t\t\t\t\t\toptions.copiedProperties[fullPropertyName] = true;\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif (ko.isWriteableObservable(mappedRootObject[indexer])) {\n\t\t\t\t\t\tvalue = ko.utils.unwrapObservable(value);\n\t\t\t\t\t\tif (mappedRootObject[indexer]() !== value) {\n\t\t\t\t\t\t\tmappedRootObject[indexer](value);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvalue = mappedRootObject[indexer] === undefined ? value : ko.utils.unwrapObservable(value);\n\t\t\t\t\t\tmappedRootObject[indexer] = value;\n\t\t\t\t\t}\n\n\t\t\t\t\toptions.mappedProperties[fullPropertyName] = true;\n\t\t\t\t});\n\t\t\t}\n\t\t} else { //mappedRootObject is an array\n\t\t\tvar changes = [];\n\n\t\t\tvar hasKeyCallback = false;\n\t\t\tvar keyCallback = function (x) {\n\t\t\t\treturn x;\n\t\t\t}\n\t\t\tif (options[parentName] && options[parentName].key) {\n\t\t\t\tkeyCallback = options[parentName].key;\n\t\t\t\thasKeyCallback = true;\n\t\t\t}\n\n\t\t\tif (!ko.isObservable(mappedRootObject)) {\n\t\t\t\t// When creating the new observable array, also add a bunch of utility functions that take the 'key' of the array items into account.\n\t\t\t\tmappedRootObject = ko.observableArray([]);\n\n\t\t\t\tmappedRootObject.mappedRemove = function (valueOrPredicate) {\n\t\t\t\t\tvar predicate = typeof valueOrPredicate == \"function\" ? valueOrPredicate : function (value) {\n\t\t\t\t\t\t\treturn value === keyCallback(valueOrPredicate);\n\t\t\t\t\t\t};\n\t\t\t\t\treturn mappedRootObject.remove(function (item) {\n\t\t\t\t\t\treturn predicate(keyCallback(item));\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\tmappedRootObject.mappedRemoveAll = function (arrayOfValues) {\n\t\t\t\t\tvar arrayOfKeys = filterArrayByKey(arrayOfValues, keyCallback);\n\t\t\t\t\treturn mappedRootObject.remove(function (item) {\n\t\t\t\t\t\treturn ko.utils.arrayIndexOf(arrayOfKeys, keyCallback(item)) != -1;\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\tmappedRootObject.mappedDestroy = function (valueOrPredicate) {\n\t\t\t\t\tvar predicate = typeof valueOrPredicate == \"function\" ? valueOrPredicate : function (value) {\n\t\t\t\t\t\t\treturn value === keyCallback(valueOrPredicate);\n\t\t\t\t\t\t};\n\t\t\t\t\treturn mappedRootObject.destroy(function (item) {\n\t\t\t\t\t\treturn predicate(keyCallback(item));\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\tmappedRootObject.mappedDestroyAll = function (arrayOfValues) {\n\t\t\t\t\tvar arrayOfKeys = filterArrayByKey(arrayOfValues, keyCallback);\n\t\t\t\t\treturn mappedRootObject.destroy(function (item) {\n\t\t\t\t\t\treturn ko.utils.arrayIndexOf(arrayOfKeys, keyCallback(item)) != -1;\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\tmappedRootObject.mappedIndexOf = function (item) {\n\t\t\t\t\tvar keys = filterArrayByKey(mappedRootObject(), keyCallback);\n\t\t\t\t\tvar key = keyCallback(item);\n\t\t\t\t\treturn ko.utils.arrayIndexOf(keys, key);\n\t\t\t\t}\n\n\t\t\t\tmappedRootObject.mappedGet = function (item) {\n\t\t\t\t\treturn mappedRootObject()[mappedRootObject.mappedIndexOf(item)];\n\t\t\t\t}\n\n\t\t\t\tmappedRootObject.mappedCreate = function (value) {\n\t\t\t\t\tif (mappedRootObject.mappedIndexOf(value) !== -1) {\n\t\t\t\t\t\tthrow new Error(\"There already is an object with the key that you specified.\");\n\t\t\t\t\t}\n\n\t\t\t\t\tvar item = hasCreateCallback() ? createCallback(value) : value;\n\t\t\t\t\tif (hasUpdateCallback()) {\n\t\t\t\t\t\tvar newValue = updateCallback(item, value);\n\t\t\t\t\t\tif (ko.isWriteableObservable(item)) {\n\t\t\t\t\t\t\titem(newValue);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\titem = newValue;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tmappedRootObject.push(item);\n\t\t\t\t\treturn item;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvar currentArrayKeys = filterArrayByKey(ko.utils.unwrapObservable(mappedRootObject), keyCallback).sort();\n\t\t\tvar newArrayKeys = filterArrayByKey(rootObject, keyCallback);\n\t\t\tif (hasKeyCallback) newArrayKeys.sort();\n\t\t\tvar editScript = ko.utils.compareArrays(currentArrayKeys, newArrayKeys);\n\n\t\t\tvar ignoreIndexOf = {};\n\t\t\t\n\t\t\tvar i, j;\n\n\t\t\tvar unwrappedRootObject = ko.utils.unwrapObservable(rootObject);\n\t\t\tvar itemsByKey = {};\n\t\t\tvar optimizedKeys = true;\n\t\t\tfor (i = 0, j = unwrappedRootObject.length; i < j; i++) {\n\t\t\t\tvar key = keyCallback(unwrappedRootObject[i]);\n\t\t\t\tif (key === undefined || key instanceof Object) {\n\t\t\t\t\toptimizedKeys = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\titemsByKey[key] = unwrappedRootObject[i];\n\t\t\t}\n\n\t\t\tvar newContents = [];\n\t\t\tvar passedOver = 0;\n\t\t\tfor (i = 0, j = editScript.length; i < j; i++) {\n\t\t\t\tvar key = editScript[i];\n\t\t\t\tvar mappedItem;\n\t\t\t\tvar fullPropertyName = parentPropertyName + \"[\" + i + \"]\";\n\t\t\t\tswitch (key.status) {\n\t\t\t\tcase \"added\":\n\t\t\t\t\tvar item = optimizedKeys ? itemsByKey[key.value] : getItemByKey(ko.utils.unwrapObservable(rootObject), key.value, keyCallback);\n\t\t\t\t\tmappedItem = updateViewModel(undefined, item, options, parentName, mappedRootObject, fullPropertyName, parent);\n\t\t\t\t\tif(!hasCreateCallback()) {\n\t\t\t\t\t\tmappedItem = ko.utils.unwrapObservable(mappedItem);\n\t\t\t\t\t}\n\n\t\t\t\t\tvar index = ignorableIndexOf(ko.utils.unwrapObservable(rootObject), item, ignoreIndexOf);\n\t\t\t\t\t\n\t\t\t\t\tif (mappedItem === emptyReturn) {\n\t\t\t\t\t\tpassedOver++;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tnewContents[index - passedOver] = mappedItem;\n\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\tignoreIndexOf[index] = true;\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"retained\":\n\t\t\t\t\tvar item = optimizedKeys ? itemsByKey[key.value] : getItemByKey(ko.utils.unwrapObservable(rootObject), key.value, keyCallback);\n\t\t\t\t\tmappedItem = getItemByKey(mappedRootObject, key.value, keyCallback);\n\t\t\t\t\tupdateViewModel(mappedItem, item, options, parentName, mappedRootObject, fullPropertyName, parent);\n\n\t\t\t\t\tvar index = ignorableIndexOf(ko.utils.unwrapObservable(rootObject), item, ignoreIndexOf);\n\t\t\t\t\tnewContents[index] = mappedItem;\n\t\t\t\t\tignoreIndexOf[index] = true;\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"deleted\":\n\t\t\t\t\tmappedItem = getItemByKey(mappedRootObject, key.value, keyCallback);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tchanges.push({\n\t\t\t\t\tevent: key.status,\n\t\t\t\t\titem: mappedItem\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tmappedRootObject(newContents);\n\n\t\t\tif (options[parentName] && options[parentName].arrayChanged) {\n\t\t\t\tko.utils.arrayForEach(changes, function (change) {\n\t\t\t\t\toptions[parentName].arrayChanged(change.event, change.item);\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\treturn mappedRootObject;\n\t}\n\n\tfunction ignorableIndexOf(array, item, ignoreIndices) {\n\t\tfor (var i = 0, j = array.length; i < j; i++) {\n\t\t\tif (ignoreIndices[i] === true) continue;\n\t\t\tif (array[i] === item) return i;\n\t\t}\n\t\treturn null;\n\t}\n\n\tfunction mapKey(item, callback) {\n\t\tvar mappedItem;\n\t\tif (callback) mappedItem = callback(item);\n\t\tif (exports.getType(mappedItem) === \"undefined\") mappedItem = item;\n\n\t\treturn ko.utils.unwrapObservable(mappedItem);\n\t}\n\n\tfunction getItemByKey(array, key, callback) {\n\t\tarray = ko.utils.unwrapObservable(array);\n\t\tfor (var i = 0, j = array.length; i < j; i++) {\n\t\t\tvar item = array[i];\n\t\t\tif (mapKey(item, callback) === key) return item;\n\t\t}\n\n\t\tthrow new Error(\"When calling ko.update*, the key '\" + key + \"' was not found!\");\n\t}\n\n\tfunction filterArrayByKey(array, callback) {\n\t\treturn ko.utils.arrayMap(ko.utils.unwrapObservable(array), function (item) {\n\t\t\tif (callback) {\n\t\t\t\treturn mapKey(item, callback);\n\t\t\t} else {\n\t\t\t\treturn item;\n\t\t\t}\n\t\t});\n\t}\n\n\tfunction visitPropertiesOrArrayEntries(rootObject, visitorCallback) {\n\t\tif (exports.getType(rootObject) === \"array\") {\n\t\t\tfor (var i = 0; i < rootObject.length; i++)\n\t\t\tvisitorCallback(i);\n\t\t} else {\n\t\t\tfor (var propertyName in rootObject)\n\t\t\tvisitorCallback(propertyName);\n\t\t}\n\t};\n\n\tfunction canHaveProperties(object) {\n\t\tvar type = exports.getType(object);\n\t\treturn ((type === \"object\") || (type === \"array\")) && (object !== null);\n\t}\n\n\t// Based on the parentName, this creates a fully classified name of a property\n\n\tfunction getPropertyName(parentName, parent, indexer) {\n\t\tvar propertyName = parentName || \"\";\n\t\tif (exports.getType(parent) === \"array\") {\n\t\t\tif (parentName) {\n\t\t\t\tpropertyName += \"[\" + indexer + \"]\";\n\t\t\t}\n\t\t} else {\n\t\t\tif (parentName) {\n\t\t\t\tpropertyName += \".\";\n\t\t\t}\n\t\t\tpropertyName += indexer;\n\t\t}\n\t\treturn propertyName;\n\t}\n\n\texports.visitModel = function (rootObject, callback, options) {\n\t\toptions = options || {};\n\t\toptions.visitedObjects = options.visitedObjects || new objectLookup();\n\n\t\tvar mappedRootObject;\n\t\tvar unwrappedRootObject = ko.utils.unwrapObservable(rootObject);\n\n\t\tif (!canHaveProperties(unwrappedRootObject)) {\n\t\t\treturn callback(rootObject, options.parentName);\n\t\t} else {\n\t\t\toptions = fillOptions(options, unwrappedRootObject[mappingProperty]);\n\n\t\t\t// Only do a callback, but ignore the results\n\t\t\tcallback(rootObject, options.parentName);\n\t\t\tmappedRootObject = exports.getType(unwrappedRootObject) === \"array\" ? [] : {};\n\t\t}\n\n\t\toptions.visitedObjects.save(rootObject, mappedRootObject);\n\n\t\tvar parentName = options.parentName;\n\t\tvisitPropertiesOrArrayEntries(unwrappedRootObject, function (indexer) {\n\t\t\tif (options.ignore && ko.utils.arrayIndexOf(options.ignore, indexer) != -1) return;\n\n\t\t\tvar propertyValue = unwrappedRootObject[indexer];\n\t\t\toptions.parentName = getPropertyName(parentName, unwrappedRootObject, indexer);\n\n\t\t\t// If we don't want to explicitly copy the unmapped property...\n\t\t\tif (ko.utils.arrayIndexOf(options.copy, indexer) === -1) {\n\t\t\t\t// ...find out if it's a property we want to explicitly include\n\t\t\t\tif (ko.utils.arrayIndexOf(options.include, indexer) === -1) {\n\t\t\t\t\t// The mapped properties object contains all the properties that were part of the original object.\n\t\t\t\t\t// If a property does not exist, and it is not because it is part of an array (e.g. \"myProp[3]\"), then it should not be unmapped.\n\t\t\t\t    if (unwrappedRootObject[mappingProperty]\n\t\t\t\t        && unwrappedRootObject[mappingProperty].mappedProperties && !unwrappedRootObject[mappingProperty].mappedProperties[indexer]\n\t\t\t\t        && unwrappedRootObject[mappingProperty].copiedProperties && !unwrappedRootObject[mappingProperty].copiedProperties[indexer]\n\t\t\t\t        && !(exports.getType(unwrappedRootObject) === \"array\")) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvar outputProperty;\n\t\t\tswitch (exports.getType(ko.utils.unwrapObservable(propertyValue))) {\n\t\t\tcase \"object\":\n\t\t\tcase \"array\":\n\t\t\tcase \"undefined\":\n\t\t\t\tvar previouslyMappedValue = options.visitedObjects.get(propertyValue);\n\t\t\t\tmappedRootObject[indexer] = (exports.getType(previouslyMappedValue) !== \"undefined\") ? previouslyMappedValue : exports.visitModel(propertyValue, callback, options);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tmappedRootObject[indexer] = callback(propertyValue, options.parentName);\n\t\t\t}\n\t\t});\n\n\t\treturn mappedRootObject;\n\t}\n\n\tfunction simpleObjectLookup() {\n\t\tvar keys = [];\n\t\tvar values = [];\n\t\tthis.save = function (key, value) {\n\t\t\tvar existingIndex = ko.utils.arrayIndexOf(keys, key);\n\t\t\tif (existingIndex >= 0) values[existingIndex] = value;\n\t\t\telse {\n\t\t\t\tkeys.push(key);\n\t\t\t\tvalues.push(value);\n\t\t\t}\n\t\t};\n\t\tthis.get = function (key) {\n\t\t\tvar existingIndex = ko.utils.arrayIndexOf(keys, key);\n\t\t\tvar value = (existingIndex >= 0) ? values[existingIndex] : undefined;\n\t\t\treturn value;\n\t\t};\n\t};\n\t\n\tfunction objectLookup() {\n\t\tvar buckets = {};\n\t\t\n\t\tvar findBucket = function(key) {\n\t\t\tvar bucketKey;\n\t\t\ttry {\n\t\t\t\tbucketKey = key;//JSON.stringify(key);\n\t\t\t}\n\t\t\tcatch (e) {\n\t\t\t\tbucketKey = \"$$$\";\n\t\t\t}\n\n\t\t\tvar bucket = buckets[bucketKey];\n\t\t\tif (bucket === undefined) {\n\t\t\t\tbucket = new simpleObjectLookup();\n\t\t\t\tbuckets[bucketKey] = bucket;\n\t\t\t}\n\t\t\treturn bucket;\n\t\t};\n\t\t\n\t\tthis.save = function (key, value) {\n\t\t\tfindBucket(key).save(key, value);\n\t\t};\n\t\tthis.get = function (key) {\n\t\t\treturn findBucket(key).get(key);\n\t\t};\n\t};\n}));",
    "// Knockout Fast Mapping v0.1\n// License: MIT (http://www.opensource.org/licenses/mit-license.php)\n\n(function (factory) {\n\t// Module systems magic dance.\n\n\tif (typeof require === \"function\" && typeof exports === \"object\" && typeof module === \"object\") {\n\t\t// CommonJS or Node: hard-coded dependency on \"knockout\"\n\t\tfactory((typeof window !== \"undefined\" ? window['ko'] : typeof global !== \"undefined\" ? global['ko'] : null), exports);\n\t} else if (typeof define === \"function\" && define[\"amd\"]) {\n\t\t// AMD anonymous module with hard-coded dependency on \"knockout\"\n\t\tdefine([\"knockout\", \"exports\"], factory);\n\t} else {\n\t\t// <script> tag: use the global `ko` object, attaching a `wrap` property\n\t\tfactory(ko, ko.wrap = {});\n\t}\n}(function (ko, exports) {\n    \n    // this function mimics ko.mapping\n    exports.fromJS = function(jsObject, computedFunctions)\n    {\n        reset();\n\treturn wrap(jsObject, computedFunctions);\n    }\n\n    // this function unwraps the outer for assigning the result to an observable\n    // see https://github.com/SteveSanderson/knockout/issues/517\n    exports.updateFromJS = function(observable, jsObject, computedFunctions)\n    {\n        reset();\n\treturn observable(ko.utils.unwrapObservable(wrap(jsObject, computedFunctions)));\n    }\n\n    exports.fromJSON = function (jsonString, computedFunctions) {\n\tvar parsed = ko.utils.parseJson(jsonString);\n\targuments[0] = parsed;\n\treturn exports.fromJS.apply(this, computedFunctions);\n    };\n    \n    exports.toJS = function (observable) {\n\treturn unwrap(observable);\n    }\n\n    exports.toJSON = function (observable) {\n\tvar plainJavaScriptObject = exports.toJS(observable);\n\treturn ko.utils.stringifyJson(plainJavaScriptObject);\n    };\n\n    function typeOf(value) {\n\tvar s = typeof value;\n\tif (s === 'object') {\n            if (value) {\n                if (value.constructor == Date)\n                    s = 'date';\n\t\telse if (Object.prototype.toString.call(value) == '[object Array]')\n                    s = 'array';\n            } else {\n\t\ts = 'null';\n            }\n\t}\n\treturn s;\n    }\n\n    // unwrapping\n    function unwrapObject(o)\n    {\n\tvar t = {};\n\n\tfor (var k in o)\n\t{\n\t    var v = o[k];\n\n\t    if (ko.isComputed(v))\n\t\tcontinue;\n\n\t    t[k] = unwrap(v);\n\t}\n\n\treturn t;\n    }\n\n    function unwrapArray(a)\n    {\n\tvar r = [];\n\n\tif (!a || a.length == 0)\n\t    return r;\n\t\n\tfor (var i = 0, l = a.length; i < l; ++i)\n\t    r.push(unwrap(a[i]));\n\n\treturn r;\n    }\n\n    function unwrap(v)\n    {\n\tvar isObservable = ko.isObservable(v);\n\n\tif (isObservable)\n\t{\n\t    var val = v();\n\n\t    return unwrap(val);\n\t}\n\telse\n\t{\n\t    if (typeOf(v) == \"array\")\n\t    {\n\t\treturn unwrapArray(v);\n\t    }\n\t    else if (typeOf(v) == \"object\")\n\t    {\n\t\treturn unwrapObject(v);\n\t    }\n\t    else\n\t    {\n\t\treturn v;\n\t    }\n\t}\n    }\n\n    function reset()\n    {\n        parents = [{obj: null, wrapped: null, lvl: \"\"}];\n    }    \n    \n    // wrapping\n\n    function wrapObject(o, computedFunctions)\n    {\n        // check for infinite recursion\n        for (var i = 0; i < parents.length; ++i) {\n            if (parents[i].obj === o) {\n                return parents[i].wrapped;\n            }\n        }\n\n\tvar t = {};\n\n\tfor (var k in o)\n\t{\n\t    var v = o[k];\n\n            parents.push({obj: o, wrapped: t, lvl: currentLvl() + \"/\" + k});\n\n\t    t[k] = wrap(v, computedFunctions);\n\n            parents.pop();\n\t}\n\n\tif (computedFunctions && computedFunctions[currentLvl()])\n\t    t = computedFunctions[currentLvl()](t);\n\n        if (hasES5Plugin())\n            ko.track(t);\n\n\treturn t;\n    }\n\n    function wrapArray(a, computedFunctions)\n    {\n\tvar r = ko.observableArray();\n\n\tif (!a || a.length == 0)\n\t    return r;\n\n\tfor (var i = 0, l = a.length; i < l; ++i)\n\t    r.push(wrap(a[i], computedFunctions));\n\n\treturn r;\n    }\n\n    // a stack, used for two purposes:\n    //  - circular reference checking\n    //  - computed functions\n    var parents;\n\n    function currentLvl()\n    {\n\treturn parents[parents.length-1].lvl;\n    }\n\n    function wrap(v, computedFunctions)\n    {\n\tif (typeOf(v) == \"array\")\n\t{\n\t    return wrapArray(v, computedFunctions);\n\t}\n\telse if (typeOf(v) == \"object\")\n\t{\n\t    return wrapObject(v, computedFunctions);\n\t}\n\telse\n\t{\n            if (!hasES5Plugin() && typeof v !== 'function')\n            {\n\t        var t = ko.observable();\n\t        t(v);\n\t        return t;\n            } else\n                return v;\n\t}\n    }\n\n    function hasES5Plugin()\n    {\n        return ko.track != null;\n    }\n}));",
    "module.exports=[\n    \"special_bonus_unique_alchemist\",\n    \"special_bonus_unique_ancient_apparition_3\",\n    \"special_bonus_unique_antimage\",\n    \"special_bonus_unique_antimage_2\",\n    \"special_bonus_unique_batrider_2\",\n    \"special_bonus_unique_bloodseeker\",\n    \"special_bonus_unique_brewmaster_2\",\n    \"special_bonus_unique_chen_3\",\n    \"special_bonus_unique_dazzle_1\",\n    \"special_bonus_unique_death_prophet_2\",\n    \"special_bonus_unique_disruptor_2\",\n    \"special_bonus_unique_disruptor_4\",\n    \"special_bonus_unique_earthshaker\",\n    \"special_bonus_unique_elder_titan_3\",\n    \"special_bonus_unique_furion_4\",\n    \"special_bonus_unique_furion_3\",\n    \"special_bonus_unique_gyrocopter_4\",\n    \"special_bonus_unique_huskar_3\",\n    \"special_bonus_unique_invoker_3\",\n    \"special_bonus_unique_legion_commander_2\",\n    \"special_bonus_unique_lich_3\",\n    \"special_bonus_unique_lina_1\",\n    \"special_bonus_unique_lone_druid_4\",\n    \"special_bonus_unique_lone_druid_8\",\n    \"special_bonus_unique_lone_druid_9\",\n    \"special_bonus_unique_luna_2\",\n    \"special_bonus_unique_meepo_3\",\n    \"special_bonus_unique_meepo\",\n    \"special_bonus_unique_mirana_4\",\n    \"special_bonus_unique_naga_siren_2\",\n    \"special_bonus_unique_necrophos\",\n    \"special_bonus_unique_night_stalker\",\n    \"special_bonus_unique_oracle_3\",\n    \"special_bonus_unique_pangolier_4\",\n    \"special_bonus_unique_puck_2\",\n    \"special_bonus_unique_pugna_4\",\n    \"special_bonus_unique_riki_2\",\n    \"special_bonus_unique_rubick_4\",\n    \"special_bonus_unique_shadow_demon_2\",\n    \"special_bonus_unique_shadow_demon_3\",\n    \"special_bonus_unique_shadow_shaman_5\",\n    \"special_bonus_unique_skywrath\",\n    \"special_bonus_unique_spectre\",\n    \"special_bonus_unique_sven\",\n    \"special_bonus_unique_techies_3\",\n    \"special_bonus_unique_terrorblade_2\",\n    \"special_bonus_unique_terrorblade\",\n    \"special_bonus_unique_tiny_3\",\n    \"special_bonus_unique_troll_warlord\",\n    \"special_bonus_unique_tusk_5\",\n    \"special_bonus_unique_undying_2\",\n    \"special_bonus_unique_ursa_2\",\n    \"special_bonus_unique_vengeful_spirit_6\",\n    \"special_bonus_unique_vengeful_spirit_5\",\n    \"special_bonus_unique_warlock_3\",\n    \"special_bonus_unique_winter_wyvern_2\"\n]",
    "var extend = function (out) {\n    out = out || {};\n\n    for (var i = 1; i < arguments.length; i++) {\n        var obj = arguments[i];\n\n        if (!obj)\n            continue;\n\n        for (var key in obj) {\n            if (obj.hasOwnProperty(key)) {\n                if (typeof obj[key] === 'object')\n                    out[key] = extend(out[key], obj[key]);\n                else\n                    out[key] = obj[key];\n            }\n        }\n    }\n\n    return out;\n};\n\nmodule.exports = extend;",
    "var findWhere = function (arr, obj) {\n    arrLoop: for (var i = 0; i < arr.length; i++) {\n        objLoop: for (var key in obj) {\n            if (arr[i][key] != obj[key]) {\n                continue arrLoop;\n            }\n        }\n        return arr[i];\n    }\n}\n\nmodule.exports = findWhere;",
    "/*! Hammer.JS - v2.0.7 - 2016-04-22\n * http://hammerjs.github.io/\n *\n * Copyright (c) 2016 Jorik Tangelder;\n * Licensed under the MIT license */\n(function(window, document, exportName, undefined) {\n  'use strict';\n\nvar VENDOR_PREFIXES = ['', 'webkit', 'Moz', 'MS', 'ms', 'o'];\nvar TEST_ELEMENT = document.createElement('div');\n\nvar TYPE_FUNCTION = 'function';\n\nvar round = Math.round;\nvar abs = Math.abs;\nvar now = Date.now;\n\n/**\n * set a timeout with a given scope\n * @param {Function} fn\n * @param {Number} timeout\n * @param {Object} context\n * @returns {number}\n */\nfunction setTimeoutContext(fn, timeout, context) {\n    return setTimeout(bindFn(fn, context), timeout);\n}\n\n/**\n * if the argument is an array, we want to execute the fn on each entry\n * if it aint an array we don't want to do a thing.\n * this is used by all the methods that accept a single and array argument.\n * @param {*|Array} arg\n * @param {String} fn\n * @param {Object} [context]\n * @returns {Boolean}\n */\nfunction invokeArrayArg(arg, fn, context) {\n    if (Array.isArray(arg)) {\n        each(arg, context[fn], context);\n        return true;\n    }\n    return false;\n}\n\n/**\n * walk objects and arrays\n * @param {Object} obj\n * @param {Function} iterator\n * @param {Object} context\n */\nfunction each(obj, iterator, context) {\n    var i;\n\n    if (!obj) {\n        return;\n    }\n\n    if (obj.forEach) {\n        obj.forEach(iterator, context);\n    } else if (obj.length !== undefined) {\n        i = 0;\n        while (i < obj.length) {\n            iterator.call(context, obj[i], i, obj);\n            i++;\n        }\n    } else {\n        for (i in obj) {\n            obj.hasOwnProperty(i) && iterator.call(context, obj[i], i, obj);\n        }\n    }\n}\n\n/**\n * wrap a method with a deprecation warning and stack trace\n * @param {Function} method\n * @param {String} name\n * @param {String} message\n * @returns {Function} A new function wrapping the supplied method.\n */\nfunction deprecate(method, name, message) {\n    var deprecationMessage = 'DEPRECATED METHOD: ' + name + '\\n' + message + ' AT \\n';\n    return function() {\n        var e = new Error('get-stack-trace');\n        var stack = e && e.stack ? e.stack.replace(/^[^\\(]+?[\\n$]/gm, '')\n            .replace(/^\\s+at\\s+/gm, '')\n            .replace(/^Object.<anonymous>\\s*\\(/gm, '{anonymous}()@') : 'Unknown Stack Trace';\n\n        var log = window.console && (window.console.warn || window.console.log);\n        if (log) {\n            log.call(window.console, deprecationMessage, stack);\n        }\n        return method.apply(this, arguments);\n    };\n}\n\n/**\n * extend object.\n * means that properties in dest will be overwritten by the ones in src.\n * @param {Object} target\n * @param {...Object} objects_to_assign\n * @returns {Object} target\n */\nvar assign;\nif (typeof Object.assign !== 'function') {\n    assign = function assign(target) {\n        if (target === undefined || target === null) {\n            throw new TypeError('Cannot convert undefined or null to object');\n        }\n\n        var output = Object(target);\n        for (var index = 1; index < arguments.length; index++) {\n            var source = arguments[index];\n            if (source !== undefined && source !== null) {\n                for (var nextKey in source) {\n                    if (source.hasOwnProperty(nextKey)) {\n                        output[nextKey] = source[nextKey];\n                    }\n                }\n            }\n        }\n        return output;\n    };\n} else {\n    assign = Object.assign;\n}\n\n/**\n * extend object.\n * means that properties in dest will be overwritten by the ones in src.\n * @param {Object} dest\n * @param {Object} src\n * @param {Boolean} [merge=false]\n * @returns {Object} dest\n */\nvar extend = deprecate(function extend(dest, src, merge) {\n    var keys = Object.keys(src);\n    var i = 0;\n    while (i < keys.length) {\n        if (!merge || (merge && dest[keys[i]] === undefined)) {\n            dest[keys[i]] = src[keys[i]];\n        }\n        i++;\n    }\n    return dest;\n}, 'extend', 'Use `assign`.');\n\n/**\n * merge the values from src in the dest.\n * means that properties that exist in dest will not be overwritten by src\n * @param {Object} dest\n * @param {Object} src\n * @returns {Object} dest\n */\nvar merge = deprecate(function merge(dest, src) {\n    return extend(dest, src, true);\n}, 'merge', 'Use `assign`.');\n\n/**\n * simple class inheritance\n * @param {Function} child\n * @param {Function} base\n * @param {Object} [properties]\n */\nfunction inherit(child, base, properties) {\n    var baseP = base.prototype,\n        childP;\n\n    childP = child.prototype = Object.create(baseP);\n    childP.constructor = child;\n    childP._super = baseP;\n\n    if (properties) {\n        assign(childP, properties);\n    }\n}\n\n/**\n * simple function bind\n * @param {Function} fn\n * @param {Object} context\n * @returns {Function}\n */\nfunction bindFn(fn, context) {\n    return function boundFn() {\n        return fn.apply(context, arguments);\n    };\n}\n\n/**\n * let a boolean value also be a function that must return a boolean\n * this first item in args will be used as the context\n * @param {Boolean|Function} val\n * @param {Array} [args]\n * @returns {Boolean}\n */\nfunction boolOrFn(val, args) {\n    if (typeof val == TYPE_FUNCTION) {\n        return val.apply(args ? args[0] || undefined : undefined, args);\n    }\n    return val;\n}\n\n/**\n * use the val2 when val1 is undefined\n * @param {*} val1\n * @param {*} val2\n * @returns {*}\n */\nfunction ifUndefined(val1, val2) {\n    return (val1 === undefined) ? val2 : val1;\n}\n\n/**\n * addEventListener with multiple events at once\n * @param {EventTarget} target\n * @param {String} types\n * @param {Function} handler\n */\nfunction addEventListeners(target, types, handler) {\n    each(splitStr(types), function(type) {\n        target.addEventListener(type, handler, false);\n    });\n}\n\n/**\n * removeEventListener with multiple events at once\n * @param {EventTarget} target\n * @param {String} types\n * @param {Function} handler\n */\nfunction removeEventListeners(target, types, handler) {\n    each(splitStr(types), function(type) {\n        target.removeEventListener(type, handler, false);\n    });\n}\n\n/**\n * find if a node is in the given parent\n * @method hasParent\n * @param {HTMLElement} node\n * @param {HTMLElement} parent\n * @return {Boolean} found\n */\nfunction hasParent(node, parent) {\n    while (node) {\n        if (node == parent) {\n            return true;\n        }\n        node = node.parentNode;\n    }\n    return false;\n}\n\n/**\n * small indexOf wrapper\n * @param {String} str\n * @param {String} find\n * @returns {Boolean} found\n */\nfunction inStr(str, find) {\n    return str.indexOf(find) > -1;\n}\n\n/**\n * split string on whitespace\n * @param {String} str\n * @returns {Array} words\n */\nfunction splitStr(str) {\n    return str.trim().split(/\\s+/g);\n}\n\n/**\n * find if a array contains the object using indexOf or a simple polyFill\n * @param {Array} src\n * @param {String} find\n * @param {String} [findByKey]\n * @return {Boolean|Number} false when not found, or the index\n */\nfunction inArray(src, find, findByKey) {\n    if (src.indexOf && !findByKey) {\n        return src.indexOf(find);\n    } else {\n        var i = 0;\n        while (i < src.length) {\n            if ((findByKey && src[i][findByKey] == find) || (!findByKey && src[i] === find)) {\n                return i;\n            }\n            i++;\n        }\n        return -1;\n    }\n}\n\n/**\n * convert array-like objects to real arrays\n * @param {Object} obj\n * @returns {Array}\n */\nfunction toArray(obj) {\n    return Array.prototype.slice.call(obj, 0);\n}\n\n/**\n * unique array with objects based on a key (like 'id') or just by the array's value\n * @param {Array} src [{id:1},{id:2},{id:1}]\n * @param {String} [key]\n * @param {Boolean} [sort=False]\n * @returns {Array} [{id:1},{id:2}]\n */\nfunction uniqueArray(src, key, sort) {\n    var results = [];\n    var values = [];\n    var i = 0;\n\n    while (i < src.length) {\n        var val = key ? src[i][key] : src[i];\n        if (inArray(values, val) < 0) {\n            results.push(src[i]);\n        }\n        values[i] = val;\n        i++;\n    }\n\n    if (sort) {\n        if (!key) {\n            results = results.sort();\n        } else {\n            results = results.sort(function sortUniqueArray(a, b) {\n                return a[key] > b[key];\n            });\n        }\n    }\n\n    return results;\n}\n\n/**\n * get the prefixed property\n * @param {Object} obj\n * @param {String} property\n * @returns {String|Undefined} prefixed\n */\nfunction prefixed(obj, property) {\n    var prefix, prop;\n    var camelProp = property[0].toUpperCase() + property.slice(1);\n\n    var i = 0;\n    while (i < VENDOR_PREFIXES.length) {\n        prefix = VENDOR_PREFIXES[i];\n        prop = (prefix) ? prefix + camelProp : property;\n\n        if (prop in obj) {\n            return prop;\n        }\n        i++;\n    }\n    return undefined;\n}\n\n/**\n * get a unique id\n * @returns {number} uniqueId\n */\nvar _uniqueId = 1;\nfunction uniqueId() {\n    return _uniqueId++;\n}\n\n/**\n * get the window object of an element\n * @param {HTMLElement} element\n * @returns {DocumentView|Window}\n */\nfunction getWindowForElement(element) {\n    var doc = element.ownerDocument || element;\n    return (doc.defaultView || doc.parentWindow || window);\n}\n\nvar MOBILE_REGEX = /mobile|tablet|ip(ad|hone|od)|android/i;\n\nvar SUPPORT_TOUCH = ('ontouchstart' in window);\nvar SUPPORT_POINTER_EVENTS = prefixed(window, 'PointerEvent') !== undefined;\nvar SUPPORT_ONLY_TOUCH = SUPPORT_TOUCH && MOBILE_REGEX.test(navigator.userAgent);\n\nvar INPUT_TYPE_TOUCH = 'touch';\nvar INPUT_TYPE_PEN = 'pen';\nvar INPUT_TYPE_MOUSE = 'mouse';\nvar INPUT_TYPE_KINECT = 'kinect';\n\nvar COMPUTE_INTERVAL = 25;\n\nvar INPUT_START = 1;\nvar INPUT_MOVE = 2;\nvar INPUT_END = 4;\nvar INPUT_CANCEL = 8;\n\nvar DIRECTION_NONE = 1;\nvar DIRECTION_LEFT = 2;\nvar DIRECTION_RIGHT = 4;\nvar DIRECTION_UP = 8;\nvar DIRECTION_DOWN = 16;\n\nvar DIRECTION_HORIZONTAL = DIRECTION_LEFT | DIRECTION_RIGHT;\nvar DIRECTION_VERTICAL = DIRECTION_UP | DIRECTION_DOWN;\nvar DIRECTION_ALL = DIRECTION_HORIZONTAL | DIRECTION_VERTICAL;\n\nvar PROPS_XY = ['x', 'y'];\nvar PROPS_CLIENT_XY = ['clientX', 'clientY'];\n\n/**\n * create new input type manager\n * @param {Manager} manager\n * @param {Function} callback\n * @returns {Input}\n * @constructor\n */\nfunction Input(manager, callback) {\n    var self = this;\n    this.manager = manager;\n    this.callback = callback;\n    this.element = manager.element;\n    this.target = manager.options.inputTarget;\n\n    // smaller wrapper around the handler, for the scope and the enabled state of the manager,\n    // so when disabled the input events are completely bypassed.\n    this.domHandler = function(ev) {\n        if (boolOrFn(manager.options.enable, [manager])) {\n            self.handler(ev);\n        }\n    };\n\n    this.init();\n\n}\n\nInput.prototype = {\n    /**\n     * should handle the inputEvent data and trigger the callback\n     * @virtual\n     */\n    handler: function() { },\n\n    /**\n     * bind the events\n     */\n    init: function() {\n        this.evEl && addEventListeners(this.element, this.evEl, this.domHandler);\n        this.evTarget && addEventListeners(this.target, this.evTarget, this.domHandler);\n        this.evWin && addEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);\n    },\n\n    /**\n     * unbind the events\n     */\n    destroy: function() {\n        this.evEl && removeEventListeners(this.element, this.evEl, this.domHandler);\n        this.evTarget && removeEventListeners(this.target, this.evTarget, this.domHandler);\n        this.evWin && removeEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);\n    }\n};\n\n/**\n * create new input type manager\n * called by the Manager constructor\n * @param {Hammer} manager\n * @returns {Input}\n */\nfunction createInputInstance(manager) {\n    var Type;\n    var inputClass = manager.options.inputClass;\n\n    if (inputClass) {\n        Type = inputClass;\n    } else if (SUPPORT_POINTER_EVENTS) {\n        Type = PointerEventInput;\n    } else if (SUPPORT_ONLY_TOUCH) {\n        Type = TouchInput;\n    } else if (!SUPPORT_TOUCH) {\n        Type = MouseInput;\n    } else {\n        Type = TouchMouseInput;\n    }\n    return new (Type)(manager, inputHandler);\n}\n\n/**\n * handle input events\n * @param {Manager} manager\n * @param {String} eventType\n * @param {Object} input\n */\nfunction inputHandler(manager, eventType, input) {\n    var pointersLen = input.pointers.length;\n    var changedPointersLen = input.changedPointers.length;\n    var isFirst = (eventType & INPUT_START && (pointersLen - changedPointersLen === 0));\n    var isFinal = (eventType & (INPUT_END | INPUT_CANCEL) && (pointersLen - changedPointersLen === 0));\n\n    input.isFirst = !!isFirst;\n    input.isFinal = !!isFinal;\n\n    if (isFirst) {\n        manager.session = {};\n    }\n\n    // source event is the normalized value of the domEvents\n    // like 'touchstart, mouseup, pointerdown'\n    input.eventType = eventType;\n\n    // compute scale, rotation etc\n    computeInputData(manager, input);\n\n    // emit secret event\n    manager.emit('hammer.input', input);\n\n    manager.recognize(input);\n    manager.session.prevInput = input;\n}\n\n/**\n * extend the data with some usable properties like scale, rotate, velocity etc\n * @param {Object} manager\n * @param {Object} input\n */\nfunction computeInputData(manager, input) {\n    var session = manager.session;\n    var pointers = input.pointers;\n    var pointersLength = pointers.length;\n\n    // store the first input to calculate the distance and direction\n    if (!session.firstInput) {\n        session.firstInput = simpleCloneInputData(input);\n    }\n\n    // to compute scale and rotation we need to store the multiple touches\n    if (pointersLength > 1 && !session.firstMultiple) {\n        session.firstMultiple = simpleCloneInputData(input);\n    } else if (pointersLength === 1) {\n        session.firstMultiple = false;\n    }\n\n    var firstInput = session.firstInput;\n    var firstMultiple = session.firstMultiple;\n    var offsetCenter = firstMultiple ? firstMultiple.center : firstInput.center;\n\n    var center = input.center = getCenter(pointers);\n    input.timeStamp = now();\n    input.deltaTime = input.timeStamp - firstInput.timeStamp;\n\n    input.angle = getAngle(offsetCenter, center);\n    input.distance = getDistance(offsetCenter, center);\n\n    computeDeltaXY(session, input);\n    input.offsetDirection = getDirection(input.deltaX, input.deltaY);\n\n    var overallVelocity = getVelocity(input.deltaTime, input.deltaX, input.deltaY);\n    input.overallVelocityX = overallVelocity.x;\n    input.overallVelocityY = overallVelocity.y;\n    input.overallVelocity = (abs(overallVelocity.x) > abs(overallVelocity.y)) ? overallVelocity.x : overallVelocity.y;\n\n    input.scale = firstMultiple ? getScale(firstMultiple.pointers, pointers) : 1;\n    input.rotation = firstMultiple ? getRotation(firstMultiple.pointers, pointers) : 0;\n\n    input.maxPointers = !session.prevInput ? input.pointers.length : ((input.pointers.length >\n        session.prevInput.maxPointers) ? input.pointers.length : session.prevInput.maxPointers);\n\n    computeIntervalInputData(session, input);\n\n    // find the correct target\n    var target = manager.element;\n    if (hasParent(input.srcEvent.target, target)) {\n        target = input.srcEvent.target;\n    }\n    input.target = target;\n}\n\nfunction computeDeltaXY(session, input) {\n    var center = input.center;\n    var offset = session.offsetDelta || {};\n    var prevDelta = session.prevDelta || {};\n    var prevInput = session.prevInput || {};\n\n    if (input.eventType === INPUT_START || prevInput.eventType === INPUT_END) {\n        prevDelta = session.prevDelta = {\n            x: prevInput.deltaX || 0,\n            y: prevInput.deltaY || 0\n        };\n\n        offset = session.offsetDelta = {\n            x: center.x,\n            y: center.y\n        };\n    }\n\n    input.deltaX = prevDelta.x + (center.x - offset.x);\n    input.deltaY = prevDelta.y + (center.y - offset.y);\n}\n\n/**\n * velocity is calculated every x ms\n * @param {Object} session\n * @param {Object} input\n */\nfunction computeIntervalInputData(session, input) {\n    var last = session.lastInterval || input,\n        deltaTime = input.timeStamp - last.timeStamp,\n        velocity, velocityX, velocityY, direction;\n\n    if (input.eventType != INPUT_CANCEL && (deltaTime > COMPUTE_INTERVAL || last.velocity === undefined)) {\n        var deltaX = input.deltaX - last.deltaX;\n        var deltaY = input.deltaY - last.deltaY;\n\n        var v = getVelocity(deltaTime, deltaX, deltaY);\n        velocityX = v.x;\n        velocityY = v.y;\n        velocity = (abs(v.x) > abs(v.y)) ? v.x : v.y;\n        direction = getDirection(deltaX, deltaY);\n\n        session.lastInterval = input;\n    } else {\n        // use latest velocity info if it doesn't overtake a minimum period\n        velocity = last.velocity;\n        velocityX = last.velocityX;\n        velocityY = last.velocityY;\n        direction = last.direction;\n    }\n\n    input.velocity = velocity;\n    input.velocityX = velocityX;\n    input.velocityY = velocityY;\n    input.direction = direction;\n}\n\n/**\n * create a simple clone from the input used for storage of firstInput and firstMultiple\n * @param {Object} input\n * @returns {Object} clonedInputData\n */\nfunction simpleCloneInputData(input) {\n    // make a simple copy of the pointers because we will get a reference if we don't\n    // we only need clientXY for the calculations\n    var pointers = [];\n    var i = 0;\n    while (i < input.pointers.length) {\n        pointers[i] = {\n            clientX: round(input.pointers[i].clientX),\n            clientY: round(input.pointers[i].clientY)\n        };\n        i++;\n    }\n\n    return {\n        timeStamp: now(),\n        pointers: pointers,\n        center: getCenter(pointers),\n        deltaX: input.deltaX,\n        deltaY: input.deltaY\n    };\n}\n\n/**\n * get the center of all the pointers\n * @param {Array} pointers\n * @return {Object} center contains `x` and `y` properties\n */\nfunction getCenter(pointers) {\n    var pointersLength = pointers.length;\n\n    // no need to loop when only one touch\n    if (pointersLength === 1) {\n        return {\n            x: round(pointers[0].clientX),\n            y: round(pointers[0].clientY)\n        };\n    }\n\n    var x = 0, y = 0, i = 0;\n    while (i < pointersLength) {\n        x += pointers[i].clientX;\n        y += pointers[i].clientY;\n        i++;\n    }\n\n    return {\n        x: round(x / pointersLength),\n        y: round(y / pointersLength)\n    };\n}\n\n/**\n * calculate the velocity between two points. unit is in px per ms.\n * @param {Number} deltaTime\n * @param {Number} x\n * @param {Number} y\n * @return {Object} velocity `x` and `y`\n */\nfunction getVelocity(deltaTime, x, y) {\n    return {\n        x: x / deltaTime || 0,\n        y: y / deltaTime || 0\n    };\n}\n\n/**\n * get the direction between two points\n * @param {Number} x\n * @param {Number} y\n * @return {Number} direction\n */\nfunction getDirection(x, y) {\n    if (x === y) {\n        return DIRECTION_NONE;\n    }\n\n    if (abs(x) >= abs(y)) {\n        return x < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;\n    }\n    return y < 0 ? DIRECTION_UP : DIRECTION_DOWN;\n}\n\n/**\n * calculate the absolute distance between two points\n * @param {Object} p1 {x, y}\n * @param {Object} p2 {x, y}\n * @param {Array} [props] containing x and y keys\n * @return {Number} distance\n */\nfunction getDistance(p1, p2, props) {\n    if (!props) {\n        props = PROPS_XY;\n    }\n    var x = p2[props[0]] - p1[props[0]],\n        y = p2[props[1]] - p1[props[1]];\n\n    return Math.sqrt((x * x) + (y * y));\n}\n\n/**\n * calculate the angle between two coordinates\n * @param {Object} p1\n * @param {Object} p2\n * @param {Array} [props] containing x and y keys\n * @return {Number} angle\n */\nfunction getAngle(p1, p2, props) {\n    if (!props) {\n        props = PROPS_XY;\n    }\n    var x = p2[props[0]] - p1[props[0]],\n        y = p2[props[1]] - p1[props[1]];\n    return Math.atan2(y, x) * 180 / Math.PI;\n}\n\n/**\n * calculate the rotation degrees between two pointersets\n * @param {Array} start array of pointers\n * @param {Array} end array of pointers\n * @return {Number} rotation\n */\nfunction getRotation(start, end) {\n    return getAngle(end[1], end[0], PROPS_CLIENT_XY) + getAngle(start[1], start[0], PROPS_CLIENT_XY);\n}\n\n/**\n * calculate the scale factor between two pointersets\n * no scale is 1, and goes down to 0 when pinched together, and bigger when pinched out\n * @param {Array} start array of pointers\n * @param {Array} end array of pointers\n * @return {Number} scale\n */\nfunction getScale(start, end) {\n    return getDistance(end[0], end[1], PROPS_CLIENT_XY) / getDistance(start[0], start[1], PROPS_CLIENT_XY);\n}\n\nvar MOUSE_INPUT_MAP = {\n    mousedown: INPUT_START,\n    mousemove: INPUT_MOVE,\n    mouseup: INPUT_END\n};\n\nvar MOUSE_ELEMENT_EVENTS = 'mousedown';\nvar MOUSE_WINDOW_EVENTS = 'mousemove mouseup';\n\n/**\n * Mouse events input\n * @constructor\n * @extends Input\n */\nfunction MouseInput() {\n    this.evEl = MOUSE_ELEMENT_EVENTS;\n    this.evWin = MOUSE_WINDOW_EVENTS;\n\n    this.pressed = false; // mousedown state\n\n    Input.apply(this, arguments);\n}\n\ninherit(MouseInput, Input, {\n    /**\n     * handle mouse events\n     * @param {Object} ev\n     */\n    handler: function MEhandler(ev) {\n        var eventType = MOUSE_INPUT_MAP[ev.type];\n\n        // on start we want to have the left mouse button down\n        if (eventType & INPUT_START && ev.button === 0) {\n            this.pressed = true;\n        }\n\n        if (eventType & INPUT_MOVE && ev.which !== 1) {\n            eventType = INPUT_END;\n        }\n\n        // mouse must be down\n        if (!this.pressed) {\n            return;\n        }\n\n        if (eventType & INPUT_END) {\n            this.pressed = false;\n        }\n\n        this.callback(this.manager, eventType, {\n            pointers: [ev],\n            changedPointers: [ev],\n            pointerType: INPUT_TYPE_MOUSE,\n            srcEvent: ev\n        });\n    }\n});\n\nvar POINTER_INPUT_MAP = {\n    pointerdown: INPUT_START,\n    pointermove: INPUT_MOVE,\n    pointerup: INPUT_END,\n    pointercancel: INPUT_CANCEL,\n    pointerout: INPUT_CANCEL\n};\n\n// in IE10 the pointer types is defined as an enum\nvar IE10_POINTER_TYPE_ENUM = {\n    2: INPUT_TYPE_TOUCH,\n    3: INPUT_TYPE_PEN,\n    4: INPUT_TYPE_MOUSE,\n    5: INPUT_TYPE_KINECT // see https://twitter.com/jacobrossi/status/480596438489890816\n};\n\nvar POINTER_ELEMENT_EVENTS = 'pointerdown';\nvar POINTER_WINDOW_EVENTS = 'pointermove pointerup pointercancel';\n\n// IE10 has prefixed support, and case-sensitive\nif (window.MSPointerEvent && !window.PointerEvent) {\n    POINTER_ELEMENT_EVENTS = 'MSPointerDown';\n    POINTER_WINDOW_EVENTS = 'MSPointerMove MSPointerUp MSPointerCancel';\n}\n\n/**\n * Pointer events input\n * @constructor\n * @extends Input\n */\nfunction PointerEventInput() {\n    this.evEl = POINTER_ELEMENT_EVENTS;\n    this.evWin = POINTER_WINDOW_EVENTS;\n\n    Input.apply(this, arguments);\n\n    this.store = (this.manager.session.pointerEvents = []);\n}\n\ninherit(PointerEventInput, Input, {\n    /**\n     * handle mouse events\n     * @param {Object} ev\n     */\n    handler: function PEhandler(ev) {\n        var store = this.store;\n        var removePointer = false;\n\n        var eventTypeNormalized = ev.type.toLowerCase().replace('ms', '');\n        var eventType = POINTER_INPUT_MAP[eventTypeNormalized];\n        var pointerType = IE10_POINTER_TYPE_ENUM[ev.pointerType] || ev.pointerType;\n\n        var isTouch = (pointerType == INPUT_TYPE_TOUCH);\n\n        // get index of the event in the store\n        var storeIndex = inArray(store, ev.pointerId, 'pointerId');\n\n        // start and mouse must be down\n        if (eventType & INPUT_START && (ev.button === 0 || isTouch)) {\n            if (storeIndex < 0) {\n                store.push(ev);\n                storeIndex = store.length - 1;\n            }\n        } else if (eventType & (INPUT_END | INPUT_CANCEL)) {\n            removePointer = true;\n        }\n\n        // it not found, so the pointer hasn't been down (so it's probably a hover)\n        if (storeIndex < 0) {\n            return;\n        }\n\n        // update the event in the store\n        store[storeIndex] = ev;\n\n        this.callback(this.manager, eventType, {\n            pointers: store,\n            changedPointers: [ev],\n            pointerType: pointerType,\n            srcEvent: ev\n        });\n\n        if (removePointer) {\n            // remove from the store\n            store.splice(storeIndex, 1);\n        }\n    }\n});\n\nvar SINGLE_TOUCH_INPUT_MAP = {\n    touchstart: INPUT_START,\n    touchmove: INPUT_MOVE,\n    touchend: INPUT_END,\n    touchcancel: INPUT_CANCEL\n};\n\nvar SINGLE_TOUCH_TARGET_EVENTS = 'touchstart';\nvar SINGLE_TOUCH_WINDOW_EVENTS = 'touchstart touchmove touchend touchcancel';\n\n/**\n * Touch events input\n * @constructor\n * @extends Input\n */\nfunction SingleTouchInput() {\n    this.evTarget = SINGLE_TOUCH_TARGET_EVENTS;\n    this.evWin = SINGLE_TOUCH_WINDOW_EVENTS;\n    this.started = false;\n\n    Input.apply(this, arguments);\n}\n\ninherit(SingleTouchInput, Input, {\n    handler: function TEhandler(ev) {\n        var type = SINGLE_TOUCH_INPUT_MAP[ev.type];\n\n        // should we handle the touch events?\n        if (type === INPUT_START) {\n            this.started = true;\n        }\n\n        if (!this.started) {\n            return;\n        }\n\n        var touches = normalizeSingleTouches.call(this, ev, type);\n\n        // when done, reset the started state\n        if (type & (INPUT_END | INPUT_CANCEL) && touches[0].length - touches[1].length === 0) {\n            this.started = false;\n        }\n\n        this.callback(this.manager, type, {\n            pointers: touches[0],\n            changedPointers: touches[1],\n            pointerType: INPUT_TYPE_TOUCH,\n            srcEvent: ev\n        });\n    }\n});\n\n/**\n * @this {TouchInput}\n * @param {Object} ev\n * @param {Number} type flag\n * @returns {undefined|Array} [all, changed]\n */\nfunction normalizeSingleTouches(ev, type) {\n    var all = toArray(ev.touches);\n    var changed = toArray(ev.changedTouches);\n\n    if (type & (INPUT_END | INPUT_CANCEL)) {\n        all = uniqueArray(all.concat(changed), 'identifier', true);\n    }\n\n    return [all, changed];\n}\n\nvar TOUCH_INPUT_MAP = {\n    touchstart: INPUT_START,\n    touchmove: INPUT_MOVE,\n    touchend: INPUT_END,\n    touchcancel: INPUT_CANCEL\n};\n\nvar TOUCH_TARGET_EVENTS = 'touchstart touchmove touchend touchcancel';\n\n/**\n * Multi-user touch events input\n * @constructor\n * @extends Input\n */\nfunction TouchInput() {\n    this.evTarget = TOUCH_TARGET_EVENTS;\n    this.targetIds = {};\n\n    Input.apply(this, arguments);\n}\n\ninherit(TouchInput, Input, {\n    handler: function MTEhandler(ev) {\n        var type = TOUCH_INPUT_MAP[ev.type];\n        var touches = getTouches.call(this, ev, type);\n        if (!touches) {\n            return;\n        }\n\n        this.callback(this.manager, type, {\n            pointers: touches[0],\n            changedPointers: touches[1],\n            pointerType: INPUT_TYPE_TOUCH,\n            srcEvent: ev\n        });\n    }\n});\n\n/**\n * @this {TouchInput}\n * @param {Object} ev\n * @param {Number} type flag\n * @returns {undefined|Array} [all, changed]\n */\nfunction getTouches(ev, type) {\n    var allTouches = toArray(ev.touches);\n    var targetIds = this.targetIds;\n\n    // when there is only one touch, the process can be simplified\n    if (type & (INPUT_START | INPUT_MOVE) && allTouches.length === 1) {\n        targetIds[allTouches[0].identifier] = true;\n        return [allTouches, allTouches];\n    }\n\n    var i,\n        targetTouches,\n        changedTouches = toArray(ev.changedTouches),\n        changedTargetTouches = [],\n        target = this.target;\n\n    // get target touches from touches\n    targetTouches = allTouches.filter(function(touch) {\n        return hasParent(touch.target, target);\n    });\n\n    // collect touches\n    if (type === INPUT_START) {\n        i = 0;\n        while (i < targetTouches.length) {\n            targetIds[targetTouches[i].identifier] = true;\n            i++;\n        }\n    }\n\n    // filter changed touches to only contain touches that exist in the collected target ids\n    i = 0;\n    while (i < changedTouches.length) {\n        if (targetIds[changedTouches[i].identifier]) {\n            changedTargetTouches.push(changedTouches[i]);\n        }\n\n        // cleanup removed touches\n        if (type & (INPUT_END | INPUT_CANCEL)) {\n            delete targetIds[changedTouches[i].identifier];\n        }\n        i++;\n    }\n\n    if (!changedTargetTouches.length) {\n        return;\n    }\n\n    return [\n        // merge targetTouches with changedTargetTouches so it contains ALL touches, including 'end' and 'cancel'\n        uniqueArray(targetTouches.concat(changedTargetTouches), 'identifier', true),\n        changedTargetTouches\n    ];\n}\n\n/**\n * Combined touch and mouse input\n *\n * Touch has a higher priority then mouse, and while touching no mouse events are allowed.\n * This because touch devices also emit mouse events while doing a touch.\n *\n * @constructor\n * @extends Input\n */\n\nvar DEDUP_TIMEOUT = 2500;\nvar DEDUP_DISTANCE = 25;\n\nfunction TouchMouseInput() {\n    Input.apply(this, arguments);\n\n    var handler = bindFn(this.handler, this);\n    this.touch = new TouchInput(this.manager, handler);\n    this.mouse = new MouseInput(this.manager, handler);\n\n    this.primaryTouch = null;\n    this.lastTouches = [];\n}\n\ninherit(TouchMouseInput, Input, {\n    /**\n     * handle mouse and touch events\n     * @param {Hammer} manager\n     * @param {String} inputEvent\n     * @param {Object} inputData\n     */\n    handler: function TMEhandler(manager, inputEvent, inputData) {\n        var isTouch = (inputData.pointerType == INPUT_TYPE_TOUCH),\n            isMouse = (inputData.pointerType == INPUT_TYPE_MOUSE);\n\n        if (isMouse && inputData.sourceCapabilities && inputData.sourceCapabilities.firesTouchEvents) {\n            return;\n        }\n\n        // when we're in a touch event, record touches to  de-dupe synthetic mouse event\n        if (isTouch) {\n            recordTouches.call(this, inputEvent, inputData);\n        } else if (isMouse && isSyntheticEvent.call(this, inputData)) {\n            return;\n        }\n\n        this.callback(manager, inputEvent, inputData);\n    },\n\n    /**\n     * remove the event listeners\n     */\n    destroy: function destroy() {\n        this.touch.destroy();\n        this.mouse.destroy();\n    }\n});\n\nfunction recordTouches(eventType, eventData) {\n    if (eventType & INPUT_START) {\n        this.primaryTouch = eventData.changedPointers[0].identifier;\n        setLastTouch.call(this, eventData);\n    } else if (eventType & (INPUT_END | INPUT_CANCEL)) {\n        setLastTouch.call(this, eventData);\n    }\n}\n\nfunction setLastTouch(eventData) {\n    var touch = eventData.changedPointers[0];\n\n    if (touch.identifier === this.primaryTouch) {\n        var lastTouch = {x: touch.clientX, y: touch.clientY};\n        this.lastTouches.push(lastTouch);\n        var lts = this.lastTouches;\n        var removeLastTouch = function() {\n            var i = lts.indexOf(lastTouch);\n            if (i > -1) {\n                lts.splice(i, 1);\n            }\n        };\n        setTimeout(removeLastTouch, DEDUP_TIMEOUT);\n    }\n}\n\nfunction isSyntheticEvent(eventData) {\n    var x = eventData.srcEvent.clientX, y = eventData.srcEvent.clientY;\n    for (var i = 0; i < this.lastTouches.length; i++) {\n        var t = this.lastTouches[i];\n        var dx = Math.abs(x - t.x), dy = Math.abs(y - t.y);\n        if (dx <= DEDUP_DISTANCE && dy <= DEDUP_DISTANCE) {\n            return true;\n        }\n    }\n    return false;\n}\n\nvar PREFIXED_TOUCH_ACTION = prefixed(TEST_ELEMENT.style, 'touchAction');\nvar NATIVE_TOUCH_ACTION = PREFIXED_TOUCH_ACTION !== undefined;\n\n// magical touchAction value\nvar TOUCH_ACTION_COMPUTE = 'compute';\nvar TOUCH_ACTION_AUTO = 'auto';\nvar TOUCH_ACTION_MANIPULATION = 'manipulation'; // not implemented\nvar TOUCH_ACTION_NONE = 'none';\nvar TOUCH_ACTION_PAN_X = 'pan-x';\nvar TOUCH_ACTION_PAN_Y = 'pan-y';\nvar TOUCH_ACTION_MAP = getTouchActionProps();\n\n/**\n * Touch Action\n * sets the touchAction property or uses the js alternative\n * @param {Manager} manager\n * @param {String} value\n * @constructor\n */\nfunction TouchAction(manager, value) {\n    this.manager = manager;\n    this.set(value);\n}\n\nTouchAction.prototype = {\n    /**\n     * set the touchAction value on the element or enable the polyfill\n     * @param {String} value\n     */\n    set: function(value) {\n        // find out the touch-action by the event handlers\n        if (value == TOUCH_ACTION_COMPUTE) {\n            value = this.compute();\n        }\n\n        if (NATIVE_TOUCH_ACTION && this.manager.element.style && TOUCH_ACTION_MAP[value]) {\n            this.manager.element.style[PREFIXED_TOUCH_ACTION] = value;\n        }\n        this.actions = value.toLowerCase().trim();\n    },\n\n    /**\n     * just re-set the touchAction value\n     */\n    update: function() {\n        this.set(this.manager.options.touchAction);\n    },\n\n    /**\n     * compute the value for the touchAction property based on the recognizer's settings\n     * @returns {String} value\n     */\n    compute: function() {\n        var actions = [];\n        each(this.manager.recognizers, function(recognizer) {\n            if (boolOrFn(recognizer.options.enable, [recognizer])) {\n                actions = actions.concat(recognizer.getTouchAction());\n            }\n        });\n        return cleanTouchActions(actions.join(' '));\n    },\n\n    /**\n     * this method is called on each input cycle and provides the preventing of the browser behavior\n     * @param {Object} input\n     */\n    preventDefaults: function(input) {\n        var srcEvent = input.srcEvent;\n        var direction = input.offsetDirection;\n\n        // if the touch action did prevented once this session\n        if (this.manager.session.prevented) {\n            srcEvent.preventDefault();\n            return;\n        }\n\n        var actions = this.actions;\n        var hasNone = inStr(actions, TOUCH_ACTION_NONE) && !TOUCH_ACTION_MAP[TOUCH_ACTION_NONE];\n        var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_Y];\n        var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_X];\n\n        if (hasNone) {\n            //do not prevent defaults if this is a tap gesture\n\n            var isTapPointer = input.pointers.length === 1;\n            var isTapMovement = input.distance < 2;\n            var isTapTouchTime = input.deltaTime < 250;\n\n            if (isTapPointer && isTapMovement && isTapTouchTime) {\n                return;\n            }\n        }\n\n        if (hasPanX && hasPanY) {\n            // `pan-x pan-y` means browser handles all scrolling/panning, do not prevent\n            return;\n        }\n\n        if (hasNone ||\n            (hasPanY && direction & DIRECTION_HORIZONTAL) ||\n            (hasPanX && direction & DIRECTION_VERTICAL)) {\n            return this.preventSrc(srcEvent);\n        }\n    },\n\n    /**\n     * call preventDefault to prevent the browser's default behavior (scrolling in most cases)\n     * @param {Object} srcEvent\n     */\n    preventSrc: function(srcEvent) {\n        this.manager.session.prevented = true;\n        srcEvent.preventDefault();\n    }\n};\n\n/**\n * when the touchActions are collected they are not a valid value, so we need to clean things up. *\n * @param {String} actions\n * @returns {*}\n */\nfunction cleanTouchActions(actions) {\n    // none\n    if (inStr(actions, TOUCH_ACTION_NONE)) {\n        return TOUCH_ACTION_NONE;\n    }\n\n    var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X);\n    var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y);\n\n    // if both pan-x and pan-y are set (different recognizers\n    // for different directions, e.g. horizontal pan but vertical swipe?)\n    // we need none (as otherwise with pan-x pan-y combined none of these\n    // recognizers will work, since the browser would handle all panning\n    if (hasPanX && hasPanY) {\n        return TOUCH_ACTION_NONE;\n    }\n\n    // pan-x OR pan-y\n    if (hasPanX || hasPanY) {\n        return hasPanX ? TOUCH_ACTION_PAN_X : TOUCH_ACTION_PAN_Y;\n    }\n\n    // manipulation\n    if (inStr(actions, TOUCH_ACTION_MANIPULATION)) {\n        return TOUCH_ACTION_MANIPULATION;\n    }\n\n    return TOUCH_ACTION_AUTO;\n}\n\nfunction getTouchActionProps() {\n    if (!NATIVE_TOUCH_ACTION) {\n        return false;\n    }\n    var touchMap = {};\n    var cssSupports = window.CSS && window.CSS.supports;\n    ['auto', 'manipulation', 'pan-y', 'pan-x', 'pan-x pan-y', 'none'].forEach(function(val) {\n\n        // If css.supports is not supported but there is native touch-action assume it supports\n        // all values. This is the case for IE 10 and 11.\n        touchMap[val] = cssSupports ? window.CSS.supports('touch-action', val) : true;\n    });\n    return touchMap;\n}\n\n/**\n * Recognizer flow explained; *\n * All recognizers have the initial state of POSSIBLE when a input session starts.\n * The definition of a input session is from the first input until the last input, with all it's movement in it. *\n * Example session for mouse-input: mousedown -> mousemove -> mouseup\n *\n * On each recognizing cycle (see Manager.recognize) the .recognize() method is executed\n * which determines with state it should be.\n *\n * If the recognizer has the state FAILED, CANCELLED or RECOGNIZED (equals ENDED), it is reset to\n * POSSIBLE to give it another change on the next cycle.\n *\n *               Possible\n *                  |\n *            +-----+---------------+\n *            |                     |\n *      +-----+-----+               |\n *      |           |               |\n *   Failed      Cancelled          |\n *                          +-------+------+\n *                          |              |\n *                      Recognized       Began\n *                                         |\n *                                      Changed\n *                                         |\n *                                  Ended/Recognized\n */\nvar STATE_POSSIBLE = 1;\nvar STATE_BEGAN = 2;\nvar STATE_CHANGED = 4;\nvar STATE_ENDED = 8;\nvar STATE_RECOGNIZED = STATE_ENDED;\nvar STATE_CANCELLED = 16;\nvar STATE_FAILED = 32;\n\n/**\n * Recognizer\n * Every recognizer needs to extend from this class.\n * @constructor\n * @param {Object} options\n */\nfunction Recognizer(options) {\n    this.options = assign({}, this.defaults, options || {});\n\n    this.id = uniqueId();\n\n    this.manager = null;\n\n    // default is enable true\n    this.options.enable = ifUndefined(this.options.enable, true);\n\n    this.state = STATE_POSSIBLE;\n\n    this.simultaneous = {};\n    this.requireFail = [];\n}\n\nRecognizer.prototype = {\n    /**\n     * @virtual\n     * @type {Object}\n     */\n    defaults: {},\n\n    /**\n     * set options\n     * @param {Object} options\n     * @return {Recognizer}\n     */\n    set: function(options) {\n        assign(this.options, options);\n\n        // also update the touchAction, in case something changed about the directions/enabled state\n        this.manager && this.manager.touchAction.update();\n        return this;\n    },\n\n    /**\n     * recognize simultaneous with an other recognizer.\n     * @param {Recognizer} otherRecognizer\n     * @returns {Recognizer} this\n     */\n    recognizeWith: function(otherRecognizer) {\n        if (invokeArrayArg(otherRecognizer, 'recognizeWith', this)) {\n            return this;\n        }\n\n        var simultaneous = this.simultaneous;\n        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\n        if (!simultaneous[otherRecognizer.id]) {\n            simultaneous[otherRecognizer.id] = otherRecognizer;\n            otherRecognizer.recognizeWith(this);\n        }\n        return this;\n    },\n\n    /**\n     * drop the simultaneous link. it doesnt remove the link on the other recognizer.\n     * @param {Recognizer} otherRecognizer\n     * @returns {Recognizer} this\n     */\n    dropRecognizeWith: function(otherRecognizer) {\n        if (invokeArrayArg(otherRecognizer, 'dropRecognizeWith', this)) {\n            return this;\n        }\n\n        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\n        delete this.simultaneous[otherRecognizer.id];\n        return this;\n    },\n\n    /**\n     * recognizer can only run when an other is failing\n     * @param {Recognizer} otherRecognizer\n     * @returns {Recognizer} this\n     */\n    requireFailure: function(otherRecognizer) {\n        if (invokeArrayArg(otherRecognizer, 'requireFailure', this)) {\n            return this;\n        }\n\n        var requireFail = this.requireFail;\n        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\n        if (inArray(requireFail, otherRecognizer) === -1) {\n            requireFail.push(otherRecognizer);\n            otherRecognizer.requireFailure(this);\n        }\n        return this;\n    },\n\n    /**\n     * drop the requireFailure link. it does not remove the link on the other recognizer.\n     * @param {Recognizer} otherRecognizer\n     * @returns {Recognizer} this\n     */\n    dropRequireFailure: function(otherRecognizer) {\n        if (invokeArrayArg(otherRecognizer, 'dropRequireFailure', this)) {\n            return this;\n        }\n\n        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\n        var index = inArray(this.requireFail, otherRecognizer);\n        if (index > -1) {\n            this.requireFail.splice(index, 1);\n        }\n        return this;\n    },\n\n    /**\n     * has require failures boolean\n     * @returns {boolean}\n     */\n    hasRequireFailures: function() {\n        return this.requireFail.length > 0;\n    },\n\n    /**\n     * if the recognizer can recognize simultaneous with an other recognizer\n     * @param {Recognizer} otherRecognizer\n     * @returns {Boolean}\n     */\n    canRecognizeWith: function(otherRecognizer) {\n        return !!this.simultaneous[otherRecognizer.id];\n    },\n\n    /**\n     * You should use `tryEmit` instead of `emit` directly to check\n     * that all the needed recognizers has failed before emitting.\n     * @param {Object} input\n     */\n    emit: function(input) {\n        var self = this;\n        var state = this.state;\n\n        function emit(event) {\n            self.manager.emit(event, input);\n        }\n\n        // 'panstart' and 'panmove'\n        if (state < STATE_ENDED) {\n            emit(self.options.event + stateStr(state));\n        }\n\n        emit(self.options.event); // simple 'eventName' events\n\n        if (input.additionalEvent) { // additional event(panleft, panright, pinchin, pinchout...)\n            emit(input.additionalEvent);\n        }\n\n        // panend and pancancel\n        if (state >= STATE_ENDED) {\n            emit(self.options.event + stateStr(state));\n        }\n    },\n\n    /**\n     * Check that all the require failure recognizers has failed,\n     * if true, it emits a gesture event,\n     * otherwise, setup the state to FAILED.\n     * @param {Object} input\n     */\n    tryEmit: function(input) {\n        if (this.canEmit()) {\n            return this.emit(input);\n        }\n        // it's failing anyway\n        this.state = STATE_FAILED;\n    },\n\n    /**\n     * can we emit?\n     * @returns {boolean}\n     */\n    canEmit: function() {\n        var i = 0;\n        while (i < this.requireFail.length) {\n            if (!(this.requireFail[i].state & (STATE_FAILED | STATE_POSSIBLE))) {\n                return false;\n            }\n            i++;\n        }\n        return true;\n    },\n\n    /**\n     * update the recognizer\n     * @param {Object} inputData\n     */\n    recognize: function(inputData) {\n        // make a new copy of the inputData\n        // so we can change the inputData without messing up the other recognizers\n        var inputDataClone = assign({}, inputData);\n\n        // is is enabled and allow recognizing?\n        if (!boolOrFn(this.options.enable, [this, inputDataClone])) {\n            this.reset();\n            this.state = STATE_FAILED;\n            return;\n        }\n\n        // reset when we've reached the end\n        if (this.state & (STATE_RECOGNIZED | STATE_CANCELLED | STATE_FAILED)) {\n            this.state = STATE_POSSIBLE;\n        }\n\n        this.state = this.process(inputDataClone);\n\n        // the recognizer has recognized a gesture\n        // so trigger an event\n        if (this.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED | STATE_CANCELLED)) {\n            this.tryEmit(inputDataClone);\n        }\n    },\n\n    /**\n     * return the state of the recognizer\n     * the actual recognizing happens in this method\n     * @virtual\n     * @param {Object} inputData\n     * @returns {Const} STATE\n     */\n    process: function(inputData) { }, // jshint ignore:line\n\n    /**\n     * return the preferred touch-action\n     * @virtual\n     * @returns {Array}\n     */\n    getTouchAction: function() { },\n\n    /**\n     * called when the gesture isn't allowed to recognize\n     * like when another is being recognized or it is disabled\n     * @virtual\n     */\n    reset: function() { }\n};\n\n/**\n * get a usable string, used as event postfix\n * @param {Const} state\n * @returns {String} state\n */\nfunction stateStr(state) {\n    if (state & STATE_CANCELLED) {\n        return 'cancel';\n    } else if (state & STATE_ENDED) {\n        return 'end';\n    } else if (state & STATE_CHANGED) {\n        return 'move';\n    } else if (state & STATE_BEGAN) {\n        return 'start';\n    }\n    return '';\n}\n\n/**\n * direction cons to string\n * @param {Const} direction\n * @returns {String}\n */\nfunction directionStr(direction) {\n    if (direction == DIRECTION_DOWN) {\n        return 'down';\n    } else if (direction == DIRECTION_UP) {\n        return 'up';\n    } else if (direction == DIRECTION_LEFT) {\n        return 'left';\n    } else if (direction == DIRECTION_RIGHT) {\n        return 'right';\n    }\n    return '';\n}\n\n/**\n * get a recognizer by name if it is bound to a manager\n * @param {Recognizer|String} otherRecognizer\n * @param {Recognizer} recognizer\n * @returns {Recognizer}\n */\nfunction getRecognizerByNameIfManager(otherRecognizer, recognizer) {\n    var manager = recognizer.manager;\n    if (manager) {\n        return manager.get(otherRecognizer);\n    }\n    return otherRecognizer;\n}\n\n/**\n * This recognizer is just used as a base for the simple attribute recognizers.\n * @constructor\n * @extends Recognizer\n */\nfunction AttrRecognizer() {\n    Recognizer.apply(this, arguments);\n}\n\ninherit(AttrRecognizer, Recognizer, {\n    /**\n     * @namespace\n     * @memberof AttrRecognizer\n     */\n    defaults: {\n        /**\n         * @type {Number}\n         * @default 1\n         */\n        pointers: 1\n    },\n\n    /**\n     * Used to check if it the recognizer receives valid input, like input.distance > 10.\n     * @memberof AttrRecognizer\n     * @param {Object} input\n     * @returns {Boolean} recognized\n     */\n    attrTest: function(input) {\n        var optionPointers = this.options.pointers;\n        return optionPointers === 0 || input.pointers.length === optionPointers;\n    },\n\n    /**\n     * Process the input and return the state for the recognizer\n     * @memberof AttrRecognizer\n     * @param {Object} input\n     * @returns {*} State\n     */\n    process: function(input) {\n        var state = this.state;\n        var eventType = input.eventType;\n\n        var isRecognized = state & (STATE_BEGAN | STATE_CHANGED);\n        var isValid = this.attrTest(input);\n\n        // on cancel input and we've recognized before, return STATE_CANCELLED\n        if (isRecognized && (eventType & INPUT_CANCEL || !isValid)) {\n            return state | STATE_CANCELLED;\n        } else if (isRecognized || isValid) {\n            if (eventType & INPUT_END) {\n                return state | STATE_ENDED;\n            } else if (!(state & STATE_BEGAN)) {\n                return STATE_BEGAN;\n            }\n            return state | STATE_CHANGED;\n        }\n        return STATE_FAILED;\n    }\n});\n\n/**\n * Pan\n * Recognized when the pointer is down and moved in the allowed direction.\n * @constructor\n * @extends AttrRecognizer\n */\nfunction PanRecognizer() {\n    AttrRecognizer.apply(this, arguments);\n\n    this.pX = null;\n    this.pY = null;\n}\n\ninherit(PanRecognizer, AttrRecognizer, {\n    /**\n     * @namespace\n     * @memberof PanRecognizer\n     */\n    defaults: {\n        event: 'pan',\n        threshold: 10,\n        pointers: 1,\n        direction: DIRECTION_ALL\n    },\n\n    getTouchAction: function() {\n        var direction = this.options.direction;\n        var actions = [];\n        if (direction & DIRECTION_HORIZONTAL) {\n            actions.push(TOUCH_ACTION_PAN_Y);\n        }\n        if (direction & DIRECTION_VERTICAL) {\n            actions.push(TOUCH_ACTION_PAN_X);\n        }\n        return actions;\n    },\n\n    directionTest: function(input) {\n        var options = this.options;\n        var hasMoved = true;\n        var distance = input.distance;\n        var direction = input.direction;\n        var x = input.deltaX;\n        var y = input.deltaY;\n\n        // lock to axis?\n        if (!(direction & options.direction)) {\n            if (options.direction & DIRECTION_HORIZONTAL) {\n                direction = (x === 0) ? DIRECTION_NONE : (x < 0) ? DIRECTION_LEFT : DIRECTION_RIGHT;\n                hasMoved = x != this.pX;\n                distance = Math.abs(input.deltaX);\n            } else {\n                direction = (y === 0) ? DIRECTION_NONE : (y < 0) ? DIRECTION_UP : DIRECTION_DOWN;\n                hasMoved = y != this.pY;\n                distance = Math.abs(input.deltaY);\n            }\n        }\n        input.direction = direction;\n        return hasMoved && distance > options.threshold && direction & options.direction;\n    },\n\n    attrTest: function(input) {\n        return AttrRecognizer.prototype.attrTest.call(this, input) &&\n            (this.state & STATE_BEGAN || (!(this.state & STATE_BEGAN) && this.directionTest(input)));\n    },\n\n    emit: function(input) {\n\n        this.pX = input.deltaX;\n        this.pY = input.deltaY;\n\n        var direction = directionStr(input.direction);\n\n        if (direction) {\n            input.additionalEvent = this.options.event + direction;\n        }\n        this._super.emit.call(this, input);\n    }\n});\n\n/**\n * Pinch\n * Recognized when two or more pointers are moving toward (zoom-in) or away from each other (zoom-out).\n * @constructor\n * @extends AttrRecognizer\n */\nfunction PinchRecognizer() {\n    AttrRecognizer.apply(this, arguments);\n}\n\ninherit(PinchRecognizer, AttrRecognizer, {\n    /**\n     * @namespace\n     * @memberof PinchRecognizer\n     */\n    defaults: {\n        event: 'pinch',\n        threshold: 0,\n        pointers: 2\n    },\n\n    getTouchAction: function() {\n        return [TOUCH_ACTION_NONE];\n    },\n\n    attrTest: function(input) {\n        return this._super.attrTest.call(this, input) &&\n            (Math.abs(input.scale - 1) > this.options.threshold || this.state & STATE_BEGAN);\n    },\n\n    emit: function(input) {\n        if (input.scale !== 1) {\n            var inOut = input.scale < 1 ? 'in' : 'out';\n            input.additionalEvent = this.options.event + inOut;\n        }\n        this._super.emit.call(this, input);\n    }\n});\n\n/**\n * Press\n * Recognized when the pointer is down for x ms without any movement.\n * @constructor\n * @extends Recognizer\n */\nfunction PressRecognizer() {\n    Recognizer.apply(this, arguments);\n\n    this._timer = null;\n    this._input = null;\n}\n\ninherit(PressRecognizer, Recognizer, {\n    /**\n     * @namespace\n     * @memberof PressRecognizer\n     */\n    defaults: {\n        event: 'press',\n        pointers: 1,\n        time: 251, // minimal time of the pointer to be pressed\n        threshold: 9 // a minimal movement is ok, but keep it low\n    },\n\n    getTouchAction: function() {\n        return [TOUCH_ACTION_AUTO];\n    },\n\n    process: function(input) {\n        var options = this.options;\n        var validPointers = input.pointers.length === options.pointers;\n        var validMovement = input.distance < options.threshold;\n        var validTime = input.deltaTime > options.time;\n\n        this._input = input;\n\n        // we only allow little movement\n        // and we've reached an end event, so a tap is possible\n        if (!validMovement || !validPointers || (input.eventType & (INPUT_END | INPUT_CANCEL) && !validTime)) {\n            this.reset();\n        } else if (input.eventType & INPUT_START) {\n            this.reset();\n            this._timer = setTimeoutContext(function() {\n                this.state = STATE_RECOGNIZED;\n                this.tryEmit();\n            }, options.time, this);\n        } else if (input.eventType & INPUT_END) {\n            return STATE_RECOGNIZED;\n        }\n        return STATE_FAILED;\n    },\n\n    reset: function() {\n        clearTimeout(this._timer);\n    },\n\n    emit: function(input) {\n        if (this.state !== STATE_RECOGNIZED) {\n            return;\n        }\n\n        if (input && (input.eventType & INPUT_END)) {\n            this.manager.emit(this.options.event + 'up', input);\n        } else {\n            this._input.timeStamp = now();\n            this.manager.emit(this.options.event, this._input);\n        }\n    }\n});\n\n/**\n * Rotate\n * Recognized when two or more pointer are moving in a circular motion.\n * @constructor\n * @extends AttrRecognizer\n */\nfunction RotateRecognizer() {\n    AttrRecognizer.apply(this, arguments);\n}\n\ninherit(RotateRecognizer, AttrRecognizer, {\n    /**\n     * @namespace\n     * @memberof RotateRecognizer\n     */\n    defaults: {\n        event: 'rotate',\n        threshold: 0,\n        pointers: 2\n    },\n\n    getTouchAction: function() {\n        return [TOUCH_ACTION_NONE];\n    },\n\n    attrTest: function(input) {\n        return this._super.attrTest.call(this, input) &&\n            (Math.abs(input.rotation) > this.options.threshold || this.state & STATE_BEGAN);\n    }\n});\n\n/**\n * Swipe\n * Recognized when the pointer is moving fast (velocity), with enough distance in the allowed direction.\n * @constructor\n * @extends AttrRecognizer\n */\nfunction SwipeRecognizer() {\n    AttrRecognizer.apply(this, arguments);\n}\n\ninherit(SwipeRecognizer, AttrRecognizer, {\n    /**\n     * @namespace\n     * @memberof SwipeRecognizer\n     */\n    defaults: {\n        event: 'swipe',\n        threshold: 10,\n        velocity: 0.3,\n        direction: DIRECTION_HORIZONTAL | DIRECTION_VERTICAL,\n        pointers: 1\n    },\n\n    getTouchAction: function() {\n        return PanRecognizer.prototype.getTouchAction.call(this);\n    },\n\n    attrTest: function(input) {\n        var direction = this.options.direction;\n        var velocity;\n\n        if (direction & (DIRECTION_HORIZONTAL | DIRECTION_VERTICAL)) {\n            velocity = input.overallVelocity;\n        } else if (direction & DIRECTION_HORIZONTAL) {\n            velocity = input.overallVelocityX;\n        } else if (direction & DIRECTION_VERTICAL) {\n            velocity = input.overallVelocityY;\n        }\n\n        return this._super.attrTest.call(this, input) &&\n            direction & input.offsetDirection &&\n            input.distance > this.options.threshold &&\n            input.maxPointers == this.options.pointers &&\n            abs(velocity) > this.options.velocity && input.eventType & INPUT_END;\n    },\n\n    emit: function(input) {\n        var direction = directionStr(input.offsetDirection);\n        if (direction) {\n            this.manager.emit(this.options.event + direction, input);\n        }\n\n        this.manager.emit(this.options.event, input);\n    }\n});\n\n/**\n * A tap is ecognized when the pointer is doing a small tap/click. Multiple taps are recognized if they occur\n * between the given interval and position. The delay option can be used to recognize multi-taps without firing\n * a single tap.\n *\n * The eventData from the emitted event contains the property `tapCount`, which contains the amount of\n * multi-taps being recognized.\n * @constructor\n * @extends Recognizer\n */\nfunction TapRecognizer() {\n    Recognizer.apply(this, arguments);\n\n    // previous time and center,\n    // used for tap counting\n    this.pTime = false;\n    this.pCenter = false;\n\n    this._timer = null;\n    this._input = null;\n    this.count = 0;\n}\n\ninherit(TapRecognizer, Recognizer, {\n    /**\n     * @namespace\n     * @memberof PinchRecognizer\n     */\n    defaults: {\n        event: 'tap',\n        pointers: 1,\n        taps: 1,\n        interval: 300, // max time between the multi-tap taps\n        time: 250, // max time of the pointer to be down (like finger on the screen)\n        threshold: 9, // a minimal movement is ok, but keep it low\n        posThreshold: 10 // a multi-tap can be a bit off the initial position\n    },\n\n    getTouchAction: function() {\n        return [TOUCH_ACTION_MANIPULATION];\n    },\n\n    process: function(input) {\n        var options = this.options;\n\n        var validPointers = input.pointers.length === options.pointers;\n        var validMovement = input.distance < options.threshold;\n        var validTouchTime = input.deltaTime < options.time;\n\n        this.reset();\n\n        if ((input.eventType & INPUT_START) && (this.count === 0)) {\n            return this.failTimeout();\n        }\n\n        // we only allow little movement\n        // and we've reached an end event, so a tap is possible\n        if (validMovement && validTouchTime && validPointers) {\n            if (input.eventType != INPUT_END) {\n                return this.failTimeout();\n            }\n\n            var validInterval = this.pTime ? (input.timeStamp - this.pTime < options.interval) : true;\n            var validMultiTap = !this.pCenter || getDistance(this.pCenter, input.center) < options.posThreshold;\n\n            this.pTime = input.timeStamp;\n            this.pCenter = input.center;\n\n            if (!validMultiTap || !validInterval) {\n                this.count = 1;\n            } else {\n                this.count += 1;\n            }\n\n            this._input = input;\n\n            // if tap count matches we have recognized it,\n            // else it has began recognizing...\n            var tapCount = this.count % options.taps;\n            if (tapCount === 0) {\n                // no failing requirements, immediately trigger the tap event\n                // or wait as long as the multitap interval to trigger\n                if (!this.hasRequireFailures()) {\n                    return STATE_RECOGNIZED;\n                } else {\n                    this._timer = setTimeoutContext(function() {\n                        this.state = STATE_RECOGNIZED;\n                        this.tryEmit();\n                    }, options.interval, this);\n                    return STATE_BEGAN;\n                }\n            }\n        }\n        return STATE_FAILED;\n    },\n\n    failTimeout: function() {\n        this._timer = setTimeoutContext(function() {\n            this.state = STATE_FAILED;\n        }, this.options.interval, this);\n        return STATE_FAILED;\n    },\n\n    reset: function() {\n        clearTimeout(this._timer);\n    },\n\n    emit: function() {\n        if (this.state == STATE_RECOGNIZED) {\n            this._input.tapCount = this.count;\n            this.manager.emit(this.options.event, this._input);\n        }\n    }\n});\n\n/**\n * Simple way to create a manager with a default set of recognizers.\n * @param {HTMLElement} element\n * @param {Object} [options]\n * @constructor\n */\nfunction Hammer(element, options) {\n    options = options || {};\n    options.recognizers = ifUndefined(options.recognizers, Hammer.defaults.preset);\n    return new Manager(element, options);\n}\n\n/**\n * @const {string}\n */\nHammer.VERSION = '2.0.7';\n\n/**\n * default settings\n * @namespace\n */\nHammer.defaults = {\n    /**\n     * set if DOM events are being triggered.\n     * But this is slower and unused by simple implementations, so disabled by default.\n     * @type {Boolean}\n     * @default false\n     */\n    domEvents: false,\n\n    /**\n     * The value for the touchAction property/fallback.\n     * When set to `compute` it will magically set the correct value based on the added recognizers.\n     * @type {String}\n     * @default compute\n     */\n    touchAction: TOUCH_ACTION_COMPUTE,\n\n    /**\n     * @type {Boolean}\n     * @default true\n     */\n    enable: true,\n\n    /**\n     * EXPERIMENTAL FEATURE -- can be removed/changed\n     * Change the parent input target element.\n     * If Null, then it is being set the to main element.\n     * @type {Null|EventTarget}\n     * @default null\n     */\n    inputTarget: null,\n\n    /**\n     * force an input class\n     * @type {Null|Function}\n     * @default null\n     */\n    inputClass: null,\n\n    /**\n     * Default recognizer setup when calling `Hammer()`\n     * When creating a new Manager these will be skipped.\n     * @type {Array}\n     */\n    preset: [\n        // RecognizerClass, options, [recognizeWith, ...], [requireFailure, ...]\n        [RotateRecognizer, {enable: false}],\n        [PinchRecognizer, {enable: false}, ['rotate']],\n        [SwipeRecognizer, {direction: DIRECTION_HORIZONTAL}],\n        [PanRecognizer, {direction: DIRECTION_HORIZONTAL}, ['swipe']],\n        [TapRecognizer],\n        [TapRecognizer, {event: 'doubletap', taps: 2}, ['tap']],\n        [PressRecognizer]\n    ],\n\n    /**\n     * Some CSS properties can be used to improve the working of Hammer.\n     * Add them to this method and they will be set when creating a new Manager.\n     * @namespace\n     */\n    cssProps: {\n        /**\n         * Disables text selection to improve the dragging gesture. Mainly for desktop browsers.\n         * @type {String}\n         * @default 'none'\n         */\n        userSelect: 'none',\n\n        /**\n         * Disable the Windows Phone grippers when pressing an element.\n         * @type {String}\n         * @default 'none'\n         */\n        touchSelect: 'none',\n\n        /**\n         * Disables the default callout shown when you touch and hold a touch target.\n         * On iOS, when you touch and hold a touch target such as a link, Safari displays\n         * a callout containing information about the link. This property allows you to disable that callout.\n         * @type {String}\n         * @default 'none'\n         */\n        touchCallout: 'none',\n\n        /**\n         * Specifies whether zooming is enabled. Used by IE10>\n         * @type {String}\n         * @default 'none'\n         */\n        contentZooming: 'none',\n\n        /**\n         * Specifies that an entire element should be draggable instead of its contents. Mainly for desktop browsers.\n         * @type {String}\n         * @default 'none'\n         */\n        userDrag: 'none',\n\n        /**\n         * Overrides the highlight color shown when the user taps a link or a JavaScript\n         * clickable element in iOS. This property obeys the alpha value, if specified.\n         * @type {String}\n         * @default 'rgba(0,0,0,0)'\n         */\n        tapHighlightColor: 'rgba(0,0,0,0)'\n    }\n};\n\nvar STOP = 1;\nvar FORCED_STOP = 2;\n\n/**\n * Manager\n * @param {HTMLElement} element\n * @param {Object} [options]\n * @constructor\n */\nfunction Manager(element, options) {\n    this.options = assign({}, Hammer.defaults, options || {});\n\n    this.options.inputTarget = this.options.inputTarget || element;\n\n    this.handlers = {};\n    this.session = {};\n    this.recognizers = [];\n    this.oldCssProps = {};\n\n    this.element = element;\n    this.input = createInputInstance(this);\n    this.touchAction = new TouchAction(this, this.options.touchAction);\n\n    toggleCssProps(this, true);\n\n    each(this.options.recognizers, function(item) {\n        var recognizer = this.add(new (item[0])(item[1]));\n        item[2] && recognizer.recognizeWith(item[2]);\n        item[3] && recognizer.requireFailure(item[3]);\n    }, this);\n}\n\nManager.prototype = {\n    /**\n     * set options\n     * @param {Object} options\n     * @returns {Manager}\n     */\n    set: function(options) {\n        assign(this.options, options);\n\n        // Options that need a little more setup\n        if (options.touchAction) {\n            this.touchAction.update();\n        }\n        if (options.inputTarget) {\n            // Clean up existing event listeners and reinitialize\n            this.input.destroy();\n            this.input.target = options.inputTarget;\n            this.input.init();\n        }\n        return this;\n    },\n\n    /**\n     * stop recognizing for this session.\n     * This session will be discarded, when a new [input]start event is fired.\n     * When forced, the recognizer cycle is stopped immediately.\n     * @param {Boolean} [force]\n     */\n    stop: function(force) {\n        this.session.stopped = force ? FORCED_STOP : STOP;\n    },\n\n    /**\n     * run the recognizers!\n     * called by the inputHandler function on every movement of the pointers (touches)\n     * it walks through all the recognizers and tries to detect the gesture that is being made\n     * @param {Object} inputData\n     */\n    recognize: function(inputData) {\n        var session = this.session;\n        if (session.stopped) {\n            return;\n        }\n\n        // run the touch-action polyfill\n        this.touchAction.preventDefaults(inputData);\n\n        var recognizer;\n        var recognizers = this.recognizers;\n\n        // this holds the recognizer that is being recognized.\n        // so the recognizer's state needs to be BEGAN, CHANGED, ENDED or RECOGNIZED\n        // if no recognizer is detecting a thing, it is set to `null`\n        var curRecognizer = session.curRecognizer;\n\n        // reset when the last recognizer is recognized\n        // or when we're in a new session\n        if (!curRecognizer || (curRecognizer && curRecognizer.state & STATE_RECOGNIZED)) {\n            curRecognizer = session.curRecognizer = null;\n        }\n\n        var i = 0;\n        while (i < recognizers.length) {\n            recognizer = recognizers[i];\n\n            // find out if we are allowed try to recognize the input for this one.\n            // 1.   allow if the session is NOT forced stopped (see the .stop() method)\n            // 2.   allow if we still haven't recognized a gesture in this session, or the this recognizer is the one\n            //      that is being recognized.\n            // 3.   allow if the recognizer is allowed to run simultaneous with the current recognized recognizer.\n            //      this can be setup with the `recognizeWith()` method on the recognizer.\n            if (session.stopped !== FORCED_STOP && ( // 1\n                    !curRecognizer || recognizer == curRecognizer || // 2\n                    recognizer.canRecognizeWith(curRecognizer))) { // 3\n                recognizer.recognize(inputData);\n            } else {\n                recognizer.reset();\n            }\n\n            // if the recognizer has been recognizing the input as a valid gesture, we want to store this one as the\n            // current active recognizer. but only if we don't already have an active recognizer\n            if (!curRecognizer && recognizer.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED)) {\n                curRecognizer = session.curRecognizer = recognizer;\n            }\n            i++;\n        }\n    },\n\n    /**\n     * get a recognizer by its event name.\n     * @param {Recognizer|String} recognizer\n     * @returns {Recognizer|Null}\n     */\n    get: function(recognizer) {\n        if (recognizer instanceof Recognizer) {\n            return recognizer;\n        }\n\n        var recognizers = this.recognizers;\n        for (var i = 0; i < recognizers.length; i++) {\n            if (recognizers[i].options.event == recognizer) {\n                return recognizers[i];\n            }\n        }\n        return null;\n    },\n\n    /**\n     * add a recognizer to the manager\n     * existing recognizers with the same event name will be removed\n     * @param {Recognizer} recognizer\n     * @returns {Recognizer|Manager}\n     */\n    add: function(recognizer) {\n        if (invokeArrayArg(recognizer, 'add', this)) {\n            return this;\n        }\n\n        // remove existing\n        var existing = this.get(recognizer.options.event);\n        if (existing) {\n            this.remove(existing);\n        }\n\n        this.recognizers.push(recognizer);\n        recognizer.manager = this;\n\n        this.touchAction.update();\n        return recognizer;\n    },\n\n    /**\n     * remove a recognizer by name or instance\n     * @param {Recognizer|String} recognizer\n     * @returns {Manager}\n     */\n    remove: function(recognizer) {\n        if (invokeArrayArg(recognizer, 'remove', this)) {\n            return this;\n        }\n\n        recognizer = this.get(recognizer);\n\n        // let's make sure this recognizer exists\n        if (recognizer) {\n            var recognizers = this.recognizers;\n            var index = inArray(recognizers, recognizer);\n\n            if (index !== -1) {\n                recognizers.splice(index, 1);\n                this.touchAction.update();\n            }\n        }\n\n        return this;\n    },\n\n    /**\n     * bind event\n     * @param {String} events\n     * @param {Function} handler\n     * @returns {EventEmitter} this\n     */\n    on: function(events, handler) {\n        if (events === undefined) {\n            return;\n        }\n        if (handler === undefined) {\n            return;\n        }\n\n        var handlers = this.handlers;\n        each(splitStr(events), function(event) {\n            handlers[event] = handlers[event] || [];\n            handlers[event].push(handler);\n        });\n        return this;\n    },\n\n    /**\n     * unbind event, leave emit blank to remove all handlers\n     * @param {String} events\n     * @param {Function} [handler]\n     * @returns {EventEmitter} this\n     */\n    off: function(events, handler) {\n        if (events === undefined) {\n            return;\n        }\n\n        var handlers = this.handlers;\n        each(splitStr(events), function(event) {\n            if (!handler) {\n                delete handlers[event];\n            } else {\n                handlers[event] && handlers[event].splice(inArray(handlers[event], handler), 1);\n            }\n        });\n        return this;\n    },\n\n    /**\n     * emit event to the listeners\n     * @param {String} event\n     * @param {Object} data\n     */\n    emit: function(event, data) {\n        // we also want to trigger dom events\n        if (this.options.domEvents) {\n            triggerDomEvent(event, data);\n        }\n\n        // no handlers, so skip it all\n        var handlers = this.handlers[event] && this.handlers[event].slice();\n        if (!handlers || !handlers.length) {\n            return;\n        }\n\n        data.type = event;\n        data.preventDefault = function() {\n            data.srcEvent.preventDefault();\n        };\n\n        var i = 0;\n        while (i < handlers.length) {\n            handlers[i](data);\n            i++;\n        }\n    },\n\n    /**\n     * destroy the manager and unbinds all events\n     * it doesn't unbind dom events, that is the user own responsibility\n     */\n    destroy: function() {\n        this.element && toggleCssProps(this, false);\n\n        this.handlers = {};\n        this.session = {};\n        this.input.destroy();\n        this.element = null;\n    }\n};\n\n/**\n * add/remove the css properties as defined in manager.options.cssProps\n * @param {Manager} manager\n * @param {Boolean} add\n */\nfunction toggleCssProps(manager, add) {\n    var element = manager.element;\n    if (!element.style) {\n        return;\n    }\n    var prop;\n    each(manager.options.cssProps, function(value, name) {\n        prop = prefixed(element.style, name);\n        if (add) {\n            manager.oldCssProps[prop] = element.style[prop];\n            element.style[prop] = value;\n        } else {\n            element.style[prop] = manager.oldCssProps[prop] || '';\n        }\n    });\n    if (!add) {\n        manager.oldCssProps = {};\n    }\n}\n\n/**\n * trigger dom event\n * @param {String} event\n * @param {Object} data\n */\nfunction triggerDomEvent(event, data) {\n    var gestureEvent = document.createEvent('Event');\n    gestureEvent.initEvent(event, true, true);\n    gestureEvent.gesture = data;\n    data.target.dispatchEvent(gestureEvent);\n}\n\nassign(Hammer, {\n    INPUT_START: INPUT_START,\n    INPUT_MOVE: INPUT_MOVE,\n    INPUT_END: INPUT_END,\n    INPUT_CANCEL: INPUT_CANCEL,\n\n    STATE_POSSIBLE: STATE_POSSIBLE,\n    STATE_BEGAN: STATE_BEGAN,\n    STATE_CHANGED: STATE_CHANGED,\n    STATE_ENDED: STATE_ENDED,\n    STATE_RECOGNIZED: STATE_RECOGNIZED,\n    STATE_CANCELLED: STATE_CANCELLED,\n    STATE_FAILED: STATE_FAILED,\n\n    DIRECTION_NONE: DIRECTION_NONE,\n    DIRECTION_LEFT: DIRECTION_LEFT,\n    DIRECTION_RIGHT: DIRECTION_RIGHT,\n    DIRECTION_UP: DIRECTION_UP,\n    DIRECTION_DOWN: DIRECTION_DOWN,\n    DIRECTION_HORIZONTAL: DIRECTION_HORIZONTAL,\n    DIRECTION_VERTICAL: DIRECTION_VERTICAL,\n    DIRECTION_ALL: DIRECTION_ALL,\n\n    Manager: Manager,\n    Input: Input,\n    TouchAction: TouchAction,\n\n    TouchInput: TouchInput,\n    MouseInput: MouseInput,\n    PointerEventInput: PointerEventInput,\n    TouchMouseInput: TouchMouseInput,\n    SingleTouchInput: SingleTouchInput,\n\n    Recognizer: Recognizer,\n    AttrRecognizer: AttrRecognizer,\n    Tap: TapRecognizer,\n    Pan: PanRecognizer,\n    Swipe: SwipeRecognizer,\n    Pinch: PinchRecognizer,\n    Rotate: RotateRecognizer,\n    Press: PressRecognizer,\n\n    on: addEventListeners,\n    off: removeEventListeners,\n    each: each,\n    merge: merge,\n    extend: extend,\n    assign: assign,\n    inherit: inherit,\n    bindFn: bindFn,\n    prefixed: prefixed\n});\n\n// this prevents errors when Hammer is loaded in the presence of an AMD\n//  style loader but by script tag, not by the loader.\nvar freeGlobal = (typeof window !== 'undefined' ? window : (typeof self !== 'undefined' ? self : {})); // jshint ignore:line\nfreeGlobal.Hammer = Hammer;\n\nif (typeof define === 'function' && define.amd) {\n    define(function() {\n        return Hammer;\n    });\n} else if (typeof module != 'undefined' && module.exports) {\n    module.exports = Hammer;\n} else {\n    window[exportName] = Hammer;\n}\n\n})(window, document, 'Hammer');\n",
    "var root = require('./_root');\n\n/** Built-in value references. */\nvar Symbol = root.Symbol;\n\nmodule.exports = Symbol;\n",
    "var Symbol = require('./_Symbol'),\n    getRawTag = require('./_getRawTag'),\n    objectToString = require('./_objectToString');\n\n/** `Object#toString` result references. */\nvar nullTag = '[object Null]',\n    undefinedTag = '[object Undefined]';\n\n/** Built-in value references. */\nvar symToStringTag = Symbol ? Symbol.toStringTag : undefined;\n\n/**\n * The base implementation of `getTag` without fallbacks for buggy environments.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nfunction baseGetTag(value) {\n  if (value == null) {\n    return value === undefined ? undefinedTag : nullTag;\n  }\n  return (symToStringTag && symToStringTag in Object(value))\n    ? getRawTag(value)\n    : objectToString(value);\n}\n\nmodule.exports = baseGetTag;\n",
    "/** Detect free variable `global` from Node.js. */\nvar freeGlobal = typeof global == 'object' && global && global.Object === Object && global;\n\nmodule.exports = freeGlobal;\n",
    "var Symbol = require('./_Symbol');\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar nativeObjectToString = objectProto.toString;\n\n/** Built-in value references. */\nvar symToStringTag = Symbol ? Symbol.toStringTag : undefined;\n\n/**\n * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the raw `toStringTag`.\n */\nfunction getRawTag(value) {\n  var isOwn = hasOwnProperty.call(value, symToStringTag),\n      tag = value[symToStringTag];\n\n  try {\n    value[symToStringTag] = undefined;\n    var unmasked = true;\n  } catch (e) {}\n\n  var result = nativeObjectToString.call(value);\n  if (unmasked) {\n    if (isOwn) {\n      value[symToStringTag] = tag;\n    } else {\n      delete value[symToStringTag];\n    }\n  }\n  return result;\n}\n\nmodule.exports = getRawTag;\n",
    "/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar nativeObjectToString = objectProto.toString;\n\n/**\n * Converts `value` to a string using `Object.prototype.toString`.\n *\n * @private\n * @param {*} value The value to convert.\n * @returns {string} Returns the converted string.\n */\nfunction objectToString(value) {\n  return nativeObjectToString.call(value);\n}\n\nmodule.exports = objectToString;\n",
    "var freeGlobal = require('./_freeGlobal');\n\n/** Detect free variable `self`. */\nvar freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n/** Used as a reference to the global object. */\nvar root = freeGlobal || freeSelf || Function('return this')();\n\nmodule.exports = root;\n",
    "/**\n * Checks if `value` is classified as an `Array` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an array, else `false`.\n * @example\n *\n * _.isArray([1, 2, 3]);\n * // => true\n *\n * _.isArray(document.body.children);\n * // => false\n *\n * _.isArray('abc');\n * // => false\n *\n * _.isArray(_.noop);\n * // => false\n */\nvar isArray = Array.isArray;\n\nmodule.exports = isArray;\n",
    "/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\nfunction isObjectLike(value) {\n  return value != null && typeof value == 'object';\n}\n\nmodule.exports = isObjectLike;\n",
    "var baseGetTag = require('./_baseGetTag'),\n    isArray = require('./isArray'),\n    isObjectLike = require('./isObjectLike');\n\n/** `Object#toString` result references. */\nvar stringTag = '[object String]';\n\n/**\n * Checks if `value` is classified as a `String` primitive or object.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a string, else `false`.\n * @example\n *\n * _.isString('abc');\n * // => true\n *\n * _.isString(1);\n * // => false\n */\nfunction isString(value) {\n  return typeof value == 'string' ||\n    (!isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag);\n}\n\nmodule.exports = isString;\n",
    "/**\n * Checks if `value` is `undefined`.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is `undefined`, else `false`.\n * @example\n *\n * _.isUndefined(void 0);\n * // => true\n *\n * _.isUndefined(null);\n * // => false\n */\nfunction isUndefined(value) {\n  return value === undefined;\n}\n\nmodule.exports = isUndefined;\n",
    "!function(t,e){\"object\"==typeof exports&&\"object\"==typeof module?module.exports=e():\"function\"==typeof define&&define.amd?define([],e):\"object\"==typeof exports?exports.rollbar=e():t.rollbar=e()}(this,function(){return function(t){function e(n){if(r[n])return r[n].exports;var o=r[n]={exports:{},id:n,loaded:!1};return t[n].call(o.exports,o,o.exports,e),o.loaded=!0,o.exports}var r={};return e.m=t,e.c=r,e.p=\"\",e(0)}([function(t,e,r){t.exports=r(1)},function(t,e,r){\"use strict\";var n=r(2),o=\"undefined\"!=typeof window&&window._rollbarConfig,i=o&&o.globalAlias||\"Rollbar\",a=\"undefined\"!=typeof window&&window[i]&&\"function\"==typeof window[i].shimId&&void 0!==window[i].shimId();if(\"undefined\"==typeof window||window._rollbarStartTime||(window._rollbarStartTime=(new Date).getTime()),!a&&o){var s=new n(o);window[i]=s}else\"undefined\"!=typeof window?(window.rollbar=n,window._rollbarDidLoad=!0):\"undefined\"!=typeof self&&(self.rollbar=n,self._rollbarDidLoad=!0);t.exports=n},function(t,e,r){\"use strict\";function n(t,e){this.options=c.merge(x,t);var r=new l(this.options,h,d);this.client=e||new u(this.options,r,p,\"browser\");var n=\"undefined\"!=typeof window&&window||\"undefined\"!=typeof self&&self,o=\"undefined\"!=typeof document&&document;i(this.client.notifier),a(this.client.queue),(this.options.captureUncaught||this.options.handleUncaughtExceptions)&&(f.captureUncaughtExceptions(n,this),f.wrapGlobals(n,this)),(this.options.captureUnhandledRejections||this.options.handleUnhandledRejections)&&f.captureUnhandledRejections(n,this),this.instrumenter=new w(this.options,this.client.telemeter,this,n,o),this.instrumenter.instrument()}function o(t){var e=\"Rollbar is not initialized\";p.error(e),t&&t(new Error(e))}function i(t){t.addTransform(m.handleItemWithError).addTransform(m.ensureItemHasSomethingToSay).addTransform(m.addBaseInfo).addTransform(m.addRequestInfo(window)).addTransform(m.addClientInfo(window)).addTransform(m.addPluginInfo(window)).addTransform(m.addBody).addTransform(g.addMessageWithError).addTransform(g.addTelemetryData).addTransform(g.addConfigToPayload).addTransform(m.scrubPayload).addTransform(g.userTransform(p)).addTransform(g.itemToPayload)}function a(t){t.addPredicate(y.checkLevel).addPredicate(v.checkIgnore).addPredicate(y.userCheckIgnore(p)).addPredicate(y.urlIsNotBlacklisted(p)).addPredicate(y.urlIsWhitelisted(p)).addPredicate(y.messageIsIgnored(p))}function s(t){for(var e=0,r=t.length;e<r;++e)if(c.isFunction(t[e]))return t[e]}var u=r(3),c=r(5),l=r(11),p=r(13),f=r(16),h=r(17),d=r(19),m=r(20),g=r(24),v=r(25),y=r(26),b=r(21),w=r(27),_=null;n.init=function(t,e){return _?_.global(t).configure(t):_=new n(t,e)},n.prototype.global=function(t){return this.client.global(t),this},n.global=function(t){return _?_.global(t):void o()},n.prototype.configure=function(t,e){var r=this.options,n={};return e&&(n={payload:e}),this.options=c.merge(r,t,n),this.client.configure(this.options,e),this.instrumenter.configure(this.options),this},n.configure=function(t,e){return _?_.configure(t,e):void o()},n.prototype.lastError=function(){return this.client.lastError},n.lastError=function(){return _?_.lastError():void o()},n.prototype.log=function(){var t=this._createItem(arguments),e=t.uuid;return this.client.log(t),{uuid:e}},n.log=function(){if(_)return _.log.apply(_,arguments);var t=s(arguments);o(t)},n.prototype.debug=function(){var t=this._createItem(arguments),e=t.uuid;return this.client.debug(t),{uuid:e}},n.debug=function(){if(_)return _.debug.apply(_,arguments);var t=s(arguments);o(t)},n.prototype.info=function(){var t=this._createItem(arguments),e=t.uuid;return this.client.info(t),{uuid:e}},n.info=function(){if(_)return _.info.apply(_,arguments);var t=s(arguments);o(t)},n.prototype.warn=function(){var t=this._createItem(arguments),e=t.uuid;return this.client.warn(t),{uuid:e}},n.warn=function(){if(_)return _.warn.apply(_,arguments);var t=s(arguments);o(t)},n.prototype.warning=function(){var t=this._createItem(arguments),e=t.uuid;return this.client.warning(t),{uuid:e}},n.warning=function(){if(_)return _.warning.apply(_,arguments);var t=s(arguments);o(t)},n.prototype.error=function(){var t=this._createItem(arguments),e=t.uuid;return this.client.error(t),{uuid:e}},n.error=function(){if(_)return _.error.apply(_,arguments);var t=s(arguments);o(t)},n.prototype.critical=function(){var t=this._createItem(arguments),e=t.uuid;return this.client.critical(t),{uuid:e}},n.critical=function(){if(_)return _.critical.apply(_,arguments);var t=s(arguments);o(t)},n.prototype.handleUncaughtException=function(t,e,r,n,o,i){var a,s=c.makeUnhandledStackInfo(t,e,r,n,o,\"onerror\",\"uncaught exception\",b);c.isError(o)?(a=this._createItem([t,o,i]),a._unhandledStackInfo=s):c.isError(e)?(a=this._createItem([t,e,i]),a._unhandledStackInfo=s):(a=this._createItem([t,i]),a.stackInfo=s),a.level=this.options.uncaughtErrorLevel,a._isUncaught=!0,this.client.log(a)},n.prototype.handleUnhandledRejection=function(t,e){var r=\"unhandled rejection was null or undefined!\";if(t)if(t.message)r=t.message;else{var n=c.stringify(t);n.value&&(r=n.value)}var o,i=t&&t._rollbarContext||e&&e._rollbarContext;c.isError(t)?o=this._createItem([r,t,i]):(o=this._createItem([r,t,i]),o.stackInfo=c.makeUnhandledStackInfo(r,\"\",0,0,null,\"unhandledrejection\",\"\",b)),o.level=this.options.uncaughtErrorLevel,o._isUncaught=!0,o._originalArgs=o._originalArgs||[],o._originalArgs.push(e),this.client.log(o)},n.prototype.wrap=function(t,e,r){try{var n;if(n=c.isFunction(e)?e:function(){return e||{}},!c.isFunction(t))return t;if(t._isWrap)return t;if(!t._rollbar_wrapped&&(t._rollbar_wrapped=function(){r&&c.isFunction(r)&&r.apply(this,arguments);try{return t.apply(this,arguments)}catch(r){var e=r;throw e&&(c.isType(e,\"string\")&&(e=new String(e)),e._rollbarContext=n()||{},e._rollbarContext._wrappedSource=t.toString(),window._rollbarWrappedError=e),e}},t._rollbar_wrapped._isWrap=!0,t.hasOwnProperty))for(var o in t)t.hasOwnProperty(o)&&(t._rollbar_wrapped[o]=t[o]);return t._rollbar_wrapped}catch(e){return t}},n.wrap=function(t,e){return _?_.wrap(t,e):void o()},n.prototype.captureEvent=function(t,e){return this.client.captureEvent(t,e)},n.captureEvent=function(t,e){return _?_.captureEvent(t,e):void o()},n.prototype.captureDomContentLoaded=function(t,e){return e||(e=new Date),this.client.captureDomContentLoaded(e)},n.prototype.captureLoad=function(t,e){return e||(e=new Date),this.client.captureLoad(e)},n.prototype._createItem=function(t){return c.createItem(t,p,this)};var x={version:\"2.4.5\",scrubFields:[\"pw\",\"pass\",\"passwd\",\"password\",\"secret\",\"confirm_password\",\"confirmPassword\",\"password_confirmation\",\"passwordConfirmation\",\"access_token\",\"accessToken\",\"secret_key\",\"secretKey\",\"secretToken\",\"cc-number\",\"card number\",\"cardnumber\",\"cardnum\",\"ccnum\",\"ccnumber\",\"cc num\",\"creditcardnumber\",\"credit card number\",\"newcreditcardnumber\",\"new credit card\",\"creditcardno\",\"credit card no\",\"card#\",\"card #\",\"cc-csc\",\"cvc2\",\"cvv2\",\"ccv2\",\"security code\",\"card verification\",\"name on credit card\",\"name on card\",\"nameoncard\",\"cardholder\",\"card holder\",\"name des karteninhabers\",\"card type\",\"cardtype\",\"cc type\",\"cctype\",\"payment type\",\"expiration date\",\"expirationdate\",\"expdate\",\"cc-exp\"],logLevel:\"debug\",reportLevel:\"debug\",uncaughtErrorLevel:\"error\",endpoint:\"api.rollbar.com/api/1/item/\",verbose:!1,enabled:!0,sendConfig:!1,includeItemsInTelemetry:!0,captureIp:!0};t.exports=n},function(t,e,r){\"use strict\";function n(t,e,r,o){this.options=c.merge(t),this.logger=r,n.rateLimiter.configureGlobal(this.options),n.rateLimiter.setPlatformOptions(o,this.options),this.queue=new a(n.rateLimiter,e,r,this.options),this.notifier=new s(this.queue,this.options),this.telemeter=new u(this.options),this.lastError=null,this.lastErrorHash=\"none\"}function o(t){var e=t.message||\"\",r=(t.err||{}).stack||String(t.err);return e+\"::\"+r}var i=r(4),a=r(8),s=r(9),u=r(10),c=r(5),l={maxItems:0,itemsPerMinute:60};n.rateLimiter=new i(l),n.prototype.global=function(t){return n.rateLimiter.configureGlobal(t),this},n.prototype.configure=function(t,e){var r=this.options,n={};return e&&(n={payload:e}),this.options=c.merge(r,t,n),this.notifier&&this.notifier.configure(this.options),this.telemeter&&this.telemeter.configure(this.options),this.global(this.options),this},n.prototype.log=function(t){var e=this._defaultLogLevel();return this._log(e,t)},n.prototype.debug=function(t){this._log(\"debug\",t)},n.prototype.info=function(t){this._log(\"info\",t)},n.prototype.warn=function(t){this._log(\"warning\",t)},n.prototype.warning=function(t){this._log(\"warning\",t)},n.prototype.error=function(t){this._log(\"error\",t)},n.prototype.critical=function(t){this._log(\"critical\",t)},n.prototype.wait=function(t){this.queue.wait(t)},n.prototype.captureEvent=function(t,e){return this.telemeter.captureEvent(t,e)},n.prototype.captureDomContentLoaded=function(t){return this.telemeter.captureDomContentLoaded(t)},n.prototype.captureLoad=function(t){return this.telemeter.captureLoad(t)},n.prototype._log=function(t,e){var r;if(e.callback&&(r=e.callback,delete e.callback),this._sameAsLastError(e)){if(r){var n=new Error(\"ignored identical item\");n.item=e,r(n)}}else try{e.level=e.level||t,this.telemeter._captureRollbarItem(e),e.telemetryEvents=this.telemeter.copyEvents(),this.notifier.log(e,r)}catch(t){this.logger.error(t)}},n.prototype._defaultLogLevel=function(){return this.options.logLevel||\"debug\"},n.prototype._sameAsLastError=function(t){if(!t._isUncaught)return!1;var e=o(t);return this.lastErrorHash===e||(this.lastError=t.err,this.lastErrorHash=e,!1)},t.exports=n},function(t,e,r){\"use strict\";function n(t){this.startTime=s.now(),this.counter=0,this.perMinCounter=0,this.platform=null,this.platformOptions={},this.configureGlobal(t)}function o(t,e,r){return!t.ignoreRateLimit&&e>=1&&r>e}function i(t,e,r,n,o,i,s){var u=null;return r&&(r=new Error(r)),r||n||(u=a(t,e,o,i,s)),{error:r,shouldSend:n,payload:u}}function a(t,e,r,n,o){var i,a=e.environment||e.payload&&e.payload.environment;i=o?\"item per minute limit reached, ignoring errors until timeout\":\"maxItems has been hit, ignoring errors until reset.\";var s={body:{message:{body:i,extra:{maxItems:r,itemsPerMinute:n}}},language:\"javascript\",environment:a,notifier:{version:e.notifier&&e.notifier.version||e.version}};return\"browser\"===t?(s.platform=\"browser\",s.framework=\"browser-js\",s.notifier.name=\"rollbar-browser-js\"):\"server\"===t?(s.framework=e.framework||\"node-js\",s.notifier.name=e.notifier.name):\"react-native\"===t&&(s.framework=e.framework||\"react-native\",s.notifier.name=e.notifier.name),s}var s=r(5);n.globalSettings={startTime:s.now(),maxItems:void 0,itemsPerMinute:void 0},n.prototype.configureGlobal=function(t){void 0!==t.startTime&&(n.globalSettings.startTime=t.startTime),void 0!==t.maxItems&&(n.globalSettings.maxItems=t.maxItems),void 0!==t.itemsPerMinute&&(n.globalSettings.itemsPerMinute=t.itemsPerMinute)},n.prototype.shouldSend=function(t,e){e=e||s.now();var r=e-this.startTime;(r<0||r>=6e4)&&(this.startTime=e,this.perMinCounter=0);var a=n.globalSettings.maxItems,u=n.globalSettings.itemsPerMinute;if(o(t,a,this.counter))return i(this.platform,this.platformOptions,a+\" max items reached\",!1);if(o(t,u,this.perMinCounter))return i(this.platform,this.platformOptions,u+\" items per minute reached\",!1);this.counter++,this.perMinCounter++;var c=!o(t,a,this.counter),l=c;return c=c&&!o(t,u,this.perMinCounter),i(this.platform,this.platformOptions,null,c,a,u,l)},n.prototype.setPlatformOptions=function(t,e){this.platform=t,this.platformOptions=e},t.exports=n},function(t,e,r){\"use strict\";function n(){if(!A&&(A=!0,c(JSON)&&(s(JSON.stringify)&&(R.stringify=JSON.stringify),s(JSON.parse)&&(R.parse=JSON.parse)),!a(R.stringify)||!a(R.parse))){var t=r(7);t(R)}}function o(t,e){return e===i(t)}function i(t){var e=typeof t;return\"object\"!==e?e:t?t instanceof Error?\"error\":{}.toString.call(t).match(/\\s([a-zA-Z]+)/)[1].toLowerCase():\"null\"}function a(t){return o(t,\"function\")}function s(t){var e=/[\\\\^$.*+?()[\\]{}|]/g,r=Function.prototype.toString.call(Object.prototype.hasOwnProperty).replace(e,\"\\\\$&\").replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g,\"$1.*?\"),n=RegExp(\"^\"+r+\"$\");return u(t)&&n.test(t)}function u(t){var e=typeof t;return null!=t&&(\"object\"==e||\"function\"==e)}function c(t){return!o(t,\"undefined\")}function l(t){var e=i(t);return\"object\"===e||\"array\"===e}function p(t){return o(t,\"error\")}function f(t,e,r){var n,i,a,s=o(t,\"object\"),u=o(t,\"array\"),c=[];if(s&&r.indexOf(t)!==-1)return t;if(r.push(t),s)for(n in t)Object.prototype.hasOwnProperty.call(t,n)&&c.push(n);else if(u)for(a=0;a<t.length;++a)c.push(a);var l=s?{}:[];for(a=0;a<c.length;++a)n=c[a],i=t[n],l[n]=e(n,i,r);return 0!=c.length?l:t}function h(){return\"********\"}function d(){var t=N(),e=\"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx\".replace(/[xy]/g,function(e){var r=(t+16*Math.random())%16|0;return t=Math.floor(t/16),(\"x\"===e?r:7&r|8).toString(16)});return e}function m(t){var e=g(t);return e?(\"\"===e.anchor&&(e.source=e.source.replace(\"#\",\"\")),t=e.source.replace(\"?\"+e.query,\"\")):\"(unknown)\"}function g(t){if(o(t,\"string\")){for(var e=P,r=e.parser[e.strictMode?\"strict\":\"loose\"].exec(t),n={},i=e.key.length;i--;)n[e.key[i]]=r[i]||\"\";return n[e.q.name]={},n[e.key[12]].replace(e.q.parser,function(t,r,o){r&&(n[e.q.name][r]=o)}),n}}function v(t,e,r){r=r||{},r.access_token=t;var n,o=[];for(n in r)Object.prototype.hasOwnProperty.call(r,n)&&o.push([n,r[n]].join(\"=\"));var i=\"?\"+o.sort().join(\"&\");e=e||{},e.path=e.path||\"\";var a,s=e.path.indexOf(\"?\"),u=e.path.indexOf(\"#\");s!==-1&&(u===-1||u>s)?(a=e.path,e.path=a.substring(0,s)+i+\"&\"+a.substring(s+1)):u!==-1?(a=e.path,e.path=a.substring(0,u)+i+a.substring(u)):e.path=e.path+i}function y(t,e){if(e=e||t.protocol,!e&&t.port&&(80===t.port?e=\"http:\":443===t.port&&(e=\"https:\")),e=e||\"https:\",!t.hostname)return null;var r=e+\"//\"+t.hostname;return t.port&&(r=r+\":\"+t.port),t.path&&(r+=t.path),r}function b(t,e){var r,n;try{r=R.stringify(t)}catch(o){if(e&&a(e))try{r=e(t)}catch(t){n=t}else n=o}return{error:n,value:r}}function w(t){var e,r;try{e=R.parse(t)}catch(t){r=t}return{error:r,value:e}}function _(t,e,r,n,o,i,a,s){var u={url:e||\"\",line:r,column:n};u.func=s.guessFunctionName(u.url,u.line),u.context=s.gatherContext(u.url,u.line);var c=document&&document.location&&document.location.href,l=window&&window.navigator&&window.navigator.userAgent;return{mode:i,message:o?String(o):t||a,url:c,stack:[u],useragent:l}}function x(t,e){return function(r,n){try{e(r,n)}catch(e){t.error(e)}}}function k(t,e,r,n,o){for(var a,s,u,c,l,p,f=[],h=0,m=t.length;h<m;++h){p=t[h];var g=i(p);switch(g){case\"undefined\":break;case\"string\":a?f.push(p):a=p;break;case\"function\":c=x(e,p);break;case\"date\":f.push(p);break;case\"error\":case\"domexception\":s?f.push(p):s=p;break;case\"object\":case\"array\":if(p instanceof Error||\"undefined\"!=typeof DOMException&&p instanceof DOMException){s?f.push(p):s=p;break}if(n&&\"object\"===g&&!l){for(var v=0,y=n.length;v<y;++v)if(void 0!==p[n[v]]){l=p;break}if(l)break}u?f.push(p):u=p;break;default:if(p instanceof Error||\"undefined\"!=typeof DOMException&&p instanceof DOMException){s?f.push(p):s=p;break}f.push(p)}}f.length>0&&(u=j(u),u.extraArgs=f);var b={message:a,err:s,custom:u,timestamp:N(),callback:c,uuid:d()};return u&&void 0!==u.level&&(b.level=u.level,delete u.level),n&&l&&(b.request=l),o&&(b.lambdaContext=o),b._originalArgs=t,b}function E(t,e){if(t){var r=e.split(\".\"),n=t;try{for(var o=0,i=r.length;o<i;++o)n=n[r[o]]}catch(t){n=void 0}return n}}function I(t,e,r){if(t){var n=e.split(\".\"),o=n.length;if(!(o<1)){if(1===o)return void(t[n[0]]=r);try{for(var i=t[n[0]]||{},a=i,s=1;s<o-1;s++)i[n[s]]=i[n[s]]||{},i=i[n[s]];i[n[o-1]]=r,t[n[0]]=a}catch(t){return}}}}function S(t,e){function r(t,e,r,n,o,i){return e+h(i)}function n(t){var e;if(o(t,\"string\"))for(e=0;e<u.length;++e)t=t.replace(u[e],r);return t}function i(t,e){var r;for(r=0;r<s.length;++r)if(s[r].test(t)){e=h(e);break}return e}function a(t,e,r){var s=i(t,e);return s===e?o(e,\"object\")||o(e,\"array\")?f(e,a,r):n(s):s}e=e||[];var s=T(e),u=O(e);return f(t,a,[])}function T(t){for(var e,r=[],n=0;n<t.length;++n)e=\"^\\\\[?(%5[bB])?\"+t[n]+\"\\\\[?(%5[bB])?\\\\]?(%5[dD])?$\",r.push(new RegExp(e,\"i\"));return r}function O(t){for(var e,r=[],n=0;n<t.length;++n)e=\"\\\\[?(%5[bB])?\"+t[n]+\"\\\\[?(%5[bB])?\\\\]?(%5[dD])?\",r.push(new RegExp(\"(\"+e+\"=)([^&\\\\n]+)\",\"igm\"));return r}function L(t){var e,r,n,o=[];for(e=0,r=t.length;e<r;e++){switch(n=t[e],i(n)){case\"object\":n=b(n),n=n.error||n.value,n.length>500&&(n=n.substr(0,497)+\"...\");break;case\"null\":n=\"null\";break;case\"undefined\":n=\"undefined\";break;case\"symbol\":n=n.toString()}o.push(n)}return o.join(\" \")}function N(){return Date.now?+Date.now():+new Date}function C(t,e){if(t&&t.user_ip&&e!==!0){var r=t.user_ip;if(e)try{var n;if(r.indexOf(\".\")!==-1)n=r.split(\".\"),n.pop(),n.push(\"0\"),r=n.join(\".\");else if(r.indexOf(\":\")!==-1){if(n=r.split(\":\"),n.length>2){var o=n.slice(0,3),i=o[2].indexOf(\"/\");i!==-1&&(o[2]=o[2].substring(0,i));var a=\"0000:0000:0000:0000:0000\";r=o.concat(a).join(\":\")}}else r=null}catch(t){r=null}else r=null;t.user_ip=r}}var j=r(6),R={},A=!1;n();var q={debug:0,info:1,warning:2,error:3,critical:4},P={strictMode:!1,key:[\"source\",\"protocol\",\"authority\",\"userInfo\",\"user\",\"password\",\"host\",\"port\",\"relative\",\"path\",\"directory\",\"file\",\"query\",\"anchor\"],q:{name:\"queryKey\",parser:/(?:^|&)([^&=]*)=?([^&]*)/g},parser:{strict:/^(?:([^:\\/?#]+):)?(?:\\/\\/((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\\/?#]*)(?::(\\d*))?))?((((?:[^?#\\/]*\\/)*)([^?#]*))(?:\\?([^#]*))?(?:#(.*))?)/,loose:/^(?:(?![^:@]+:[^:@\\/]*@)([^:\\/?#.]+):)?(?:\\/\\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\\/?#]*)(?::(\\d*))?)(((\\/(?:[^?#](?![^?#\\/]*\\.[^?#\\/.]+(?:[?#]|$)))*\\/?)?([^?#\\/]*))(?:\\?([^#]*))?(?:#(.*))?)/}};t.exports={isType:o,typeName:i,isFunction:a,isNativeFunction:s,isIterable:l,isError:p,merge:j,traverse:f,redact:h,uuid4:d,LEVELS:q,sanitizeUrl:m,addParamsAndAccessTokenToPath:v,formatUrl:y,stringify:b,jsonParse:w,makeUnhandledStackInfo:_,createItem:k,get:E,set:I,scrub:S,formatArgsAsString:L,now:N,filterIp:C}},function(t,e){\"use strict\";function r(){var t,e,n,o,a,s={},u=null,c=arguments.length;for(t=0;t<c;t++)if(u=arguments[t],null!=u)for(a in u)e=s[a],n=u[a],s!==n&&(n&&i(n)?(o=e&&i(e)?e:{},s[a]=r(o,n)):\"undefined\"!=typeof n&&(s[a]=n));return s}var n=Object.prototype.hasOwnProperty,o=Object.prototype.toString,i=function(t){if(!t||\"[object Object]\"!==o.call(t))return!1;var e=n.call(t,\"constructor\"),r=t.constructor&&t.constructor.prototype&&n.call(t.constructor.prototype,\"isPrototypeOf\");if(t.constructor&&!e&&!r)return!1;var i;for(i in t);return\"undefined\"==typeof i||n.call(t,i)};t.exports=r},function(t,e){var r=function(t){function e(t){return t<10?\"0\"+t:t}function r(){return this.valueOf()}function n(t){return i.lastIndex=0,i.test(t)?'\"'+t.replace(i,function(t){var e=u[t];return\"string\"==typeof e?e:\"\\\\u\"+(\"0000\"+t.charCodeAt(0).toString(16)).slice(-4)})+'\"':'\"'+t+'\"'}function o(t,e){var r,i,u,l,p,f=a,h=e[t];switch(h&&\"object\"==typeof h&&\"function\"==typeof h.toJSON&&(h=h.toJSON(t)),\"function\"==typeof c&&(h=c.call(e,t,h)),typeof h){case\"string\":return n(h);case\"number\":return isFinite(h)?String(h):\"null\";case\"boolean\":case\"null\":return String(h);case\"object\":if(!h)return\"null\";if(a+=s,p=[],\"[object Array]\"===Object.prototype.toString.apply(h)){for(l=h.length,r=0;r<l;r+=1)p[r]=o(r,h)||\"null\";return u=0===p.length?\"[]\":a?\"[\\n\"+a+p.join(\",\\n\"+a)+\"\\n\"+f+\"]\":\"[\"+p.join(\",\")+\"]\",a=f,u}if(c&&\"object\"==typeof c)for(l=c.length,r=0;r<l;r+=1)\"string\"==typeof c[r]&&(i=c[r],u=o(i,h),u&&p.push(n(i)+(a?\": \":\":\")+u));else for(i in h)Object.prototype.hasOwnProperty.call(h,i)&&(u=o(i,h),u&&p.push(n(i)+(a?\": \":\":\")+u));return u=0===p.length?\"{}\":a?\"{\\n\"+a+p.join(\",\\n\"+a)+\"\\n\"+f+\"}\":\"{\"+p.join(\",\")+\"}\",a=f,u}}var i=/[\\\\\"\\u0000-\\u001f\\u007f-\\u009f\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/g;\"function\"!=typeof Date.prototype.toJSON&&(Date.prototype.toJSON=function(){return isFinite(this.valueOf())?this.getUTCFullYear()+\"-\"+e(this.getUTCMonth()+1)+\"-\"+e(this.getUTCDate())+\"T\"+e(this.getUTCHours())+\":\"+e(this.getUTCMinutes())+\":\"+e(this.getUTCSeconds())+\"Z\":null},Boolean.prototype.toJSON=r,Number.prototype.toJSON=r,String.prototype.toJSON=r);var a,s,u,c;\"function\"!=typeof t.stringify&&(u={\"\\b\":\"\\\\b\",\"\\t\":\"\\\\t\",\"\\n\":\"\\\\n\",\"\\f\":\"\\\\f\",\"\\r\":\"\\\\r\",'\"':'\\\\\"',\"\\\\\":\"\\\\\\\\\"},t.stringify=function(t,e,r){var n;if(a=\"\",s=\"\",\"number\"==typeof r)for(n=0;n<r;n+=1)s+=\" \";else\"string\"==typeof r&&(s=r);if(c=e,e&&\"function\"!=typeof e&&(\"object\"!=typeof e||\"number\"!=typeof e.length))throw new Error(\"JSON.stringify\");return o(\"\",{\"\":t})}),\"function\"!=typeof t.parse&&(t.parse=function(){function t(t){return t.replace(/\\\\(?:u(.{4})|([^u]))/g,function(t,e,r){return e?String.fromCharCode(parseInt(e,16)):a[r]})}var e,r,n,o,i,a={\"\\\\\":\"\\\\\",'\"':'\"',\"/\":\"/\",t:\"\\t\",n:\"\\n\",r:\"\\r\",f:\"\\f\",b:\"\\b\"},s={go:function(){e=\"ok\"},firstokey:function(){o=i,e=\"colon\"},okey:function(){o=i,e=\"colon\"},ovalue:function(){e=\"ocomma\"},firstavalue:function(){e=\"acomma\"},avalue:function(){e=\"acomma\"}},u={go:function(){e=\"ok\"},ovalue:function(){e=\"ocomma\"},firstavalue:function(){e=\"acomma\"},avalue:function(){e=\"acomma\"}},c={\"{\":{go:function(){r.push({state:\"ok\"}),n={},e=\"firstokey\"},ovalue:function(){r.push({container:n,state:\"ocomma\",key:o}),n={},e=\"firstokey\"},firstavalue:function(){r.push({container:n,state:\"acomma\"}),n={},e=\"firstokey\"},avalue:function(){r.push({container:n,state:\"acomma\"}),n={},e=\"firstokey\"}},\"}\":{firstokey:function(){var t=r.pop();i=n,n=t.container,o=t.key,e=t.state},ocomma:function(){var t=r.pop();n[o]=i,i=n,n=t.container,o=t.key,e=t.state}},\"[\":{go:function(){r.push({state:\"ok\"}),n=[],e=\"firstavalue\"},ovalue:function(){r.push({container:n,state:\"ocomma\",key:o}),n=[],e=\"firstavalue\"},firstavalue:function(){r.push({container:n,state:\"acomma\"}),n=[],e=\"firstavalue\"},avalue:function(){r.push({container:n,state:\"acomma\"}),n=[],e=\"firstavalue\"}},\"]\":{firstavalue:function(){var t=r.pop();i=n,n=t.container,o=t.key,e=t.state},acomma:function(){var t=r.pop();n.push(i),i=n,n=t.container,o=t.key,e=t.state}},\":\":{colon:function(){if(Object.hasOwnProperty.call(n,o))throw new SyntaxError(\"Duplicate key '\"+o+'\"');e=\"ovalue\"}},\",\":{ocomma:function(){n[o]=i,e=\"okey\"},acomma:function(){n.push(i),e=\"avalue\"}},true:{go:function(){i=!0,e=\"ok\"},ovalue:function(){i=!0,e=\"ocomma\"},firstavalue:function(){i=!0,e=\"acomma\"},avalue:function(){i=!0,e=\"acomma\"}},false:{go:function(){i=!1,e=\"ok\"},ovalue:function(){i=!1,e=\"ocomma\"},firstavalue:function(){i=!1,e=\"acomma\"},avalue:function(){i=!1,e=\"acomma\"}},null:{go:function(){i=null,e=\"ok\"},ovalue:function(){i=null,e=\"ocomma\"},firstavalue:function(){i=null,e=\"acomma\"},avalue:function(){i=null,e=\"acomma\"}}};return function(n,o){var a,l=/^[\\u0020\\t\\n\\r]*(?:([,:\\[\\]{}]|true|false|null)|(-?\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d+)?)|\"((?:[^\\r\\n\\t\\\\\\\"]|\\\\(?:[\"\\\\\\/trnfb]|u[0-9a-fA-F]{4}))*)\")/;e=\"go\",r=[];try{for(;;){if(a=l.exec(n),!a)break;a[1]?c[a[1]][e]():a[2]?(i=+a[2],u[e]()):(i=t(a[3]),s[e]()),n=n.slice(a[0].length)}}catch(t){e=t}if(\"ok\"!==e||/[^\\u0020\\t\\n\\r]/.test(n))throw e instanceof SyntaxError?e:new SyntaxError(\"JSON\");return\"function\"==typeof o?function t(e,r){var n,a,s=e[r];if(s&&\"object\"==typeof s)for(n in i)Object.prototype.hasOwnProperty.call(s,n)&&(a=t(s,n),void 0!==a?s[n]=a:delete s[n]);return o.call(e,r,s)}({\"\":i},\"\"):i}}())};t.exports=r},function(t,e,r){\"use strict\";function n(t,e,r,n){this.rateLimiter=t,this.api=e,this.logger=r,this.options=n,this.predicates=[],this.pendingItems=[],this.pendingRequests=[],this.retryQueue=[],this.retryHandle=null,this.waitCallback=null,this.waitIntervalID=null}var o=r(5);n.prototype.configure=function(t){this.api&&this.api.configure(t);var e=this.options;return this.options=o.merge(e,t),this},n.prototype.addPredicate=function(t){return o.isFunction(t)&&this.predicates.push(t),this},n.prototype.addPendingItem=function(t){this.pendingItems.push(t)},n.prototype.removePendingItem=function(t){var e=this.pendingItems.indexOf(t);e!==-1&&this.pendingItems.splice(e,1)},n.prototype.addItem=function(t,e,r,n){e&&o.isFunction(e)||(e=function(){});var i=this._applyPredicates(t);if(i.stop)return this.removePendingItem(n),void e(i.err);this._maybeLog(t,r),this.removePendingItem(n),this.pendingRequests.push(t);try{this._makeApiRequest(t,function(r,n){this._dequeuePendingRequest(t),e(r,n)}.bind(this))}catch(r){this._dequeuePendingRequest(t),e(r)}},n.prototype.wait=function(t){o.isFunction(t)&&(this.waitCallback=t,this._maybeCallWait()||(this.waitIntervalID&&(this.waitIntervalID=clearInterval(this.waitIntervalID)),this.waitIntervalID=setInterval(function(){this._maybeCallWait()}.bind(this),500)))},n.prototype._applyPredicates=function(t){for(var e=null,r=0,n=this.predicates.length;r<n;r++)if(e=this.predicates[r](t,this.options),!e||void 0!==e.err)return{stop:!0,err:e.err};return{stop:!1,err:null}},n.prototype._makeApiRequest=function(t,e){var r=this.rateLimiter.shouldSend(t);r.shouldSend?this.api.postItem(t,function(r,n){r?this._maybeRetry(r,t,e):e(r,n)}.bind(this)):r.error?e(r.error):this.api.postItem(r.payload,e)};var i=[\"ECONNRESET\",\"ENOTFOUND\",\"ESOCKETTIMEDOUT\",\"ETIMEDOUT\",\"ECONNREFUSED\",\"EHOSTUNREACH\",\"EPIPE\",\"EAI_AGAIN\"];n.prototype._maybeRetry=function(t,e,r){var n=!1;if(this.options.retryInterval)for(var o=0,a=i.length;o<a;o++)if(t.code===i[o]){n=!0;break}n?this._retryApiRequest(e,r):r(t)},n.prototype._retryApiRequest=function(t,e){this.retryQueue.push({item:t,callback:e}),this.retryHandle||(this.retryHandle=setInterval(function(){for(;this.retryQueue.length;){var t=this.retryQueue.shift();this._makeApiRequest(t.item,t.callback)}}.bind(this),this.options.retryInterval))},n.prototype._dequeuePendingRequest=function(t){var e=this.pendingRequests.indexOf(t);e!==-1&&(this.pendingRequests.splice(e,1),this._maybeCallWait())},n.prototype._maybeLog=function(t,e){if(this.logger&&this.options.verbose){var r=e;if(r=r||o.get(t,\"body.trace.exception.message\"),r=r||o.get(t,\"body.trace_chain.0.exception.message\"))return void this.logger.error(r);r=o.get(t,\"body.message.body\"),r&&this.logger.log(r)}},n.prototype._maybeCallWait=function(){return!(!o.isFunction(this.waitCallback)||0!==this.pendingItems.length||0!==this.pendingRequests.length)&&(this.waitIntervalID&&(this.waitIntervalID=clearInterval(this.waitIntervalID)),this.waitCallback(),!0)},t.exports=n},function(t,e,r){\"use strict\";function n(t,e){this.queue=t,this.options=e,this.transforms=[]}var o=r(5);n.prototype.configure=function(t){this.queue&&this.queue.configure(t);var e=this.options;return this.options=o.merge(e,t),this},n.prototype.addTransform=function(t){return o.isFunction(t)&&this.transforms.push(t),this},n.prototype.log=function(t,e){if(e&&o.isFunction(e)||(e=function(){}),!this.options.enabled)return e(new Error(\"Rollbar is not enabled\"));this.queue.addPendingItem(t);var r=t.err;this._applyTransforms(t,function(n,o){return n?(this.queue.removePendingItem(t),e(n,null)):void this.queue.addItem(o,e,r,t)}.bind(this))},n.prototype._applyTransforms=function(t,e){var r=-1,n=this.transforms.length,o=this.transforms,i=this.options,a=function(t,s){return t?void e(t,null):(r++,r===n?void e(null,s):void o[r](s,i,a))};a(null,t)},t.exports=n},function(t,e,r){\"use strict\";function n(t){this.queue=[],this.options=i.merge(t);var e=this.options.maxTelemetryEvents||a;this.maxQueueSize=Math.max(0,Math.min(e,a))}function o(t,e){if(e)return e;var r={error:\"error\",manual:\"info\"};return r[t]||\"info\"}var i=r(5),a=100;n.prototype.configure=function(t){var e=this.options;this.options=i.merge(e,t);var r=this.options.maxTelemetryEvents||a,n=Math.max(0,Math.min(r,a)),o=0;this.maxQueueSize>n&&(o=this.maxQueueSize-n),this.maxQueueSize=n,this.queue.splice(0,o)},n.prototype.copyEvents=function(){return Array.prototype.slice.call(this.queue,0)},n.prototype.capture=function(t,e,r,n,a){var s={level:o(t,r),type:t,timestamp_ms:a||i.now(),body:e,source:\"client\"};n&&(s.uuid=n);try{if(i.isFunction(this.options.filterTelemetry)&&this.options.filterTelemetry(s))return!1}catch(t){this.options.filterTelemetry=null}return this.push(s),s},n.prototype.captureEvent=function(t,e,r){return this.capture(\"manual\",t,e,r)},n.prototype.captureError=function(t,e,r,n){var o={message:t.message||String(t)};return t.stack&&(o.stack=t.stack),this.capture(\"error\",o,e,r,n)},n.prototype.captureLog=function(t,e,r,n){return this.capture(\"log\",{message:t},e,r,n)},n.prototype.captureNetwork=function(t,e,r,n){e=e||\"xhr\",t.subtype=t.subtype||e,n&&(t.request=n);var o=this.levelFromStatus(t.status_code);return this.capture(\"network\",t,o,r)},n.prototype.levelFromStatus=function(t){return t>=200&&t<400?\"info\":0===t||t>=400?\"error\":\"info\"},n.prototype.captureDom=function(t,e,r,n,o){var i={subtype:t,element:e};return void 0!==r&&(i.value=r),void 0!==n&&(i.checked=n),this.capture(\"dom\",i,\"info\",o)},n.prototype.captureNavigation=function(t,e,r){return this.capture(\"navigation\",{from:t,to:e},\"info\",r)},n.prototype.captureDomContentLoaded=function(t){return this.capture(\"navigation\",{subtype:\"DOMContentLoaded\"},\"info\",void 0,t&&t.getTime())},n.prototype.captureLoad=function(t){return this.capture(\"navigation\",{subtype:\"load\"},\"info\",void 0,t&&t.getTime())},n.prototype.captureConnectivityChange=function(t,e){return this.captureNetwork({change:t},\"connectivity\",e)},n.prototype._captureRollbarItem=function(t){if(this.options.includeItemsInTelemetry)return t.err?this.captureError(t.err,t.level,t.uuid,t.timestamp):t.message?this.captureLog(t.message,t.level,t.uuid,t.timestamp):t.custom?this.capture(\"log\",t.custom,t.level,t.uuid,t.timestamp):void 0},n.prototype.push=function(t){this.queue.push(t),this.queue.length>this.maxQueueSize&&this.queue.shift()},t.exports=n},function(t,e,r){\"use strict\";function n(t,e,r,n){this.options=t,this.transport=e,this.url=r,this.jsonBackup=n,this.accessToken=t.accessToken,this.transportOptions=o(t,r)}function o(t,e){return a.getTransportFromOptions(t,s,e)}var i=r(5),a=r(12),s={hostname:\"api.rollbar.com\",path:\"/api/1/item/\",search:null,version:\"1\",protocol:\"https:\",port:443};n.prototype.postItem=function(t,e){var r=a.transportOptions(this.transportOptions,\"POST\"),n=a.buildPayload(this.accessToken,t,this.jsonBackup);this.transport.post(this.accessToken,r,n,e)},n.prototype.configure=function(t){var e=this.oldOptions;return this.options=i.merge(e,t),this.transportOptions=o(this.options,this.url),void 0!==this.options.accessToken&&(this.accessToken=this.options.accessToken),this},t.exports=n},function(t,e,r){\"use strict\";function n(t,e,r){if(!s.isType(e.context,\"string\")){var n=s.stringify(e.context,r);n.error?e.context=\"Error: could not serialize 'context'\":e.context=n.value||\"\",e.context.length>255&&(e.context=e.context.substr(0,255))}return{access_token:t,data:e}}function o(t,e,r){var n=e.hostname,o=e.protocol,i=e.port,a=e.path,s=e.search,u=t.proxy;if(t.endpoint){var c=r.parse(t.endpoint);n=c.hostname,o=c.protocol,i=c.port,a=c.pathname,s=c.search}return{hostname:n,protocol:o,port:i,path:a,search:s,proxy:u}}function i(t,e){var r=t.protocol||\"https:\",n=t.port||(\"http:\"===r?80:\"https:\"===r?443:void 0),o=t.hostname,i=t.path;return t.search&&(i+=t.search),t.proxy&&(i=r+\"//\"+o+i,o=t.proxy.host||t.proxy.hostname,n=t.proxy.port,r=t.proxy.protocol||r),{protocol:r,hostname:o,path:i,port:n,method:e}}function a(t,e){var r=/\\/$/.test(t),n=/^\\//.test(e);return r&&n?e=e.substring(1):r||n||(e=\"/\"+e),t+e}var s=r(5);t.exports={buildPayload:n,getTransportFromOptions:o,transportOptions:i,appendPathToPath:a}},function(t,e,r){\"use strict\";function n(){var t=Array.prototype.slice.call(arguments,0);t.unshift(\"Rollbar:\"),a.ieVersion()<=8?console.error(s.formatArgsAsString(t)):console.error.apply(console,t)}function o(){var t=Array.prototype.slice.call(arguments,0);t.unshift(\"Rollbar:\"),a.ieVersion()<=8?console.info(s.formatArgsAsString(t)):console.info.apply(console,t)}function i(){var t=Array.prototype.slice.call(arguments,0);t.unshift(\"Rollbar:\"),a.ieVersion()<=8?console.log(s.formatArgsAsString(t)):console.log.apply(console,t)}\nr(14);var a=r(15),s=r(5);t.exports={error:n,info:o,log:i}},function(t,e){!function(t){\"use strict\";t.console||(t.console={});for(var e,r,n=t.console,o=function(){},i=[\"memory\"],a=\"assert,clear,count,debug,dir,dirxml,error,exception,group,groupCollapsed,groupEnd,info,log,markTimeline,profile,profiles,profileEnd,show,table,time,timeEnd,timeline,timelineEnd,timeStamp,trace,warn\".split(\",\");e=i.pop();)n[e]||(n[e]={});for(;r=a.pop();)n[r]||(n[r]=o)}(\"undefined\"==typeof window?this:window)},function(t,e){\"use strict\";function r(){var t;if(!document)return t;for(var e=3,r=document.createElement(\"div\"),n=r.getElementsByTagName(\"i\");r.innerHTML=\"<!--[if gt IE \"+ ++e+\"]><i></i><![endif]-->\",n[0];);return e>4?e:t}var n={ieVersion:r};t.exports=n},function(t,e){\"use strict\";function r(t,e,r){if(t){var o;if(\"function\"==typeof e._rollbarOldOnError)o=e._rollbarOldOnError;else if(t.onerror){for(o=t.onerror;o._rollbarOldOnError;)o=o._rollbarOldOnError;e._rollbarOldOnError=o}var i=function(){var r=Array.prototype.slice.call(arguments,0);n(t,e,o,r)};r&&(i._rollbarOldOnError=o),t.onerror=i}}function n(t,e,r,n){t._rollbarWrappedError&&(n[4]||(n[4]=t._rollbarWrappedError),n[5]||(n[5]=t._rollbarWrappedError._rollbarContext),t._rollbarWrappedError=null),e.handleUncaughtException.apply(e,n),r&&r.apply(t,n)}function o(t,e,r){if(t){\"function\"==typeof t._rollbarURH&&t._rollbarURH.belongsToShim&&t.removeEventListener(\"unhandledrejection\",t._rollbarURH);var n=function(t){var r,n,o;try{r=t.reason}catch(t){r=void 0}try{n=t.promise}catch(t){n=\"[unhandledrejection] error getting `promise` from event\"}try{o=t.detail,!r&&o&&(r=o.reason,n=o.promise)}catch(t){o=\"[unhandledrejection] error getting `detail` from event\"}r||(r=\"[unhandledrejection] error getting `reason` from event\"),e&&e.handleUnhandledRejection&&e.handleUnhandledRejection(r,n)};n.belongsToShim=r,t._rollbarURH=n,t.addEventListener(\"unhandledrejection\",n)}}function i(t,e,r){if(t){var n,o,i=\"EventTarget,Window,Node,ApplicationCache,AudioTrackList,ChannelMergerNode,CryptoOperation,EventSource,FileReader,HTMLUnknownElement,IDBDatabase,IDBRequest,IDBTransaction,KeyOperation,MediaController,MessagePort,ModalWindow,Notification,SVGElementInstance,Screen,TextTrack,TextTrackCue,TextTrackList,WebSocket,WebSocketWorker,Worker,XMLHttpRequest,XMLHttpRequestEventTarget,XMLHttpRequestUpload\".split(\",\");for(n=0;n<i.length;++n)o=i[n],t[o]&&t[o].prototype&&a(e,t[o].prototype,r)}}function a(t,e,r){if(e.hasOwnProperty&&e.hasOwnProperty(\"addEventListener\")){for(var n=e.addEventListener;n._rollbarOldAdd&&n.belongsToShim;)n=n._rollbarOldAdd;var o=function(e,r,o){n.call(this,e,t.wrap(r),o)};o._rollbarOldAdd=n,o.belongsToShim=r,e.addEventListener=o;for(var i=e.removeEventListener;i._rollbarOldRemove&&i.belongsToShim;)i=i._rollbarOldRemove;var a=function(t,e,r){i.call(this,t,e&&e._rollbar_wrapped||e,r)};a._rollbarOldRemove=i,a.belongsToShim=r,e.removeEventListener=a}}t.exports={captureUncaughtExceptions:r,captureUnhandledRejections:o,wrapGlobals:i}},function(t,e,r){\"use strict\";function n(t,e,r,n,o){n&&l.isFunction(n)||(n=function(){}),l.addParamsAndAccessTokenToPath(t,e,r);var a=\"GET\",s=l.formatUrl(e);i(t,s,a,null,n,o)}function o(t,e,r,n,o){if(n&&l.isFunction(n)||(n=function(){}),!r)return n(new Error(\"Cannot send empty request\"));var a=p.truncate(r);if(a.error)return n(a.error);var s=a.value,u=\"POST\",c=l.formatUrl(e);i(t,c,u,s,n,o)}function i(t,e,r,n,o,i){var p;if(p=i?i():a(),!p)return o(new Error(\"No way to send a request\"));try{try{var h=function(){try{if(h&&4===p.readyState){h=void 0;var t=l.jsonParse(p.responseText);if(s(p))return void o(t.error,t.value);if(u(p)){if(403===p.status){var e=t.value&&t.value.message;f.error(e)}o(new Error(String(p.status)))}else{var r=\"XHR response had no status code (likely connection failure)\";o(c(r))}}}catch(t){var n;n=t&&t.stack?t:new Error(t),o(n)}};p.open(r,e,!0),p.setRequestHeader&&(p.setRequestHeader(\"Content-Type\",\"application/json\"),p.setRequestHeader(\"X-Rollbar-Access-Token\",t)),p.onreadystatechange=h,p.send(n)}catch(t){if(\"undefined\"!=typeof XDomainRequest){if(!window||!window.location)return o(new Error(\"No window available during request, unknown environment\"));\"http:\"===window.location.href.substring(0,5)&&\"https\"===e.substring(0,5)&&(e=\"http\"+e.substring(5));var d=new XDomainRequest;d.onprogress=function(){},d.ontimeout=function(){var t=\"Request timed out\",e=\"ETIMEDOUT\";o(c(t,e))},d.onerror=function(){o(new Error(\"Error during request\"))},d.onload=function(){var t=l.jsonParse(d.responseText);o(t.error,t.value)},d.open(r,e,!0),d.send(n)}else o(new Error(\"Cannot find a method to transport a request\"))}}catch(t){o(t)}}function a(){var t,e,r=[function(){return new XMLHttpRequest},function(){return new ActiveXObject(\"Msxml2.XMLHTTP\")},function(){return new ActiveXObject(\"Msxml3.XMLHTTP\")},function(){return new ActiveXObject(\"Microsoft.XMLHTTP\")}],n=r.length;for(e=0;e<n;e++)try{t=r[e]();break}catch(t){}return t}function s(t){return t&&t.status&&200===t.status}function u(t){return t&&l.isType(t.status,\"number\")&&t.status>=400&&t.status<600}function c(t,e){var r=new Error(t);return r.code=e||\"ENOTFOUND\",r}var l=r(5),p=r(18),f=r(13);t.exports={get:n,post:o}},function(t,e,r){\"use strict\";function n(t,e){return[t,f.stringify(t,e)]}function o(t,e){var r=t.length;return r>2*e?t.slice(0,e).concat(t.slice(r-e)):t}function i(t,e,r){r=\"undefined\"==typeof r?30:r;var n,i=t.data.body;if(i.trace_chain)for(var a=i.trace_chain,s=0;s<a.length;s++)n=a[s].frames,n=o(n,r),a[s].frames=n;else i.trace&&(n=i.trace.frames,n=o(n,r),i.trace.frames=n);return[t,f.stringify(t,e)]}function a(t,e){return e&&e.length>t?e.slice(0,t-3).concat(\"...\"):e}function s(t,e,r){function n(e,r,o){switch(f.typeName(r)){case\"string\":return a(t,r);case\"object\":case\"array\":return f.traverse(r,n,o);default:return r}}return e=f.traverse(e,n,[]),[e,f.stringify(e,r)]}function u(t){return t.exception&&(delete t.exception.description,t.exception.message=a(255,t.exception.message)),t.frames=o(t.frames,1),t}function c(t,e){var r=t.data.body;if(r.trace_chain)for(var n=r.trace_chain,o=0;o<n.length;o++)n[o]=u(n[o]);else r.trace&&(r.trace=u(r.trace));return[t,f.stringify(t,e)]}function l(t,e){return t.length>e}function p(t,e,r){r=\"undefined\"==typeof r?524288:r;for(var o,a,u,p=[n,i,s.bind(null,1024),s.bind(null,512),s.bind(null,256),c];o=p.shift();)if(a=o(t,e),t=a[0],u=a[1],u.error||!l(u.value,r))return u;return u}var f=r(5);t.exports={truncate:p,raw:n,truncateFrames:i,truncateStrings:s,maybeTruncateValue:a}},function(t,e){\"use strict\";function r(t){var e,r,n={protocol:null,auth:null,host:null,path:null,hash:null,href:t,hostname:null,port:null,pathname:null,search:null,query:null};if(e=t.indexOf(\"//\"),e!==-1?(n.protocol=t.substring(0,e),r=e+2):r=0,e=t.indexOf(\"@\",r),e!==-1&&(n.auth=t.substring(r,e),r=e+1),e=t.indexOf(\"/\",r),e===-1){if(e=t.indexOf(\"?\",r),e===-1)return e=t.indexOf(\"#\",r),e===-1?n.host=t.substring(r):(n.host=t.substring(r,e),n.hash=t.substring(e)),n.hostname=n.host.split(\":\")[0],n.port=n.host.split(\":\")[1],n.port&&(n.port=parseInt(n.port,10)),n;n.host=t.substring(r,e),n.hostname=n.host.split(\":\")[0],n.port=n.host.split(\":\")[1],n.port&&(n.port=parseInt(n.port,10)),r=e}else n.host=t.substring(r,e),n.hostname=n.host.split(\":\")[0],n.port=n.host.split(\":\")[1],n.port&&(n.port=parseInt(n.port,10)),r=e;if(e=t.indexOf(\"#\",r),e===-1?n.path=t.substring(r):(n.path=t.substring(r,e),n.hash=t.substring(e)),n.path){var o=n.path.split(\"?\");n.pathname=o[0],n.query=o[1],n.search=n.query?\"?\"+n.query:null}return n}t.exports={parse:r}},function(t,e,r){\"use strict\";function n(t,e,r){if(t.data=t.data||{},t.err)try{t.stackInfo=t.err._savedStackTrace||d.parse(t.err)}catch(e){m.error(\"Error while parsing the error object.\",e);try{t.message=t.err.message||t.err.description||t.message||String(t.err)}catch(e){t.message=String(t.err)||String(e)}delete t.err}r(null,t)}function o(t,e,r){t.message||t.stackInfo||t.custom||r(new Error(\"No message, stack info, or custom data\"),null),r(null,t)}function i(t,e,r){var n=e.payload&&e.payload.environment||e.environment;t.data=h.merge(t.data,{environment:n,level:t.level,endpoint:e.endpoint,platform:\"browser\",framework:\"browser-js\",language:\"javascript\",server:{},uuid:t.uuid,notifier:{name:\"rollbar-browser-js\",version:e.version}}),r(null,t)}function a(t){return function(e,r,n){if(!t||!t.location)return n(null,e);var o=\"$remote_ip\";r.captureIp?r.captureIp!==!0&&(o+=\"_anonymize\"):o=null,h.set(e,\"data.request\",{url:t.location.href,query_string:t.location.search,user_ip:o}),n(null,e)}}function s(t){return function(e,r,n){if(!t)return n(null,e);var o=t.navigator||{},i=t.screen||{};h.set(e,\"data.client\",{runtime_ms:e.timestamp-t._rollbarStartTime,timestamp:Math.round(e.timestamp/1e3),javascript:{browser:o.userAgent,language:o.language,cookie_enabled:o.cookieEnabled,screen:{width:i.width,height:i.height}}}),n(null,e)}}function u(t){return function(e,r,n){if(!t||!t.navigator)return n(null,e);for(var o,i=[],a=t.navigator.plugins||[],s=0,u=a.length;s<u;++s)o=a[s],i.push({name:o.name,description:o.description});h.set(e,\"data.client.javascript.plugins\",i),n(null,e)}}function c(t,e,r){t.stackInfo?p(t,e,r):l(t,e,r)}function l(t,e,r){var n=t.message,o=t.custom;if(!n)if(o){var i=e.scrubFields,a=h.stringify(h.scrub(o,i));n=a.error||a.value||\"\"}else n=\"\";var s={body:n};o&&(s.extra=h.merge(o)),h.set(t,\"data.body\",{message:s}),r(null,t)}function p(t,e,r){var n=t.data.description,o=t.stackInfo,i=t.custom,a=d.guessErrorClass(o.message),s=o.name||a[0],u=a[1],c={exception:{class:s,message:u}};n&&(c.exception.description=n);var p=o.stack;if(p&&0===p.length&&t._unhandledStackInfo&&t._unhandledStackInfo.stack&&(p=t._unhandledStackInfo.stack),p){0===p.length&&(c.exception.stack=o.rawStack,c.exception.raw=String(o.rawException));var f,m,g,v,y,b,w,_;for(c.frames=[],w=0;w<p.length;++w)f=p[w],m={filename:f.url?h.sanitizeUrl(f.url):\"(unknown)\",lineno:f.line||null,method:f.func&&\"?\"!==f.func?f.func:\"[anonymous]\",colno:f.column},m.method&&m.method.endsWith&&m.method.endsWith(\"_rollbar_wrapped\")||(g=v=y=null,b=f.context?f.context.length:0,b&&(_=Math.floor(b/2),v=f.context.slice(0,_),g=f.context[_],y=f.context.slice(_)),g&&(m.code=g),(v||y)&&(m.context={},v&&v.length&&(m.context.pre=v),y&&y.length&&(m.context.post=y)),f.args&&(m.args=f.args),c.frames.push(m));c.frames.reverse(),i&&(c.extra=h.merge(i)),h.set(t,\"data.body\",{trace:c}),r(null,t)}else t.message=s+\": \"+u,l(t,e,r)}function f(t,e,r){var n=e.scrubFields;t.data=h.scrub(t.data,n),r(null,t)}var h=r(5),d=r(21),m=r(13);t.exports={handleItemWithError:n,ensureItemHasSomethingToSay:o,addBaseInfo:i,addRequestInfo:a,addClientInfo:s,addPluginInfo:u,addBody:c,scrubPayload:f}},function(t,e,r){\"use strict\";function n(){return l}function o(){return null}function i(t){var e={};return e._stackFrame=t,e.url=t.fileName,e.line=t.lineNumber,e.func=t.functionName,e.column=t.columnNumber,e.args=t.args,e.context=o(e.url,e.line),e}function a(t){function e(){var e,r=[];if(t.stack)e=t;else try{throw t}catch(t){e=t}try{r=c.parse(e)}catch(t){r=[]}for(var n=[],o=0;o<r.length;o++)n.push(new i(r[o]));return n}return{stack:e(),message:t.message,name:t.name,rawStack:t.stack,rawException:t}}function s(t){return new a(t)}function u(t){if(!t||!t.match)return[\"Unknown error. There was no error message to display.\",\"\"];var e=t.match(p),r=\"(unknown)\";return e&&(r=e[e.length-1],t=t.replace((e[e.length-2]||\"\")+r+\":\",\"\"),t=t.replace(/(^[\\s]+|[\\s]+$)/g,\"\")),[r,t]}var c=r(22),l=\"?\",p=new RegExp(\"^(([a-zA-Z0-9-_$ ]*): *)?(Uncaught )?([a-zA-Z0-9-_$ ]*): \");t.exports={guessFunctionName:n,guessErrorClass:u,gatherContext:o,parse:s,Stack:a,Frame:i}},function(t,e,r){var n,o,i;!function(a,s){\"use strict\";o=[r(23)],n=s,i=\"function\"==typeof n?n.apply(e,o):n,!(void 0!==i&&(t.exports=i))}(this,function(t){\"use strict\";function e(t,e,r){if(\"function\"==typeof Array.prototype.map)return t.map(e,r);for(var n=new Array(t.length),o=0;o<t.length;o++)n[o]=e.call(r,t[o]);return n}function r(t,e,r){if(\"function\"==typeof Array.prototype.filter)return t.filter(e,r);for(var n=[],o=0;o<t.length;o++)e.call(r,t[o])&&n.push(t[o]);return n}var n=/(^|@)\\S+\\:\\d+/,o=/^\\s*at .*(\\S+\\:\\d+|\\(native\\))/m,i=/^(eval@)?(\\[native code\\])?$/;return{parse:function(t){if(\"undefined\"!=typeof t.stacktrace||\"undefined\"!=typeof t[\"opera#sourceloc\"])return this.parseOpera(t);if(t.stack&&t.stack.match(o))return this.parseV8OrIE(t);if(t.stack)return this.parseFFOrSafari(t);throw new Error(\"Cannot parse given Error object\")},extractLocation:function(t){if(t.indexOf(\":\")===-1)return[t];var e=t.replace(/[\\(\\)\\s]/g,\"\").split(\":\"),r=e.pop(),n=e[e.length-1];if(!isNaN(parseFloat(n))&&isFinite(n)){var o=e.pop();return[e.join(\":\"),o,r]}return[e.join(\":\"),r,void 0]},parseV8OrIE:function(n){var i=r(n.stack.split(\"\\n\"),function(t){return!!t.match(o)},this);return e(i,function(e){e.indexOf(\"(eval \")>-1&&(e=e.replace(/eval code/g,\"eval\").replace(/(\\(eval at [^\\()]*)|(\\)\\,.*$)/g,\"\"));var r=e.replace(/^\\s+/,\"\").replace(/\\(eval code/g,\"(\").split(/\\s+/).slice(1),n=this.extractLocation(r.pop()),o=r.join(\" \")||void 0,i=\"eval\"===n[0]?void 0:n[0];return new t(o,void 0,i,n[1],n[2],e)},this)},parseFFOrSafari:function(n){var o=r(n.stack.split(\"\\n\"),function(t){return!t.match(i)},this);return e(o,function(e){if(e.indexOf(\" > eval\")>-1&&(e=e.replace(/ line (\\d+)(?: > eval line \\d+)* > eval\\:\\d+\\:\\d+/g,\":$1\")),e.indexOf(\"@\")===-1&&e.indexOf(\":\")===-1)return new t(e);var r=e.split(\"@\"),n=this.extractLocation(r.pop()),o=r.shift()||void 0;return new t(o,void 0,n[0],n[1],n[2],e)},this)},parseOpera:function(t){return!t.stacktrace||t.message.indexOf(\"\\n\")>-1&&t.message.split(\"\\n\").length>t.stacktrace.split(\"\\n\").length?this.parseOpera9(t):t.stack?this.parseOpera11(t):this.parseOpera10(t)},parseOpera9:function(e){for(var r=/Line (\\d+).*script (?:in )?(\\S+)/i,n=e.message.split(\"\\n\"),o=[],i=2,a=n.length;i<a;i+=2){var s=r.exec(n[i]);s&&o.push(new t(void 0,void 0,s[2],s[1],void 0,n[i]))}return o},parseOpera10:function(e){for(var r=/Line (\\d+).*script (?:in )?(\\S+)(?:: In function (\\S+))?$/i,n=e.stacktrace.split(\"\\n\"),o=[],i=0,a=n.length;i<a;i+=2){var s=r.exec(n[i]);s&&o.push(new t(s[3]||void 0,void 0,s[2],s[1],void 0,n[i]))}return o},parseOpera11:function(o){var i=r(o.stack.split(\"\\n\"),function(t){return!!t.match(n)&&!t.match(/^Error created at/)},this);return e(i,function(e){var r,n=e.split(\"@\"),o=this.extractLocation(n.pop()),i=n.shift()||\"\",a=i.replace(/<anonymous function(: (\\w+))?>/,\"$2\").replace(/\\([^\\)]*\\)/g,\"\")||void 0;i.match(/\\(([^\\)]*)\\)/)&&(r=i.replace(/^[^\\(]+\\(([^\\)]*)\\)$/,\"$1\"));var s=void 0===r||\"[arguments not available]\"===r?void 0:r.split(\",\");return new t(a,s,o[0],o[1],o[2],e)},this)}}})},function(t,e,r){var n,o,i;!function(r,a){\"use strict\";o=[],n=a,i=\"function\"==typeof n?n.apply(e,o):n,!(void 0!==i&&(t.exports=i))}(this,function(){\"use strict\";function t(t){return!isNaN(parseFloat(t))&&isFinite(t)}function e(t,e,r,n,o,i){void 0!==t&&this.setFunctionName(t),void 0!==e&&this.setArgs(e),void 0!==r&&this.setFileName(r),void 0!==n&&this.setLineNumber(n),void 0!==o&&this.setColumnNumber(o),void 0!==i&&this.setSource(i)}return e.prototype={getFunctionName:function(){return this.functionName},setFunctionName:function(t){this.functionName=String(t)},getArgs:function(){return this.args},setArgs:function(t){if(\"[object Array]\"!==Object.prototype.toString.call(t))throw new TypeError(\"Args must be an Array\");this.args=t},getFileName:function(){return this.fileName},setFileName:function(t){this.fileName=String(t)},getLineNumber:function(){return this.lineNumber},setLineNumber:function(e){if(!t(e))throw new TypeError(\"Line Number must be a Number\");this.lineNumber=Number(e)},getColumnNumber:function(){return this.columnNumber},setColumnNumber:function(e){if(!t(e))throw new TypeError(\"Column Number must be a Number\");this.columnNumber=Number(e)},getSource:function(){return this.source},setSource:function(t){this.source=String(t)},toString:function(){var e=this.getFunctionName()||\"{anonymous}\",r=\"(\"+(this.getArgs()||[]).join(\",\")+\")\",n=this.getFileName()?\"@\"+this.getFileName():\"\",o=t(this.getLineNumber())?\":\"+this.getLineNumber():\"\",i=t(this.getColumnNumber())?\":\"+this.getColumnNumber():\"\";return e+r+n+o+i}},e})},function(t,e,r){\"use strict\";function n(t,e,r){var n=e.payload||{};n.body&&delete n.body;var o=u.merge(t.data,n);t._isUncaught&&(o._isUncaught=!0),t._originalArgs&&(o._originalArgs=t._originalArgs),r(null,o)}function o(t,e,r){t.telemetryEvents&&u.set(t,\"data.body.telemetry\",t.telemetryEvents),r(null,t)}function i(t,e,r){if(!t.message)return void r(null,t);var n=\"data.body.trace_chain.0\",o=u.get(t,n);if(o||(n=\"data.body.trace\",o=u.get(t,n)),o){if(!o.exception||!o.exception.description)return u.set(t,n+\".exception.description\",t.message),void r(null,t);var i=u.get(t,n+\".extra\")||{},a=u.merge(i,{message:t.message});u.set(t,n+\".extra\",a)}r(null,t)}function a(t){return function(e,r,n){var o=u.merge(e);try{u.isFunction(r.transform)&&r.transform(o.data,e)}catch(o){return r.transform=null,t.error(\"Error while calling custom transform() function. Removing custom transform().\",o),void n(null,e)}n(null,o)}}function s(t,e,r){if(!e.sendConfig)return r(null,t);var n=\"_rollbarConfig\",o=u.get(t,\"data.custom\")||{};o[n]=e,t.data.custom=o,r(null,t)}var u=r(5);t.exports={itemToPayload:n,addTelemetryData:o,addMessageWithError:i,userTransform:a,addConfigToPayload:s}},function(t,e,r){\"use strict\";function n(t,e){return!o.get(e,\"plugins.jquery.ignoreAjaxErrors\")||!o.get(t,\"body.message.extra.isAjax\")}var o=r(5);t.exports={checkIgnore:n}},function(t,e,r){\"use strict\";function n(t,e){var r=t.level,n=c.LEVELS[r]||0,o=e.reportLevel,i=c.LEVELS[o]||0;return!(n<i)}function o(t){return function(e,r){var n=!!e._isUncaught;delete e._isUncaught;var o=e._originalArgs;delete e._originalArgs;try{c.isFunction(r.onSendCallback)&&r.onSendCallback(n,o,e)}catch(e){r.onSendCallback=null,t.error(\"Error while calling onSendCallback, removing\",e)}try{if(c.isFunction(r.checkIgnore)&&r.checkIgnore(n,o,e))return!1}catch(e){r.checkIgnore=null,t.error(\"Error while calling custom checkIgnore(), removing\",e)}return!0}}function i(t){return function(e,r){return!s(e,r,\"blacklist\",t)}}function a(t){return function(e,r){return s(e,r,\"whitelist\",t)}}function s(t,e,r,n){var o=!1;\"blacklist\"===r&&(o=!0);var i,a,s,u,l,p,f,h,d,m;try{if(i=o?e.hostBlackList:e.hostWhiteList,f=i&&i.length,a=c.get(t,\"body.trace\"),!i||0===f)return!o;if(!a||!a.frames||0===a.frames.length)return!o;for(l=a.frames.length,d=0;d<l;d++){if(s=a.frames[d],u=s.filename,!c.isType(u,\"string\"))return!o;for(m=0;m<f;m++)if(p=i[m],h=new RegExp(p),h.test(u))return!0}}catch(t){o?e.hostBlackList=null:e.hostWhiteList=null;var g=o?\"hostBlackList\":\"hostWhiteList\";return n.error(\"Error while reading your configuration's \"+g+\" option. Removing custom \"+g+\".\",t),!o}return!1}function u(t){return function(e,r){var n,o,i,a,s,u,l,p,f;try{if(s=!1,i=r.ignoredMessages,!i||0===i.length)return!0;if(l=e.body,p=c.get(l,\"trace.exception.message\"),f=c.get(l,\"message.body\"),n=p||f,!n)return!0;for(a=i.length,o=0;o<a&&(u=new RegExp(i[o],\"gi\"),!(s=u.test(n)));o++);}catch(e){r.ignoredMessages=null,t.error(\"Error while reading your configuration's ignoredMessages option. Removing custom ignoredMessages.\")}return!s}}var c=r(5);t.exports={checkLevel:n,userCheckIgnore:o,urlIsNotBlacklisted:i,urlIsWhitelisted:a,messageIsIgnored:u}},function(t,e,r){\"use strict\";function n(t,e,r,n,o){var i=t[e];t[e]=r(i),n&&n[o].push([t,e,i])}function o(t,e){for(var r;t[e].length;)r=t[e].shift(),r[0][r[1]]=r[2]}function i(t){if(!t||!t.attributes)return null;for(var e=t.attributes,r=0;r<e.length;++r)if(\"name\"===e[r].key)return e[r].value;return null}function a(t){for(var e=[],r=0;r<t.length;++r)e.push(new RegExp(t[r],\"i\"));return function(t){var r=i(t);if(!r)return!1;for(var n=0;n<e.length;++n)if(e[n].test(r))return!0;return!1}}function s(t,e,r,n,o){var i=t.autoInstrument;t.enabled===!1||i===!1?this.autoInstrument={}:(u.isType(i,\"object\")||(i=p),this.autoInstrument=u.merge(p,i)),this.scrubTelemetryInputs=!!t.scrubTelemetryInputs,this.telemetryScrubber=t.telemetryScrubber,this.defaultValueScrubber=a(t.scrubFields),this.telemeter=e,this.rollbar=r,this._window=n||{},this._document=o||{},this.replacements={network:[],log:[],navigation:[],connectivity:[]},this.eventRemovers={dom:[],connectivity:[]},this._location=this._window.location,this._lastHref=this._location&&this._location.href}var u=r(5),c=r(19),l=r(28),p={network:!0,networkResponseHeaders:!1,networkResponseBody:!1,networkRequestBody:!1,log:!0,dom:!0,navigation:!0,connectivity:!0};s.prototype.configure=function(t){var e=t.autoInstrument,r=u.merge(this.autoInstrument);t.enabled===!1||e===!1?this.autoInstrument={}:(u.isType(e,\"object\")||(e=p),this.autoInstrument=u.merge(p,e)),this.instrument(r),void 0!==t.scrubTelemetryInputs&&(this.scrubTelemetryInputs=!!t.scrubTelemetryInputs),void 0!==t.telemetryScrubber&&(this.telemetryScrubber=t.telemetryScrubber)},s.prototype.instrument=function(t){!this.autoInstrument.network||t&&t.network?!this.autoInstrument.network&&t&&t.network&&this.deinstrumentNetwork():this.instrumentNetwork(),!this.autoInstrument.log||t&&t.log?!this.autoInstrument.log&&t&&t.log&&this.deinstrumentConsole():this.instrumentConsole(),!this.autoInstrument.dom||t&&t.dom?!this.autoInstrument.dom&&t&&t.dom&&this.deinstrumentDom():this.instrumentDom(),!this.autoInstrument.navigation||t&&t.navigation?!this.autoInstrument.navigation&&t&&t.navigation&&this.deinstrumentNavigation():this.instrumentNavigation(),!this.autoInstrument.connectivity||t&&t.connectivity?!this.autoInstrument.connectivity&&t&&t.connectivity&&this.deinstrumentConnectivity():this.instrumentConnectivity()},s.prototype.deinstrumentNetwork=function(){o(this.replacements,\"network\")},s.prototype.instrumentNetwork=function(){function t(t,r){t in r&&u.isFunction(r[t])&&n(r,t,function(t){return e.rollbar.wrap(t)})}var e=this;if(\"XMLHttpRequest\"in this._window){var r=this._window.XMLHttpRequest.prototype;n(r,\"open\",function(t){return function(e,r){return u.isType(r,\"string\")&&(this.__rollbar_xhr={method:e,url:r,status_code:null,start_time_ms:u.now(),end_time_ms:null}),t.apply(this,arguments)}},this.replacements,\"network\"),n(r,\"send\",function(r){return function(o){function i(){if(a.__rollbar_xhr&&(1===a.readyState||4===a.readyState)){if(null===a.__rollbar_xhr.status_code){a.__rollbar_xhr.status_code=0;var t=null;e.autoInstrument.networkRequestBody&&(t=o),a.__rollbar_event=e.telemeter.captureNetwork(a.__rollbar_xhr,\"xhr\",void 0,t)}if(1===a.readyState)a.__rollbar_xhr.start_time_ms=u.now();else{a.__rollbar_xhr.end_time_ms=u.now();var r=null;if(e.autoInstrument.networkResponseHeaders){var n=e.autoInstrument.networkResponseHeaders;r={};try{var i,s;if(n===!0){var c=a.getAllResponseHeaders();if(c){var l,p,f=c.trim().split(/[\\r\\n]+/);for(s=0;s<f.length;s++)l=f[s].split(\": \"),i=l.shift(),p=l.join(\": \"),r[i]=p}}else for(s=0;s<n.length;s++)i=n[s],r[i]=a.getResponseHeader(i)}catch(t){}}var h=null;if(e.autoInstrument.networkResponseBody)try{h=a.responseText}catch(t){}var d=null;(h||r)&&(d={},h&&(d.body=h),r&&(d.headers=r)),d&&(a.__rollbar_xhr.response=d)}try{var m=a.status;m=1223===m?204:m,a.__rollbar_xhr.status_code=m,a.__rollbar_event.level=e.telemeter.levelFromStatus(m)}catch(t){}}}var a=this;return t(\"onload\",a),t(\"onerror\",a),t(\"onprogress\",a),\"onreadystatechange\"in a&&u.isFunction(a.onreadystatechange)?n(a,\"onreadystatechange\",function(t){return e.rollbar.wrap(t,void 0,i)}):a.onreadystatechange=i,r.apply(this,arguments)}},this.replacements,\"network\")}\"fetch\"in this._window&&n(this._window,\"fetch\",function(t){return function(r,n){for(var o=new Array(arguments.length),i=0,a=o.length;i<a;i++)o[i]=arguments[i];var s,c=o[0],l=\"GET\";u.isType(c,\"string\")?s=c:c&&(s=c.url,c.method&&(l=c.method)),o[1]&&o[1].method&&(l=o[1].method);var p={method:l,url:s,status_code:null,start_time_ms:u.now(),end_time_ms:null},f=null;return e.autoInstrument.networkRequestBody&&(o[1]&&o[1].body?f=o[1].body:o[0]&&!u.isType(o[0],\"string\")&&o[0].body&&(f=o[0].body)),e.telemeter.captureNetwork(p,\"fetch\",void 0,f),t.apply(this,o).then(function(t){p.end_time_ms=u.now(),p.status_code=t.status;var r=null;if(e.autoInstrument.networkResponseHeaders){var n=e.autoInstrument.networkResponseHeaders;r={};try{if(n===!0);else for(var o=0;o<n.length;o++){var i=n[o];r[i]=t.headers.get(i)}}catch(t){}}var a=null;return r&&(a={headers:r}),a&&(p.response=a),t})}},this.replacements,\"network\")},s.prototype.deinstrumentConsole=function(){if(\"console\"in this._window&&this._window.console.log)for(var t;this.replacements.log.length;)t=this.replacements.log.shift(),this._window.console[t[0]]=t[1]},s.prototype.instrumentConsole=function(){function t(t){var n=r[t],o=r,i=\"warn\"===t?\"warning\":t;r[t]=function(){var t=Array.prototype.slice.call(arguments),r=u.formatArgsAsString(t);e.telemeter.captureLog(r,i),n&&Function.prototype.apply.call(n,o,t)},e.replacements.log.push([t,n])}if(\"console\"in this._window&&this._window.console.log)for(var e=this,r=this._window.console,n=[\"debug\",\"info\",\"warn\",\"error\",\"log\"],o=0,i=n.length;o<i;o++)t(n[o])},s.prototype.deinstrumentDom=function(){(\"addEventListener\"in this._window||\"attachEvent\"in this._window)&&this.removeListeners(\"dom\")},s.prototype.instrumentDom=function(){if(\"addEventListener\"in this._window||\"attachEvent\"in this._window){var t=this.handleClick.bind(this),e=this.handleBlur.bind(this);this.addListener(\"dom\",this._window,\"click\",\"onclick\",t,!0),this.addListener(\"dom\",this._window,\"blur\",\"onfocusout\",e,!0)}},s.prototype.handleClick=function(t){try{var e=l.getElementFromEvent(t,this._document),r=e&&e.tagName,n=l.isDescribedElement(e,\"a\")||l.isDescribedElement(e,\"button\");r&&(n||l.isDescribedElement(e,\"input\",[\"button\",\"submit\"]))?this.captureDomEvent(\"click\",e):l.isDescribedElement(e,\"input\",[\"checkbox\",\"radio\"])&&this.captureDomEvent(\"input\",e,e.value,e.checked)}catch(t){}},s.prototype.handleBlur=function(t){try{var e=l.getElementFromEvent(t,this._document);e&&e.tagName&&(l.isDescribedElement(e,\"textarea\")?this.captureDomEvent(\"input\",e,e.value):l.isDescribedElement(e,\"select\")&&e.options&&e.options.length?this.handleSelectInputChanged(e):l.isDescribedElement(e,\"input\")&&!l.isDescribedElement(e,\"input\",[\"button\",\"submit\",\"hidden\",\"checkbox\",\"radio\"])&&this.captureDomEvent(\"input\",e,e.value))}catch(t){}},s.prototype.handleSelectInputChanged=function(t){if(t.multiple)for(var e=0;e<t.options.length;e++)t.options[e].selected&&this.captureDomEvent(\"input\",t,t.options[e].value);else t.selectedIndex>=0&&t.options[t.selectedIndex]&&this.captureDomEvent(\"input\",t,t.options[t.selectedIndex].value)},s.prototype.captureDomEvent=function(t,e,r,n){if(void 0!==r)if(this.scrubTelemetryInputs||\"password\"===l.getElementType(e))r=\"[scrubbed]\";else{var o=l.describeElement(e);this.telemetryScrubber?this.telemetryScrubber(o)&&(r=\"[scrubbed]\"):this.defaultValueScrubber(o)&&(r=\"[scrubbed]\")}var i=l.elementArrayToString(l.treeToArray(e));this.telemeter.captureDom(t,i,r,n)},s.prototype.deinstrumentNavigation=function(){var t=this._window.chrome,e=t&&t.app&&t.app.runtime,r=!e&&this._window.history&&this._window.history.pushState;r&&o(this.replacements,\"navigation\")},s.prototype.instrumentNavigation=function(){var t=this._window.chrome,e=t&&t.app&&t.app.runtime,r=!e&&this._window.history&&this._window.history.pushState;if(r){var o=this;n(this._window,\"onpopstate\",function(t){return function(){var e=o._location.href;o.handleUrlChange(o._lastHref,e),t&&t.apply(this,arguments)}},this.replacements,\"navigation\"),n(this._window.history,\"pushState\",function(t){return function(){var e=arguments.length>2?arguments[2]:void 0;return e&&o.handleUrlChange(o._lastHref,e+\"\"),t.apply(this,arguments)}},this.replacements,\"navigation\")}},s.prototype.handleUrlChange=function(t,e){var r=c.parse(this._location.href),n=c.parse(e),o=c.parse(t);this._lastHref=e,r.protocol===n.protocol&&r.host===n.host&&(e=n.path+(n.hash||\"\")),r.protocol===o.protocol&&r.host===o.host&&(t=o.path+(o.hash||\"\")),this.telemeter.captureNavigation(t,e)},s.prototype.deinstrumentConnectivity=function(){(\"addEventListener\"in this._window||\"body\"in this._document)&&(this._window.addEventListener?this.removeListeners(\"connectivity\"):o(this.replacements,\"connectivity\"))},s.prototype.instrumentConnectivity=function(){if(\"addEventListener\"in this._window||\"body\"in this._document)if(this._window.addEventListener)this.addListener(\"connectivity\",this._window,\"online\",void 0,function(){this.telemeter.captureConnectivityChange(\"online\")}.bind(this),!0),this.addListener(\"connectivity\",this._window,\"offline\",void 0,function(){this.telemeter.captureConnectivityChange(\"offline\")}.bind(this),!0);else{var t=this;n(this._document.body,\"ononline\",function(e){return function(){t.telemeter.captureConnectivityChange(\"online\"),e&&e.apply(this,arguments)}},this.replacements,\"connectivity\"),n(this._document.body,\"onoffline\",function(e){return function(){t.telemeter.captureConnectivityChange(\"offline\"),e&&e.apply(this,arguments)}},this.replacements,\"connectivity\")}},s.prototype.addListener=function(t,e,r,n,o,i){e.addEventListener?(e.addEventListener(r,o,i),this.eventRemovers[t].push(function(){e.removeEventListener(r,o,i)})):n&&(e.attachEvent(n,o),this.eventRemovers[t].push(function(){e.detachEvent(n,o)}))},s.prototype.removeListeners=function(t){for(var e;this.eventRemovers[t].length;)(e=this.eventRemovers[t].shift())()},t.exports=s},function(t,e){\"use strict\";function r(t){return(t.getAttribute(\"type\")||\"\").toLowerCase()}function n(t,e,n){if(t.tagName.toLowerCase()!==e.toLowerCase())return!1;if(!n)return!0;t=r(t);for(var o=0;o<n.length;o++)if(n[o]===t)return!0;return!1}function o(t,e){return t.target?t.target:e&&e.elementFromPoint?e.elementFromPoint(t.clientX,t.clientY):void 0}function i(t){for(var e,r=5,n=[],o=0;t&&o<r&&(e=u(t),\"html\"!==e.tagName);o++)n.unshift(e),t=t.parentNode;return n}function a(t){for(var e,r,n=80,o=\" > \",i=o.length,a=[],u=0,c=t.length-1;c>=0;c--){if(e=s(t[c]),r=u+a.length*i+e.length,c<t.length-1&&r>=n+3){a.unshift(\"...\");break}a.unshift(e),u+=e.length}return a.join(o)}function s(t){if(!t||!t.tagName)return\"\";var e=[t.tagName];t.id&&e.push(\"#\"+t.id),t.classes&&e.push(\".\"+t.classes.join(\".\"));for(var r=0;r<t.attributes.length;r++)e.push(\"[\"+t.attributes[r].key+'=\"'+t.attributes[r].value+'\"]');return e.join(\"\")}function u(t){if(!t||!t.tagName)return null;var e,r,n,o,i={};i.tagName=t.tagName.toLowerCase(),t.id&&(i.id=t.id),e=t.className,e&&\"string\"==typeof e&&(i.classes=e.split(/\\s+/));var a=[\"type\",\"name\",\"title\",\"alt\"];for(i.attributes=[],o=0;o<a.length;o++)r=a[o],n=t.getAttribute(r),n&&i.attributes.push({key:r,value:n});return i}t.exports={describeElement:u,descriptionToString:s,elementArrayToString:a,treeToArray:i,getElementFromEvent:o,isDescribedElement:n,getElementType:r}}])});\n//# sourceMappingURL=rollbar.umd.min.js.map",
    "/*!\n * URI.js - Mutating URLs\n *\n * Version: 1.18.4\n *\n * Author: Rodney Rehm\n * Web: http://medialize.github.io/URI.js/\n *\n * Licensed under\n *   MIT License http://www.opensource.org/licenses/mit-license\n *\n */\n(function (root, factory) {\n  'use strict';\n  // https://github.com/umdjs/umd/blob/master/returnExports.js\n  if (typeof module === 'object' && module.exports) {\n    // Node\n    module.exports = factory();\n  } else if (typeof define === 'function' && define.amd) {\n    // AMD. Register as an anonymous module.\n    define(['./punycode', './IPv6', './SecondLevelDomains'], factory);\n  } else {\n    // Browser globals (root is window)\n    root.URI = factory(root.punycode, root.IPv6, root.SecondLevelDomains, root);\n  }\n}(this, function (punycode, IPv6, SLD, root) {\n  'use strict';\n  /*global location, escape, unescape */\n  // FIXME: v2.0.0 renamce non-camelCase properties to uppercase\n  /*jshint camelcase: false */\n\n  // save current URI variable, if any\n  var _URI = root && root.URI;\n\n  function URI(url, base) {\n    var _urlSupplied = arguments.length >= 1;\n    var _baseSupplied = arguments.length >= 2;\n\n    // Allow instantiation without the 'new' keyword\n    if (!(this instanceof URI)) {\n      if (_urlSupplied) {\n        if (_baseSupplied) {\n          return new URI(url, base);\n        }\n\n        return new URI(url);\n      }\n\n      return new URI();\n    }\n\n    if (url === undefined) {\n      if (_urlSupplied) {\n        throw new TypeError('undefined is not a valid argument for URI');\n      }\n\n      if (typeof location !== 'undefined') {\n        url = location.href + '';\n      } else {\n        url = '';\n      }\n    }\n\n    this.href(url);\n\n    // resolve to base according to http://dvcs.w3.org/hg/url/raw-file/tip/Overview.html#constructor\n    if (base !== undefined) {\n      return this.absoluteTo(base);\n    }\n\n    return this;\n  }\n\n  URI.version = '1.18.4';\n\n  var p = URI.prototype;\n  var hasOwn = Object.prototype.hasOwnProperty;\n\n  function escapeRegEx(string) {\n    // https://github.com/medialize/URI.js/commit/85ac21783c11f8ccab06106dba9735a31a86924d#commitcomment-821963\n    return string.replace(/([.*+?^=!:${}()|[\\]\\/\\\\])/g, '\\\\$1');\n  }\n\n  function getType(value) {\n    // IE8 doesn't return [Object Undefined] but [Object Object] for undefined value\n    if (value === undefined) {\n      return 'Undefined';\n    }\n\n    return String(Object.prototype.toString.call(value)).slice(8, -1);\n  }\n\n  function isArray(obj) {\n    return getType(obj) === 'Array';\n  }\n\n  function filterArrayValues(data, value) {\n    var lookup = {};\n    var i, length;\n\n    if (getType(value) === 'RegExp') {\n      lookup = null;\n    } else if (isArray(value)) {\n      for (i = 0, length = value.length; i < length; i++) {\n        lookup[value[i]] = true;\n      }\n    } else {\n      lookup[value] = true;\n    }\n\n    for (i = 0, length = data.length; i < length; i++) {\n      /*jshint laxbreak: true */\n      var _match = lookup && lookup[data[i]] !== undefined\n        || !lookup && value.test(data[i]);\n      /*jshint laxbreak: false */\n      if (_match) {\n        data.splice(i, 1);\n        length--;\n        i--;\n      }\n    }\n\n    return data;\n  }\n\n  function arrayContains(list, value) {\n    var i, length;\n\n    // value may be string, number, array, regexp\n    if (isArray(value)) {\n      // Note: this can be optimized to O(n) (instead of current O(m * n))\n      for (i = 0, length = value.length; i < length; i++) {\n        if (!arrayContains(list, value[i])) {\n          return false;\n        }\n      }\n\n      return true;\n    }\n\n    var _type = getType(value);\n    for (i = 0, length = list.length; i < length; i++) {\n      if (_type === 'RegExp') {\n        if (typeof list[i] === 'string' && list[i].match(value)) {\n          return true;\n        }\n      } else if (list[i] === value) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  function arraysEqual(one, two) {\n    if (!isArray(one) || !isArray(two)) {\n      return false;\n    }\n\n    // arrays can't be equal if they have different amount of content\n    if (one.length !== two.length) {\n      return false;\n    }\n\n    one.sort();\n    two.sort();\n\n    for (var i = 0, l = one.length; i < l; i++) {\n      if (one[i] !== two[i]) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  function trimSlashes(text) {\n    var trim_expression = /^\\/+|\\/+$/g;\n    return text.replace(trim_expression, '');\n  }\n\n  URI._parts = function() {\n    return {\n      protocol: null,\n      username: null,\n      password: null,\n      hostname: null,\n      urn: null,\n      port: null,\n      path: null,\n      query: null,\n      fragment: null,\n      // state\n      duplicateQueryParameters: URI.duplicateQueryParameters,\n      escapeQuerySpace: URI.escapeQuerySpace\n    };\n  };\n  // state: allow duplicate query parameters (a=1&a=1)\n  URI.duplicateQueryParameters = false;\n  // state: replaces + with %20 (space in query strings)\n  URI.escapeQuerySpace = true;\n  // static properties\n  URI.protocol_expression = /^[a-z][a-z0-9.+-]*$/i;\n  URI.idn_expression = /[^a-z0-9\\.-]/i;\n  URI.punycode_expression = /(xn--)/i;\n  // well, 333.444.555.666 matches, but it sure ain't no IPv4 - do we care?\n  URI.ip4_expression = /^\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}$/;\n  // credits to Rich Brown\n  // source: http://forums.intermapper.com/viewtopic.php?p=1096#1096\n  // specification: http://www.ietf.org/rfc/rfc4291.txt\n  URI.ip6_expression = /^\\s*((([0-9A-Fa-f]{1,4}:){7}([0-9A-Fa-f]{1,4}|:))|(([0-9A-Fa-f]{1,4}:){6}(:[0-9A-Fa-f]{1,4}|((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){5}(((:[0-9A-Fa-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){4}(((:[0-9A-Fa-f]{1,4}){1,3})|((:[0-9A-Fa-f]{1,4})?:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){3}(((:[0-9A-Fa-f]{1,4}){1,4})|((:[0-9A-Fa-f]{1,4}){0,2}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){2}(((:[0-9A-Fa-f]{1,4}){1,5})|((:[0-9A-Fa-f]{1,4}){0,3}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){1}(((:[0-9A-Fa-f]{1,4}){1,6})|((:[0-9A-Fa-f]{1,4}){0,4}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(:(((:[0-9A-Fa-f]{1,4}){1,7})|((:[0-9A-Fa-f]{1,4}){0,5}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:)))(%.+)?\\s*$/;\n  // expression used is \"gruber revised\" (@gruber v2) determined to be the\n  // best solution in a regex-golf we did a couple of ages ago at\n  // * http://mathiasbynens.be/demo/url-regex\n  // * http://rodneyrehm.de/t/url-regex.html\n  URI.find_uri_expression = /\\b((?:[a-z][\\w-]+:(?:\\/{1,3}|[a-z0-9%])|www\\d{0,3}[.]|[a-z0-9.\\-]+[.][a-z]{2,4}\\/)(?:[^\\s()<>]+|\\(([^\\s()<>]+|(\\([^\\s()<>]+\\)))*\\))+(?:\\(([^\\s()<>]+|(\\([^\\s()<>]+\\)))*\\)|[^\\s`!()\\[\\]{};:'\".,<>?]))/ig;\n  URI.findUri = {\n    // valid \"scheme://\" or \"www.\"\n    start: /\\b(?:([a-z][a-z0-9.+-]*:\\/\\/)|www\\.)/gi,\n    // everything up to the next whitespace\n    end: /[\\s\\r\\n]|$/,\n    // trim trailing punctuation captured by end RegExp\n    trim: /[`!()\\[\\]{};:'\".,<>?]+$/,\n    // balanced parens inclusion (), [], {}, <>\n    parens: /(\\([^\\)]*\\)|\\[[^\\]]*\\]|\\{[^}]*\\}|<[^>]*>)/g,\n  };\n  // http://www.iana.org/assignments/uri-schemes.html\n  // http://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#Well-known_ports\n  URI.defaultPorts = {\n    http: '80',\n    https: '443',\n    ftp: '21',\n    gopher: '70',\n    ws: '80',\n    wss: '443'\n  };\n  // allowed hostname characters according to RFC 3986\n  // ALPHA DIGIT \"-\" \".\" \"_\" \"~\" \"!\" \"$\" \"&\" \"'\" \"(\" \")\" \"*\" \"+\" \",\" \";\" \"=\" %encoded\n  // I've never seen a (non-IDN) hostname other than: ALPHA DIGIT . -\n  URI.invalid_hostname_characters = /[^a-zA-Z0-9\\.-]/;\n  // map DOM Elements to their URI attribute\n  URI.domAttributes = {\n    'a': 'href',\n    'blockquote': 'cite',\n    'link': 'href',\n    'base': 'href',\n    'script': 'src',\n    'form': 'action',\n    'img': 'src',\n    'area': 'href',\n    'iframe': 'src',\n    'embed': 'src',\n    'source': 'src',\n    'track': 'src',\n    'input': 'src', // but only if type=\"image\"\n    'audio': 'src',\n    'video': 'src'\n  };\n  URI.getDomAttribute = function(node) {\n    if (!node || !node.nodeName) {\n      return undefined;\n    }\n\n    var nodeName = node.nodeName.toLowerCase();\n    // <input> should only expose src for type=\"image\"\n    if (nodeName === 'input' && node.type !== 'image') {\n      return undefined;\n    }\n\n    return URI.domAttributes[nodeName];\n  };\n\n  function escapeForDumbFirefox36(value) {\n    // https://github.com/medialize/URI.js/issues/91\n    return escape(value);\n  }\n\n  // encoding / decoding according to RFC3986\n  function strictEncodeURIComponent(string) {\n    // see https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/encodeURIComponent\n    return encodeURIComponent(string)\n      .replace(/[!'()*]/g, escapeForDumbFirefox36)\n      .replace(/\\*/g, '%2A');\n  }\n  URI.encode = strictEncodeURIComponent;\n  URI.decode = decodeURIComponent;\n  URI.iso8859 = function() {\n    URI.encode = escape;\n    URI.decode = unescape;\n  };\n  URI.unicode = function() {\n    URI.encode = strictEncodeURIComponent;\n    URI.decode = decodeURIComponent;\n  };\n  URI.characters = {\n    pathname: {\n      encode: {\n        // RFC3986 2.1: For consistency, URI producers and normalizers should\n        // use uppercase hexadecimal digits for all percent-encodings.\n        expression: /%(24|26|2B|2C|3B|3D|3A|40)/ig,\n        map: {\n          // -._~!'()*\n          '%24': '$',\n          '%26': '&',\n          '%2B': '+',\n          '%2C': ',',\n          '%3B': ';',\n          '%3D': '=',\n          '%3A': ':',\n          '%40': '@'\n        }\n      },\n      decode: {\n        expression: /[\\/\\?#]/g,\n        map: {\n          '/': '%2F',\n          '?': '%3F',\n          '#': '%23'\n        }\n      }\n    },\n    reserved: {\n      encode: {\n        // RFC3986 2.1: For consistency, URI producers and normalizers should\n        // use uppercase hexadecimal digits for all percent-encodings.\n        expression: /%(21|23|24|26|27|28|29|2A|2B|2C|2F|3A|3B|3D|3F|40|5B|5D)/ig,\n        map: {\n          // gen-delims\n          '%3A': ':',\n          '%2F': '/',\n          '%3F': '?',\n          '%23': '#',\n          '%5B': '[',\n          '%5D': ']',\n          '%40': '@',\n          // sub-delims\n          '%21': '!',\n          '%24': '$',\n          '%26': '&',\n          '%27': '\\'',\n          '%28': '(',\n          '%29': ')',\n          '%2A': '*',\n          '%2B': '+',\n          '%2C': ',',\n          '%3B': ';',\n          '%3D': '='\n        }\n      }\n    },\n    urnpath: {\n      // The characters under `encode` are the characters called out by RFC 2141 as being acceptable\n      // for usage in a URN. RFC2141 also calls out \"-\", \".\", and \"_\" as acceptable characters, but\n      // these aren't encoded by encodeURIComponent, so we don't have to call them out here. Also\n      // note that the colon character is not featured in the encoding map; this is because URI.js\n      // gives the colons in URNs semantic meaning as the delimiters of path segements, and so it\n      // should not appear unencoded in a segment itself.\n      // See also the note above about RFC3986 and capitalalized hex digits.\n      encode: {\n        expression: /%(21|24|27|28|29|2A|2B|2C|3B|3D|40)/ig,\n        map: {\n          '%21': '!',\n          '%24': '$',\n          '%27': '\\'',\n          '%28': '(',\n          '%29': ')',\n          '%2A': '*',\n          '%2B': '+',\n          '%2C': ',',\n          '%3B': ';',\n          '%3D': '=',\n          '%40': '@'\n        }\n      },\n      // These characters are the characters called out by RFC2141 as \"reserved\" characters that\n      // should never appear in a URN, plus the colon character (see note above).\n      decode: {\n        expression: /[\\/\\?#:]/g,\n        map: {\n          '/': '%2F',\n          '?': '%3F',\n          '#': '%23',\n          ':': '%3A'\n        }\n      }\n    }\n  };\n  URI.encodeQuery = function(string, escapeQuerySpace) {\n    var escaped = URI.encode(string + '');\n    if (escapeQuerySpace === undefined) {\n      escapeQuerySpace = URI.escapeQuerySpace;\n    }\n\n    return escapeQuerySpace ? escaped.replace(/%20/g, '+') : escaped;\n  };\n  URI.decodeQuery = function(string, escapeQuerySpace) {\n    string += '';\n    if (escapeQuerySpace === undefined) {\n      escapeQuerySpace = URI.escapeQuerySpace;\n    }\n\n    try {\n      return URI.decode(escapeQuerySpace ? string.replace(/\\+/g, '%20') : string);\n    } catch(e) {\n      // we're not going to mess with weird encodings,\n      // give up and return the undecoded original string\n      // see https://github.com/medialize/URI.js/issues/87\n      // see https://github.com/medialize/URI.js/issues/92\n      return string;\n    }\n  };\n  // generate encode/decode path functions\n  var _parts = {'encode':'encode', 'decode':'decode'};\n  var _part;\n  var generateAccessor = function(_group, _part) {\n    return function(string) {\n      try {\n        return URI[_part](string + '').replace(URI.characters[_group][_part].expression, function(c) {\n          return URI.characters[_group][_part].map[c];\n        });\n      } catch (e) {\n        // we're not going to mess with weird encodings,\n        // give up and return the undecoded original string\n        // see https://github.com/medialize/URI.js/issues/87\n        // see https://github.com/medialize/URI.js/issues/92\n        return string;\n      }\n    };\n  };\n\n  for (_part in _parts) {\n    URI[_part + 'PathSegment'] = generateAccessor('pathname', _parts[_part]);\n    URI[_part + 'UrnPathSegment'] = generateAccessor('urnpath', _parts[_part]);\n  }\n\n  var generateSegmentedPathFunction = function(_sep, _codingFuncName, _innerCodingFuncName) {\n    return function(string) {\n      // Why pass in names of functions, rather than the function objects themselves? The\n      // definitions of some functions (but in particular, URI.decode) will occasionally change due\n      // to URI.js having ISO8859 and Unicode modes. Passing in the name and getting it will ensure\n      // that the functions we use here are \"fresh\".\n      var actualCodingFunc;\n      if (!_innerCodingFuncName) {\n        actualCodingFunc = URI[_codingFuncName];\n      } else {\n        actualCodingFunc = function(string) {\n          return URI[_codingFuncName](URI[_innerCodingFuncName](string));\n        };\n      }\n\n      var segments = (string + '').split(_sep);\n\n      for (var i = 0, length = segments.length; i < length; i++) {\n        segments[i] = actualCodingFunc(segments[i]);\n      }\n\n      return segments.join(_sep);\n    };\n  };\n\n  // This takes place outside the above loop because we don't want, e.g., encodeUrnPath functions.\n  URI.decodePath = generateSegmentedPathFunction('/', 'decodePathSegment');\n  URI.decodeUrnPath = generateSegmentedPathFunction(':', 'decodeUrnPathSegment');\n  URI.recodePath = generateSegmentedPathFunction('/', 'encodePathSegment', 'decode');\n  URI.recodeUrnPath = generateSegmentedPathFunction(':', 'encodeUrnPathSegment', 'decode');\n\n  URI.encodeReserved = generateAccessor('reserved', 'encode');\n\n  URI.parse = function(string, parts) {\n    var pos;\n    if (!parts) {\n      parts = {};\n    }\n    // [protocol\"://\"[username[\":\"password]\"@\"]hostname[\":\"port]\"/\"?][path][\"?\"querystring][\"#\"fragment]\n\n    // extract fragment\n    pos = string.indexOf('#');\n    if (pos > -1) {\n      // escaping?\n      parts.fragment = string.substring(pos + 1) || null;\n      string = string.substring(0, pos);\n    }\n\n    // extract query\n    pos = string.indexOf('?');\n    if (pos > -1) {\n      // escaping?\n      parts.query = string.substring(pos + 1) || null;\n      string = string.substring(0, pos);\n    }\n\n    // extract protocol\n    if (string.substring(0, 2) === '//') {\n      // relative-scheme\n      parts.protocol = null;\n      string = string.substring(2);\n      // extract \"user:pass@host:port\"\n      string = URI.parseAuthority(string, parts);\n    } else {\n      pos = string.indexOf(':');\n      if (pos > -1) {\n        parts.protocol = string.substring(0, pos) || null;\n        if (parts.protocol && !parts.protocol.match(URI.protocol_expression)) {\n          // : may be within the path\n          parts.protocol = undefined;\n        } else if (string.substring(pos + 1, pos + 3) === '//') {\n          string = string.substring(pos + 3);\n\n          // extract \"user:pass@host:port\"\n          string = URI.parseAuthority(string, parts);\n        } else {\n          string = string.substring(pos + 1);\n          parts.urn = true;\n        }\n      }\n    }\n\n    // what's left must be the path\n    parts.path = string;\n\n    // and we're done\n    return parts;\n  };\n  URI.parseHost = function(string, parts) {\n    // Copy chrome, IE, opera backslash-handling behavior.\n    // Back slashes before the query string get converted to forward slashes\n    // See: https://github.com/joyent/node/blob/386fd24f49b0e9d1a8a076592a404168faeecc34/lib/url.js#L115-L124\n    // See: https://code.google.com/p/chromium/issues/detail?id=25916\n    // https://github.com/medialize/URI.js/pull/233\n    string = string.replace(/\\\\/g, '/');\n\n    // extract host:port\n    var pos = string.indexOf('/');\n    var bracketPos;\n    var t;\n\n    if (pos === -1) {\n      pos = string.length;\n    }\n\n    if (string.charAt(0) === '[') {\n      // IPv6 host - http://tools.ietf.org/html/draft-ietf-6man-text-addr-representation-04#section-6\n      // I claim most client software breaks on IPv6 anyways. To simplify things, URI only accepts\n      // IPv6+port in the format [2001:db8::1]:80 (for the time being)\n      bracketPos = string.indexOf(']');\n      parts.hostname = string.substring(1, bracketPos) || null;\n      parts.port = string.substring(bracketPos + 2, pos) || null;\n      if (parts.port === '/') {\n        parts.port = null;\n      }\n    } else {\n      var firstColon = string.indexOf(':');\n      var firstSlash = string.indexOf('/');\n      var nextColon = string.indexOf(':', firstColon + 1);\n      if (nextColon !== -1 && (firstSlash === -1 || nextColon < firstSlash)) {\n        // IPv6 host contains multiple colons - but no port\n        // this notation is actually not allowed by RFC 3986, but we're a liberal parser\n        parts.hostname = string.substring(0, pos) || null;\n        parts.port = null;\n      } else {\n        t = string.substring(0, pos).split(':');\n        parts.hostname = t[0] || null;\n        parts.port = t[1] || null;\n      }\n    }\n\n    if (parts.hostname && string.substring(pos).charAt(0) !== '/') {\n      pos++;\n      string = '/' + string;\n    }\n\n    return string.substring(pos) || '/';\n  };\n  URI.parseAuthority = function(string, parts) {\n    string = URI.parseUserinfo(string, parts);\n    return URI.parseHost(string, parts);\n  };\n  URI.parseUserinfo = function(string, parts) {\n    // extract username:password\n    var firstSlash = string.indexOf('/');\n    var pos = string.lastIndexOf('@', firstSlash > -1 ? firstSlash : string.length - 1);\n    var t;\n\n    // authority@ must come before /path\n    if (pos > -1 && (firstSlash === -1 || pos < firstSlash)) {\n      t = string.substring(0, pos).split(':');\n      parts.username = t[0] ? URI.decode(t[0]) : null;\n      t.shift();\n      parts.password = t[0] ? URI.decode(t.join(':')) : null;\n      string = string.substring(pos + 1);\n    } else {\n      parts.username = null;\n      parts.password = null;\n    }\n\n    return string;\n  };\n  URI.parseQuery = function(string, escapeQuerySpace) {\n    if (!string) {\n      return {};\n    }\n\n    // throw out the funky business - \"?\"[name\"=\"value\"&\"]+\n    string = string.replace(/&+/g, '&').replace(/^\\?*&*|&+$/g, '');\n\n    if (!string) {\n      return {};\n    }\n\n    var items = {};\n    var splits = string.split('&');\n    var length = splits.length;\n    var v, name, value;\n\n    for (var i = 0; i < length; i++) {\n      v = splits[i].split('=');\n      name = URI.decodeQuery(v.shift(), escapeQuerySpace);\n      // no \"=\" is null according to http://dvcs.w3.org/hg/url/raw-file/tip/Overview.html#collect-url-parameters\n      value = v.length ? URI.decodeQuery(v.join('='), escapeQuerySpace) : null;\n\n      if (hasOwn.call(items, name)) {\n        if (typeof items[name] === 'string' || items[name] === null) {\n          items[name] = [items[name]];\n        }\n\n        items[name].push(value);\n      } else {\n        items[name] = value;\n      }\n    }\n\n    return items;\n  };\n\n  URI.build = function(parts) {\n    var t = '';\n\n    if (parts.protocol) {\n      t += parts.protocol + ':';\n    }\n\n    if (!parts.urn && (t || parts.hostname)) {\n      t += '//';\n    }\n\n    t += (URI.buildAuthority(parts) || '');\n\n    if (typeof parts.path === 'string') {\n      if (parts.path.charAt(0) !== '/' && typeof parts.hostname === 'string') {\n        t += '/';\n      }\n\n      t += parts.path;\n    }\n\n    if (typeof parts.query === 'string' && parts.query) {\n      t += '?' + parts.query;\n    }\n\n    if (typeof parts.fragment === 'string' && parts.fragment) {\n      t += '#' + parts.fragment;\n    }\n    return t;\n  };\n  URI.buildHost = function(parts) {\n    var t = '';\n\n    if (!parts.hostname) {\n      return '';\n    } else if (URI.ip6_expression.test(parts.hostname)) {\n      t += '[' + parts.hostname + ']';\n    } else {\n      t += parts.hostname;\n    }\n\n    if (parts.port) {\n      t += ':' + parts.port;\n    }\n\n    return t;\n  };\n  URI.buildAuthority = function(parts) {\n    return URI.buildUserinfo(parts) + URI.buildHost(parts);\n  };\n  URI.buildUserinfo = function(parts) {\n    var t = '';\n\n    if (parts.username) {\n      t += URI.encode(parts.username);\n    }\n\n    if (parts.password) {\n      t += ':' + URI.encode(parts.password);\n    }\n\n    if (t) {\n      t += '@';\n    }\n\n    return t;\n  };\n  URI.buildQuery = function(data, duplicateQueryParameters, escapeQuerySpace) {\n    // according to http://tools.ietf.org/html/rfc3986 or http://labs.apache.org/webarch/uri/rfc/rfc3986.html\n    // being -._~!$&'()*+,;=:@/? %HEX and alnum are allowed\n    // the RFC explicitly states ?/foo being a valid use case, no mention of parameter syntax!\n    // URI.js treats the query string as being application/x-www-form-urlencoded\n    // see http://www.w3.org/TR/REC-html40/interact/forms.html#form-content-type\n\n    var t = '';\n    var unique, key, i, length;\n    for (key in data) {\n      if (hasOwn.call(data, key) && key) {\n        if (isArray(data[key])) {\n          unique = {};\n          for (i = 0, length = data[key].length; i < length; i++) {\n            if (data[key][i] !== undefined && unique[data[key][i] + ''] === undefined) {\n              t += '&' + URI.buildQueryParameter(key, data[key][i], escapeQuerySpace);\n              if (duplicateQueryParameters !== true) {\n                unique[data[key][i] + ''] = true;\n              }\n            }\n          }\n        } else if (data[key] !== undefined) {\n          t += '&' + URI.buildQueryParameter(key, data[key], escapeQuerySpace);\n        }\n      }\n    }\n\n    return t.substring(1);\n  };\n  URI.buildQueryParameter = function(name, value, escapeQuerySpace) {\n    // http://www.w3.org/TR/REC-html40/interact/forms.html#form-content-type -- application/x-www-form-urlencoded\n    // don't append \"=\" for null values, according to http://dvcs.w3.org/hg/url/raw-file/tip/Overview.html#url-parameter-serialization\n    return URI.encodeQuery(name, escapeQuerySpace) + (value !== null ? '=' + URI.encodeQuery(value, escapeQuerySpace) : '');\n  };\n\n  URI.addQuery = function(data, name, value) {\n    if (typeof name === 'object') {\n      for (var key in name) {\n        if (hasOwn.call(name, key)) {\n          URI.addQuery(data, key, name[key]);\n        }\n      }\n    } else if (typeof name === 'string') {\n      if (data[name] === undefined) {\n        data[name] = value;\n        return;\n      } else if (typeof data[name] === 'string') {\n        data[name] = [data[name]];\n      }\n\n      if (!isArray(value)) {\n        value = [value];\n      }\n\n      data[name] = (data[name] || []).concat(value);\n    } else {\n      throw new TypeError('URI.addQuery() accepts an object, string as the name parameter');\n    }\n  };\n  URI.removeQuery = function(data, name, value) {\n    var i, length, key;\n\n    if (isArray(name)) {\n      for (i = 0, length = name.length; i < length; i++) {\n        data[name[i]] = undefined;\n      }\n    } else if (getType(name) === 'RegExp') {\n      for (key in data) {\n        if (name.test(key)) {\n          data[key] = undefined;\n        }\n      }\n    } else if (typeof name === 'object') {\n      for (key in name) {\n        if (hasOwn.call(name, key)) {\n          URI.removeQuery(data, key, name[key]);\n        }\n      }\n    } else if (typeof name === 'string') {\n      if (value !== undefined) {\n        if (getType(value) === 'RegExp') {\n          if (!isArray(data[name]) && value.test(data[name])) {\n            data[name] = undefined;\n          } else {\n            data[name] = filterArrayValues(data[name], value);\n          }\n        } else if (data[name] === String(value) && (!isArray(value) || value.length === 1)) {\n          data[name] = undefined;\n        } else if (isArray(data[name])) {\n          data[name] = filterArrayValues(data[name], value);\n        }\n      } else {\n        data[name] = undefined;\n      }\n    } else {\n      throw new TypeError('URI.removeQuery() accepts an object, string, RegExp as the first parameter');\n    }\n  };\n  URI.hasQuery = function(data, name, value, withinArray) {\n    switch (getType(name)) {\n      case 'String':\n        // Nothing to do here\n        break;\n\n      case 'RegExp':\n        for (var key in data) {\n          if (hasOwn.call(data, key)) {\n            if (name.test(key) && (value === undefined || URI.hasQuery(data, key, value))) {\n              return true;\n            }\n          }\n        }\n\n        return false;\n\n      case 'Object':\n        for (var _key in name) {\n          if (hasOwn.call(name, _key)) {\n            if (!URI.hasQuery(data, _key, name[_key])) {\n              return false;\n            }\n          }\n        }\n\n        return true;\n\n      default:\n        throw new TypeError('URI.hasQuery() accepts a string, regular expression or object as the name parameter');\n    }\n\n    switch (getType(value)) {\n      case 'Undefined':\n        // true if exists (but may be empty)\n        return name in data; // data[name] !== undefined;\n\n      case 'Boolean':\n        // true if exists and non-empty\n        var _booly = Boolean(isArray(data[name]) ? data[name].length : data[name]);\n        return value === _booly;\n\n      case 'Function':\n        // allow complex comparison\n        return !!value(data[name], name, data);\n\n      case 'Array':\n        if (!isArray(data[name])) {\n          return false;\n        }\n\n        var op = withinArray ? arrayContains : arraysEqual;\n        return op(data[name], value);\n\n      case 'RegExp':\n        if (!isArray(data[name])) {\n          return Boolean(data[name] && data[name].match(value));\n        }\n\n        if (!withinArray) {\n          return false;\n        }\n\n        return arrayContains(data[name], value);\n\n      case 'Number':\n        value = String(value);\n        /* falls through */\n      case 'String':\n        if (!isArray(data[name])) {\n          return data[name] === value;\n        }\n\n        if (!withinArray) {\n          return false;\n        }\n\n        return arrayContains(data[name], value);\n\n      default:\n        throw new TypeError('URI.hasQuery() accepts undefined, boolean, string, number, RegExp, Function as the value parameter');\n    }\n  };\n\n\n  URI.joinPaths = function() {\n    var input = [];\n    var segments = [];\n    var nonEmptySegments = 0;\n\n    for (var i = 0; i < arguments.length; i++) {\n      var url = new URI(arguments[i]);\n      input.push(url);\n      var _segments = url.segment();\n      for (var s = 0; s < _segments.length; s++) {\n        if (typeof _segments[s] === 'string') {\n          segments.push(_segments[s]);\n        }\n\n        if (_segments[s]) {\n          nonEmptySegments++;\n        }\n      }\n    }\n\n    if (!segments.length || !nonEmptySegments) {\n      return new URI('');\n    }\n\n    var uri = new URI('').segment(segments);\n\n    if (input[0].path() === '' || input[0].path().slice(0, 1) === '/') {\n      uri.path('/' + uri.path());\n    }\n\n    return uri.normalize();\n  };\n\n  URI.commonPath = function(one, two) {\n    var length = Math.min(one.length, two.length);\n    var pos;\n\n    // find first non-matching character\n    for (pos = 0; pos < length; pos++) {\n      if (one.charAt(pos) !== two.charAt(pos)) {\n        pos--;\n        break;\n      }\n    }\n\n    if (pos < 1) {\n      return one.charAt(0) === two.charAt(0) && one.charAt(0) === '/' ? '/' : '';\n    }\n\n    // revert to last /\n    if (one.charAt(pos) !== '/' || two.charAt(pos) !== '/') {\n      pos = one.substring(0, pos).lastIndexOf('/');\n    }\n\n    return one.substring(0, pos + 1);\n  };\n\n  URI.withinString = function(string, callback, options) {\n    options || (options = {});\n    var _start = options.start || URI.findUri.start;\n    var _end = options.end || URI.findUri.end;\n    var _trim = options.trim || URI.findUri.trim;\n    var _parens = options.parens || URI.findUri.parens;\n    var _attributeOpen = /[a-z0-9-]=[\"']?$/i;\n\n    _start.lastIndex = 0;\n    while (true) {\n      var match = _start.exec(string);\n      if (!match) {\n        break;\n      }\n\n      var start = match.index;\n      if (options.ignoreHtml) {\n        // attribut(e=[\"']?$)\n        var attributeOpen = string.slice(Math.max(start - 3, 0), start);\n        if (attributeOpen && _attributeOpen.test(attributeOpen)) {\n          continue;\n        }\n      }\n\n      var end = start + string.slice(start).search(_end);\n      var slice = string.slice(start, end);\n      // make sure we include well balanced parens\n      var parensEnd = -1;\n      while (true) {\n        var parensMatch = _parens.exec(slice);\n        if (!parensMatch) {\n          break;\n        }\n\n        var parensMatchEnd = parensMatch.index + parensMatch[0].length;\n        parensEnd = Math.max(parensEnd, parensMatchEnd);\n      }\n\n      if (parensEnd > -1) {\n        slice = slice.slice(0, parensEnd) + slice.slice(parensEnd + 1).replace(_trim, '');\n      } else {\n        slice = slice.replace(_trim, '');\n      }\n\n      if (options.ignore && options.ignore.test(slice)) {\n        continue;\n      }\n\n      end = start + slice.length;\n      var result = callback(slice, start, end, string);\n      if (result === undefined) {\n        _start.lastIndex = end;\n        continue;\n      }\n\n      result = String(result);\n      string = string.slice(0, start) + result + string.slice(end);\n      _start.lastIndex = start + result.length;\n    }\n\n    _start.lastIndex = 0;\n    return string;\n  };\n\n  URI.ensureValidHostname = function(v) {\n    // Theoretically URIs allow percent-encoding in Hostnames (according to RFC 3986)\n    // they are not part of DNS and therefore ignored by URI.js\n\n    if (v.match(URI.invalid_hostname_characters)) {\n      // test punycode\n      if (!punycode) {\n        throw new TypeError('Hostname \"' + v + '\" contains characters other than [A-Z0-9.-] and Punycode.js is not available');\n      }\n\n      if (punycode.toASCII(v).match(URI.invalid_hostname_characters)) {\n        throw new TypeError('Hostname \"' + v + '\" contains characters other than [A-Z0-9.-]');\n      }\n    }\n  };\n\n  // noConflict\n  URI.noConflict = function(removeAll) {\n    if (removeAll) {\n      var unconflicted = {\n        URI: this.noConflict()\n      };\n\n      if (root.URITemplate && typeof root.URITemplate.noConflict === 'function') {\n        unconflicted.URITemplate = root.URITemplate.noConflict();\n      }\n\n      if (root.IPv6 && typeof root.IPv6.noConflict === 'function') {\n        unconflicted.IPv6 = root.IPv6.noConflict();\n      }\n\n      if (root.SecondLevelDomains && typeof root.SecondLevelDomains.noConflict === 'function') {\n        unconflicted.SecondLevelDomains = root.SecondLevelDomains.noConflict();\n      }\n\n      return unconflicted;\n    } else if (root.URI === this) {\n      root.URI = _URI;\n    }\n\n    return this;\n  };\n\n  p.build = function(deferBuild) {\n    if (deferBuild === true) {\n      this._deferred_build = true;\n    } else if (deferBuild === undefined || this._deferred_build) {\n      this._string = URI.build(this._parts);\n      this._deferred_build = false;\n    }\n\n    return this;\n  };\n\n  p.clone = function() {\n    return new URI(this);\n  };\n\n  p.valueOf = p.toString = function() {\n    return this.build(false)._string;\n  };\n\n\n  function generateSimpleAccessor(_part){\n    return function(v, build) {\n      if (v === undefined) {\n        return this._parts[_part] || '';\n      } else {\n        this._parts[_part] = v || null;\n        this.build(!build);\n        return this;\n      }\n    };\n  }\n\n  function generatePrefixAccessor(_part, _key){\n    return function(v, build) {\n      if (v === undefined) {\n        return this._parts[_part] || '';\n      } else {\n        if (v !== null) {\n          v = v + '';\n          if (v.charAt(0) === _key) {\n            v = v.substring(1);\n          }\n        }\n\n        this._parts[_part] = v;\n        this.build(!build);\n        return this;\n      }\n    };\n  }\n\n  p.protocol = generateSimpleAccessor('protocol');\n  p.username = generateSimpleAccessor('username');\n  p.password = generateSimpleAccessor('password');\n  p.hostname = generateSimpleAccessor('hostname');\n  p.port = generateSimpleAccessor('port');\n  p.query = generatePrefixAccessor('query', '?');\n  p.fragment = generatePrefixAccessor('fragment', '#');\n\n  p.search = function(v, build) {\n    var t = this.query(v, build);\n    return typeof t === 'string' && t.length ? ('?' + t) : t;\n  };\n  p.hash = function(v, build) {\n    var t = this.fragment(v, build);\n    return typeof t === 'string' && t.length ? ('#' + t) : t;\n  };\n\n  p.pathname = function(v, build) {\n    if (v === undefined || v === true) {\n      var res = this._parts.path || (this._parts.hostname ? '/' : '');\n      return v ? (this._parts.urn ? URI.decodeUrnPath : URI.decodePath)(res) : res;\n    } else {\n      if (this._parts.urn) {\n        this._parts.path = v ? URI.recodeUrnPath(v) : '';\n      } else {\n        this._parts.path = v ? URI.recodePath(v) : '/';\n      }\n      this.build(!build);\n      return this;\n    }\n  };\n  p.path = p.pathname;\n  p.href = function(href, build) {\n    var key;\n\n    if (href === undefined) {\n      return this.toString();\n    }\n\n    this._string = '';\n    this._parts = URI._parts();\n\n    var _URI = href instanceof URI;\n    var _object = typeof href === 'object' && (href.hostname || href.path || href.pathname);\n    if (href.nodeName) {\n      var attribute = URI.getDomAttribute(href);\n      href = href[attribute] || '';\n      _object = false;\n    }\n\n    // window.location is reported to be an object, but it's not the sort\n    // of object we're looking for:\n    // * location.protocol ends with a colon\n    // * location.query != object.search\n    // * location.hash != object.fragment\n    // simply serializing the unknown object should do the trick\n    // (for location, not for everything...)\n    if (!_URI && _object && href.pathname !== undefined) {\n      href = href.toString();\n    }\n\n    if (typeof href === 'string' || href instanceof String) {\n      this._parts = URI.parse(String(href), this._parts);\n    } else if (_URI || _object) {\n      var src = _URI ? href._parts : href;\n      for (key in src) {\n        if (hasOwn.call(this._parts, key)) {\n          this._parts[key] = src[key];\n        }\n      }\n    } else {\n      throw new TypeError('invalid input');\n    }\n\n    this.build(!build);\n    return this;\n  };\n\n  // identification accessors\n  p.is = function(what) {\n    var ip = false;\n    var ip4 = false;\n    var ip6 = false;\n    var name = false;\n    var sld = false;\n    var idn = false;\n    var punycode = false;\n    var relative = !this._parts.urn;\n\n    if (this._parts.hostname) {\n      relative = false;\n      ip4 = URI.ip4_expression.test(this._parts.hostname);\n      ip6 = URI.ip6_expression.test(this._parts.hostname);\n      ip = ip4 || ip6;\n      name = !ip;\n      sld = name && SLD && SLD.has(this._parts.hostname);\n      idn = name && URI.idn_expression.test(this._parts.hostname);\n      punycode = name && URI.punycode_expression.test(this._parts.hostname);\n    }\n\n    switch (what.toLowerCase()) {\n      case 'relative':\n        return relative;\n\n      case 'absolute':\n        return !relative;\n\n      // hostname identification\n      case 'domain':\n      case 'name':\n        return name;\n\n      case 'sld':\n        return sld;\n\n      case 'ip':\n        return ip;\n\n      case 'ip4':\n      case 'ipv4':\n      case 'inet4':\n        return ip4;\n\n      case 'ip6':\n      case 'ipv6':\n      case 'inet6':\n        return ip6;\n\n      case 'idn':\n        return idn;\n\n      case 'url':\n        return !this._parts.urn;\n\n      case 'urn':\n        return !!this._parts.urn;\n\n      case 'punycode':\n        return punycode;\n    }\n\n    return null;\n  };\n\n  // component specific input validation\n  var _protocol = p.protocol;\n  var _port = p.port;\n  var _hostname = p.hostname;\n\n  p.protocol = function(v, build) {\n    if (v !== undefined) {\n      if (v) {\n        // accept trailing ://\n        v = v.replace(/:(\\/\\/)?$/, '');\n\n        if (!v.match(URI.protocol_expression)) {\n          throw new TypeError('Protocol \"' + v + '\" contains characters other than [A-Z0-9.+-] or doesn\\'t start with [A-Z]');\n        }\n      }\n    }\n    return _protocol.call(this, v, build);\n  };\n  p.scheme = p.protocol;\n  p.port = function(v, build) {\n    if (this._parts.urn) {\n      return v === undefined ? '' : this;\n    }\n\n    if (v !== undefined) {\n      if (v === 0) {\n        v = null;\n      }\n\n      if (v) {\n        v += '';\n        if (v.charAt(0) === ':') {\n          v = v.substring(1);\n        }\n\n        if (v.match(/[^0-9]/)) {\n          throw new TypeError('Port \"' + v + '\" contains characters other than [0-9]');\n        }\n      }\n    }\n    return _port.call(this, v, build);\n  };\n  p.hostname = function(v, build) {\n    if (this._parts.urn) {\n      return v === undefined ? '' : this;\n    }\n\n    if (v !== undefined) {\n      var x = {};\n      var res = URI.parseHost(v, x);\n      if (res !== '/') {\n        throw new TypeError('Hostname \"' + v + '\" contains characters other than [A-Z0-9.-]');\n      }\n\n      v = x.hostname;\n    }\n    return _hostname.call(this, v, build);\n  };\n\n  // compound accessors\n  p.origin = function(v, build) {\n    if (this._parts.urn) {\n      return v === undefined ? '' : this;\n    }\n\n    if (v === undefined) {\n      var protocol = this.protocol();\n      var authority = this.authority();\n      if (!authority) {\n        return '';\n      }\n\n      return (protocol ? protocol + '://' : '') + this.authority();\n    } else {\n      var origin = URI(v);\n      this\n        .protocol(origin.protocol())\n        .authority(origin.authority())\n        .build(!build);\n      return this;\n    }\n  };\n  p.host = function(v, build) {\n    if (this._parts.urn) {\n      return v === undefined ? '' : this;\n    }\n\n    if (v === undefined) {\n      return this._parts.hostname ? URI.buildHost(this._parts) : '';\n    } else {\n      var res = URI.parseHost(v, this._parts);\n      if (res !== '/') {\n        throw new TypeError('Hostname \"' + v + '\" contains characters other than [A-Z0-9.-]');\n      }\n\n      this.build(!build);\n      return this;\n    }\n  };\n  p.authority = function(v, build) {\n    if (this._parts.urn) {\n      return v === undefined ? '' : this;\n    }\n\n    if (v === undefined) {\n      return this._parts.hostname ? URI.buildAuthority(this._parts) : '';\n    } else {\n      var res = URI.parseAuthority(v, this._parts);\n      if (res !== '/') {\n        throw new TypeError('Hostname \"' + v + '\" contains characters other than [A-Z0-9.-]');\n      }\n\n      this.build(!build);\n      return this;\n    }\n  };\n  p.userinfo = function(v, build) {\n    if (this._parts.urn) {\n      return v === undefined ? '' : this;\n    }\n\n    if (v === undefined) {\n      var t = URI.buildUserinfo(this._parts);\n      return t ? t.substring(0, t.length -1) : t;\n    } else {\n      if (v[v.length-1] !== '@') {\n        v += '@';\n      }\n\n      URI.parseUserinfo(v, this._parts);\n      this.build(!build);\n      return this;\n    }\n  };\n  p.resource = function(v, build) {\n    var parts;\n\n    if (v === undefined) {\n      return this.path() + this.search() + this.hash();\n    }\n\n    parts = URI.parse(v);\n    this._parts.path = parts.path;\n    this._parts.query = parts.query;\n    this._parts.fragment = parts.fragment;\n    this.build(!build);\n    return this;\n  };\n\n  // fraction accessors\n  p.subdomain = function(v, build) {\n    if (this._parts.urn) {\n      return v === undefined ? '' : this;\n    }\n\n    // convenience, return \"www\" from \"www.example.org\"\n    if (v === undefined) {\n      if (!this._parts.hostname || this.is('IP')) {\n        return '';\n      }\n\n      // grab domain and add another segment\n      var end = this._parts.hostname.length - this.domain().length - 1;\n      return this._parts.hostname.substring(0, end) || '';\n    } else {\n      var e = this._parts.hostname.length - this.domain().length;\n      var sub = this._parts.hostname.substring(0, e);\n      var replace = new RegExp('^' + escapeRegEx(sub));\n\n      if (v && v.charAt(v.length - 1) !== '.') {\n        v += '.';\n      }\n\n      if (v) {\n        URI.ensureValidHostname(v);\n      }\n\n      this._parts.hostname = this._parts.hostname.replace(replace, v);\n      this.build(!build);\n      return this;\n    }\n  };\n  p.domain = function(v, build) {\n    if (this._parts.urn) {\n      return v === undefined ? '' : this;\n    }\n\n    if (typeof v === 'boolean') {\n      build = v;\n      v = undefined;\n    }\n\n    // convenience, return \"example.org\" from \"www.example.org\"\n    if (v === undefined) {\n      if (!this._parts.hostname || this.is('IP')) {\n        return '';\n      }\n\n      // if hostname consists of 1 or 2 segments, it must be the domain\n      var t = this._parts.hostname.match(/\\./g);\n      if (t && t.length < 2) {\n        return this._parts.hostname;\n      }\n\n      // grab tld and add another segment\n      var end = this._parts.hostname.length - this.tld(build).length - 1;\n      end = this._parts.hostname.lastIndexOf('.', end -1) + 1;\n      return this._parts.hostname.substring(end) || '';\n    } else {\n      if (!v) {\n        throw new TypeError('cannot set domain empty');\n      }\n\n      URI.ensureValidHostname(v);\n\n      if (!this._parts.hostname || this.is('IP')) {\n        this._parts.hostname = v;\n      } else {\n        var replace = new RegExp(escapeRegEx(this.domain()) + '$');\n        this._parts.hostname = this._parts.hostname.replace(replace, v);\n      }\n\n      this.build(!build);\n      return this;\n    }\n  };\n  p.tld = function(v, build) {\n    if (this._parts.urn) {\n      return v === undefined ? '' : this;\n    }\n\n    if (typeof v === 'boolean') {\n      build = v;\n      v = undefined;\n    }\n\n    // return \"org\" from \"www.example.org\"\n    if (v === undefined) {\n      if (!this._parts.hostname || this.is('IP')) {\n        return '';\n      }\n\n      var pos = this._parts.hostname.lastIndexOf('.');\n      var tld = this._parts.hostname.substring(pos + 1);\n\n      if (build !== true && SLD && SLD.list[tld.toLowerCase()]) {\n        return SLD.get(this._parts.hostname) || tld;\n      }\n\n      return tld;\n    } else {\n      var replace;\n\n      if (!v) {\n        throw new TypeError('cannot set TLD empty');\n      } else if (v.match(/[^a-zA-Z0-9-]/)) {\n        if (SLD && SLD.is(v)) {\n          replace = new RegExp(escapeRegEx(this.tld()) + '$');\n          this._parts.hostname = this._parts.hostname.replace(replace, v);\n        } else {\n          throw new TypeError('TLD \"' + v + '\" contains characters other than [A-Z0-9]');\n        }\n      } else if (!this._parts.hostname || this.is('IP')) {\n        throw new ReferenceError('cannot set TLD on non-domain host');\n      } else {\n        replace = new RegExp(escapeRegEx(this.tld()) + '$');\n        this._parts.hostname = this._parts.hostname.replace(replace, v);\n      }\n\n      this.build(!build);\n      return this;\n    }\n  };\n  p.directory = function(v, build) {\n    if (this._parts.urn) {\n      return v === undefined ? '' : this;\n    }\n\n    if (v === undefined || v === true) {\n      if (!this._parts.path && !this._parts.hostname) {\n        return '';\n      }\n\n      if (this._parts.path === '/') {\n        return '/';\n      }\n\n      var end = this._parts.path.length - this.filename().length - 1;\n      var res = this._parts.path.substring(0, end) || (this._parts.hostname ? '/' : '');\n\n      return v ? URI.decodePath(res) : res;\n\n    } else {\n      var e = this._parts.path.length - this.filename().length;\n      var directory = this._parts.path.substring(0, e);\n      var replace = new RegExp('^' + escapeRegEx(directory));\n\n      // fully qualifier directories begin with a slash\n      if (!this.is('relative')) {\n        if (!v) {\n          v = '/';\n        }\n\n        if (v.charAt(0) !== '/') {\n          v = '/' + v;\n        }\n      }\n\n      // directories always end with a slash\n      if (v && v.charAt(v.length - 1) !== '/') {\n        v += '/';\n      }\n\n      v = URI.recodePath(v);\n      this._parts.path = this._parts.path.replace(replace, v);\n      this.build(!build);\n      return this;\n    }\n  };\n  p.filename = function(v, build) {\n    if (this._parts.urn) {\n      return v === undefined ? '' : this;\n    }\n\n    if (v === undefined || v === true) {\n      if (!this._parts.path || this._parts.path === '/') {\n        return '';\n      }\n\n      var pos = this._parts.path.lastIndexOf('/');\n      var res = this._parts.path.substring(pos+1);\n\n      return v ? URI.decodePathSegment(res) : res;\n    } else {\n      var mutatedDirectory = false;\n\n      if (v.charAt(0) === '/') {\n        v = v.substring(1);\n      }\n\n      if (v.match(/\\.?\\//)) {\n        mutatedDirectory = true;\n      }\n\n      var replace = new RegExp(escapeRegEx(this.filename()) + '$');\n      v = URI.recodePath(v);\n      this._parts.path = this._parts.path.replace(replace, v);\n\n      if (mutatedDirectory) {\n        this.normalizePath(build);\n      } else {\n        this.build(!build);\n      }\n\n      return this;\n    }\n  };\n  p.suffix = function(v, build) {\n    if (this._parts.urn) {\n      return v === undefined ? '' : this;\n    }\n\n    if (v === undefined || v === true) {\n      if (!this._parts.path || this._parts.path === '/') {\n        return '';\n      }\n\n      var filename = this.filename();\n      var pos = filename.lastIndexOf('.');\n      var s, res;\n\n      if (pos === -1) {\n        return '';\n      }\n\n      // suffix may only contain alnum characters (yup, I made this up.)\n      s = filename.substring(pos+1);\n      res = (/^[a-z0-9%]+$/i).test(s) ? s : '';\n      return v ? URI.decodePathSegment(res) : res;\n    } else {\n      if (v.charAt(0) === '.') {\n        v = v.substring(1);\n      }\n\n      var suffix = this.suffix();\n      var replace;\n\n      if (!suffix) {\n        if (!v) {\n          return this;\n        }\n\n        this._parts.path += '.' + URI.recodePath(v);\n      } else if (!v) {\n        replace = new RegExp(escapeRegEx('.' + suffix) + '$');\n      } else {\n        replace = new RegExp(escapeRegEx(suffix) + '$');\n      }\n\n      if (replace) {\n        v = URI.recodePath(v);\n        this._parts.path = this._parts.path.replace(replace, v);\n      }\n\n      this.build(!build);\n      return this;\n    }\n  };\n  p.segment = function(segment, v, build) {\n    var separator = this._parts.urn ? ':' : '/';\n    var path = this.path();\n    var absolute = path.substring(0, 1) === '/';\n    var segments = path.split(separator);\n\n    if (segment !== undefined && typeof segment !== 'number') {\n      build = v;\n      v = segment;\n      segment = undefined;\n    }\n\n    if (segment !== undefined && typeof segment !== 'number') {\n      throw new Error('Bad segment \"' + segment + '\", must be 0-based integer');\n    }\n\n    if (absolute) {\n      segments.shift();\n    }\n\n    if (segment < 0) {\n      // allow negative indexes to address from the end\n      segment = Math.max(segments.length + segment, 0);\n    }\n\n    if (v === undefined) {\n      /*jshint laxbreak: true */\n      return segment === undefined\n        ? segments\n        : segments[segment];\n      /*jshint laxbreak: false */\n    } else if (segment === null || segments[segment] === undefined) {\n      if (isArray(v)) {\n        segments = [];\n        // collapse empty elements within array\n        for (var i=0, l=v.length; i < l; i++) {\n          if (!v[i].length && (!segments.length || !segments[segments.length -1].length)) {\n            continue;\n          }\n\n          if (segments.length && !segments[segments.length -1].length) {\n            segments.pop();\n          }\n\n          segments.push(trimSlashes(v[i]));\n        }\n      } else if (v || typeof v === 'string') {\n        v = trimSlashes(v);\n        if (segments[segments.length -1] === '') {\n          // empty trailing elements have to be overwritten\n          // to prevent results such as /foo//bar\n          segments[segments.length -1] = v;\n        } else {\n          segments.push(v);\n        }\n      }\n    } else {\n      if (v) {\n        segments[segment] = trimSlashes(v);\n      } else {\n        segments.splice(segment, 1);\n      }\n    }\n\n    if (absolute) {\n      segments.unshift('');\n    }\n\n    return this.path(segments.join(separator), build);\n  };\n  p.segmentCoded = function(segment, v, build) {\n    var segments, i, l;\n\n    if (typeof segment !== 'number') {\n      build = v;\n      v = segment;\n      segment = undefined;\n    }\n\n    if (v === undefined) {\n      segments = this.segment(segment, v, build);\n      if (!isArray(segments)) {\n        segments = segments !== undefined ? URI.decode(segments) : undefined;\n      } else {\n        for (i = 0, l = segments.length; i < l; i++) {\n          segments[i] = URI.decode(segments[i]);\n        }\n      }\n\n      return segments;\n    }\n\n    if (!isArray(v)) {\n      v = (typeof v === 'string' || v instanceof String) ? URI.encode(v) : v;\n    } else {\n      for (i = 0, l = v.length; i < l; i++) {\n        v[i] = URI.encode(v[i]);\n      }\n    }\n\n    return this.segment(segment, v, build);\n  };\n\n  // mutating query string\n  var q = p.query;\n  p.query = function(v, build) {\n    if (v === true) {\n      return URI.parseQuery(this._parts.query, this._parts.escapeQuerySpace);\n    } else if (typeof v === 'function') {\n      var data = URI.parseQuery(this._parts.query, this._parts.escapeQuerySpace);\n      var result = v.call(this, data);\n      this._parts.query = URI.buildQuery(result || data, this._parts.duplicateQueryParameters, this._parts.escapeQuerySpace);\n      this.build(!build);\n      return this;\n    } else if (v !== undefined && typeof v !== 'string') {\n      this._parts.query = URI.buildQuery(v, this._parts.duplicateQueryParameters, this._parts.escapeQuerySpace);\n      this.build(!build);\n      return this;\n    } else {\n      return q.call(this, v, build);\n    }\n  };\n  p.setQuery = function(name, value, build) {\n    var data = URI.parseQuery(this._parts.query, this._parts.escapeQuerySpace);\n\n    if (typeof name === 'string' || name instanceof String) {\n      data[name] = value !== undefined ? value : null;\n    } else if (typeof name === 'object') {\n      for (var key in name) {\n        if (hasOwn.call(name, key)) {\n          data[key] = name[key];\n        }\n      }\n    } else {\n      throw new TypeError('URI.addQuery() accepts an object, string as the name parameter');\n    }\n\n    this._parts.query = URI.buildQuery(data, this._parts.duplicateQueryParameters, this._parts.escapeQuerySpace);\n    if (typeof name !== 'string') {\n      build = value;\n    }\n\n    this.build(!build);\n    return this;\n  };\n  p.addQuery = function(name, value, build) {\n    var data = URI.parseQuery(this._parts.query, this._parts.escapeQuerySpace);\n    URI.addQuery(data, name, value === undefined ? null : value);\n    this._parts.query = URI.buildQuery(data, this._parts.duplicateQueryParameters, this._parts.escapeQuerySpace);\n    if (typeof name !== 'string') {\n      build = value;\n    }\n\n    this.build(!build);\n    return this;\n  };\n  p.removeQuery = function(name, value, build) {\n    var data = URI.parseQuery(this._parts.query, this._parts.escapeQuerySpace);\n    URI.removeQuery(data, name, value);\n    this._parts.query = URI.buildQuery(data, this._parts.duplicateQueryParameters, this._parts.escapeQuerySpace);\n    if (typeof name !== 'string') {\n      build = value;\n    }\n\n    this.build(!build);\n    return this;\n  };\n  p.hasQuery = function(name, value, withinArray) {\n    var data = URI.parseQuery(this._parts.query, this._parts.escapeQuerySpace);\n    return URI.hasQuery(data, name, value, withinArray);\n  };\n  p.setSearch = p.setQuery;\n  p.addSearch = p.addQuery;\n  p.removeSearch = p.removeQuery;\n  p.hasSearch = p.hasQuery;\n\n  // sanitizing URLs\n  p.normalize = function() {\n    if (this._parts.urn) {\n      return this\n        .normalizeProtocol(false)\n        .normalizePath(false)\n        .normalizeQuery(false)\n        .normalizeFragment(false)\n        .build();\n    }\n\n    return this\n      .normalizeProtocol(false)\n      .normalizeHostname(false)\n      .normalizePort(false)\n      .normalizePath(false)\n      .normalizeQuery(false)\n      .normalizeFragment(false)\n      .build();\n  };\n  p.normalizeProtocol = function(build) {\n    if (typeof this._parts.protocol === 'string') {\n      this._parts.protocol = this._parts.protocol.toLowerCase();\n      this.build(!build);\n    }\n\n    return this;\n  };\n  p.normalizeHostname = function(build) {\n    if (this._parts.hostname) {\n      if (this.is('IDN') && punycode) {\n        this._parts.hostname = punycode.toASCII(this._parts.hostname);\n      } else if (this.is('IPv6') && IPv6) {\n        this._parts.hostname = IPv6.best(this._parts.hostname);\n      }\n\n      this._parts.hostname = this._parts.hostname.toLowerCase();\n      this.build(!build);\n    }\n\n    return this;\n  };\n  p.normalizePort = function(build) {\n    // remove port of it's the protocol's default\n    if (typeof this._parts.protocol === 'string' && this._parts.port === URI.defaultPorts[this._parts.protocol]) {\n      this._parts.port = null;\n      this.build(!build);\n    }\n\n    return this;\n  };\n  p.normalizePath = function(build) {\n    var _path = this._parts.path;\n    if (!_path) {\n      return this;\n    }\n\n    if (this._parts.urn) {\n      this._parts.path = URI.recodeUrnPath(this._parts.path);\n      this.build(!build);\n      return this;\n    }\n\n    if (this._parts.path === '/') {\n      return this;\n    }\n\n    _path = URI.recodePath(_path);\n\n    var _was_relative;\n    var _leadingParents = '';\n    var _parent, _pos;\n\n    // handle relative paths\n    if (_path.charAt(0) !== '/') {\n      _was_relative = true;\n      _path = '/' + _path;\n    }\n\n    // handle relative files (as opposed to directories)\n    if (_path.slice(-3) === '/..' || _path.slice(-2) === '/.') {\n      _path += '/';\n    }\n\n    // resolve simples\n    _path = _path\n      .replace(/(\\/(\\.\\/)+)|(\\/\\.$)/g, '/')\n      .replace(/\\/{2,}/g, '/');\n\n    // remember leading parents\n    if (_was_relative) {\n      _leadingParents = _path.substring(1).match(/^(\\.\\.\\/)+/) || '';\n      if (_leadingParents) {\n        _leadingParents = _leadingParents[0];\n      }\n    }\n\n    // resolve parents\n    while (true) {\n      _parent = _path.search(/\\/\\.\\.(\\/|$)/);\n      if (_parent === -1) {\n        // no more ../ to resolve\n        break;\n      } else if (_parent === 0) {\n        // top level cannot be relative, skip it\n        _path = _path.substring(3);\n        continue;\n      }\n\n      _pos = _path.substring(0, _parent).lastIndexOf('/');\n      if (_pos === -1) {\n        _pos = _parent;\n      }\n      _path = _path.substring(0, _pos) + _path.substring(_parent + 3);\n    }\n\n    // revert to relative\n    if (_was_relative && this.is('relative')) {\n      _path = _leadingParents + _path.substring(1);\n    }\n\n    this._parts.path = _path;\n    this.build(!build);\n    return this;\n  };\n  p.normalizePathname = p.normalizePath;\n  p.normalizeQuery = function(build) {\n    if (typeof this._parts.query === 'string') {\n      if (!this._parts.query.length) {\n        this._parts.query = null;\n      } else {\n        this.query(URI.parseQuery(this._parts.query, this._parts.escapeQuerySpace));\n      }\n\n      this.build(!build);\n    }\n\n    return this;\n  };\n  p.normalizeFragment = function(build) {\n    if (!this._parts.fragment) {\n      this._parts.fragment = null;\n      this.build(!build);\n    }\n\n    return this;\n  };\n  p.normalizeSearch = p.normalizeQuery;\n  p.normalizeHash = p.normalizeFragment;\n\n  p.iso8859 = function() {\n    // expect unicode input, iso8859 output\n    var e = URI.encode;\n    var d = URI.decode;\n\n    URI.encode = escape;\n    URI.decode = decodeURIComponent;\n    try {\n      this.normalize();\n    } finally {\n      URI.encode = e;\n      URI.decode = d;\n    }\n    return this;\n  };\n\n  p.unicode = function() {\n    // expect iso8859 input, unicode output\n    var e = URI.encode;\n    var d = URI.decode;\n\n    URI.encode = strictEncodeURIComponent;\n    URI.decode = unescape;\n    try {\n      this.normalize();\n    } finally {\n      URI.encode = e;\n      URI.decode = d;\n    }\n    return this;\n  };\n\n  p.readable = function() {\n    var uri = this.clone();\n    // removing username, password, because they shouldn't be displayed according to RFC 3986\n    uri.username('').password('').normalize();\n    var t = '';\n    if (uri._parts.protocol) {\n      t += uri._parts.protocol + '://';\n    }\n\n    if (uri._parts.hostname) {\n      if (uri.is('punycode') && punycode) {\n        t += punycode.toUnicode(uri._parts.hostname);\n        if (uri._parts.port) {\n          t += ':' + uri._parts.port;\n        }\n      } else {\n        t += uri.host();\n      }\n    }\n\n    if (uri._parts.hostname && uri._parts.path && uri._parts.path.charAt(0) !== '/') {\n      t += '/';\n    }\n\n    t += uri.path(true);\n    if (uri._parts.query) {\n      var q = '';\n      for (var i = 0, qp = uri._parts.query.split('&'), l = qp.length; i < l; i++) {\n        var kv = (qp[i] || '').split('=');\n        q += '&' + URI.decodeQuery(kv[0], this._parts.escapeQuerySpace)\n          .replace(/&/g, '%26');\n\n        if (kv[1] !== undefined) {\n          q += '=' + URI.decodeQuery(kv[1], this._parts.escapeQuerySpace)\n            .replace(/&/g, '%26');\n        }\n      }\n      t += '?' + q.substring(1);\n    }\n\n    t += URI.decodeQuery(uri.hash(), true);\n    return t;\n  };\n\n  // resolving relative and absolute URLs\n  p.absoluteTo = function(base) {\n    var resolved = this.clone();\n    var properties = ['protocol', 'username', 'password', 'hostname', 'port'];\n    var basedir, i, p;\n\n    if (this._parts.urn) {\n      throw new Error('URNs do not have any generally defined hierarchical components');\n    }\n\n    if (!(base instanceof URI)) {\n      base = new URI(base);\n    }\n\n    if (!resolved._parts.protocol) {\n      resolved._parts.protocol = base._parts.protocol;\n    }\n\n    if (this._parts.hostname) {\n      return resolved;\n    }\n\n    for (i = 0; (p = properties[i]); i++) {\n      resolved._parts[p] = base._parts[p];\n    }\n\n    if (!resolved._parts.path) {\n      resolved._parts.path = base._parts.path;\n      if (!resolved._parts.query) {\n        resolved._parts.query = base._parts.query;\n      }\n    } else {\n      if (resolved._parts.path.substring(-2) === '..') {\n        resolved._parts.path += '/';\n      }\n\n      if (resolved.path().charAt(0) !== '/') {\n        basedir = base.directory();\n        basedir = basedir ? basedir : base.path().indexOf('/') === 0 ? '/' : '';\n        resolved._parts.path = (basedir ? (basedir + '/') : '') + resolved._parts.path;\n        resolved.normalizePath();\n      }\n    }\n\n    resolved.build();\n    return resolved;\n  };\n  p.relativeTo = function(base) {\n    var relative = this.clone().normalize();\n    var relativeParts, baseParts, common, relativePath, basePath;\n\n    if (relative._parts.urn) {\n      throw new Error('URNs do not have any generally defined hierarchical components');\n    }\n\n    base = new URI(base).normalize();\n    relativeParts = relative._parts;\n    baseParts = base._parts;\n    relativePath = relative.path();\n    basePath = base.path();\n\n    if (relativePath.charAt(0) !== '/') {\n      throw new Error('URI is already relative');\n    }\n\n    if (basePath.charAt(0) !== '/') {\n      throw new Error('Cannot calculate a URI relative to another relative URI');\n    }\n\n    if (relativeParts.protocol === baseParts.protocol) {\n      relativeParts.protocol = null;\n    }\n\n    if (relativeParts.username !== baseParts.username || relativeParts.password !== baseParts.password) {\n      return relative.build();\n    }\n\n    if (relativeParts.protocol !== null || relativeParts.username !== null || relativeParts.password !== null) {\n      return relative.build();\n    }\n\n    if (relativeParts.hostname === baseParts.hostname && relativeParts.port === baseParts.port) {\n      relativeParts.hostname = null;\n      relativeParts.port = null;\n    } else {\n      return relative.build();\n    }\n\n    if (relativePath === basePath) {\n      relativeParts.path = '';\n      return relative.build();\n    }\n\n    // determine common sub path\n    common = URI.commonPath(relativePath, basePath);\n\n    // If the paths have nothing in common, return a relative URL with the absolute path.\n    if (!common) {\n      return relative.build();\n    }\n\n    var parents = baseParts.path\n      .substring(common.length)\n      .replace(/[^\\/]*$/, '')\n      .replace(/.*?\\//g, '../');\n\n    relativeParts.path = (parents + relativeParts.path.substring(common.length)) || './';\n\n    return relative.build();\n  };\n\n  // comparing URIs\n  p.equals = function(uri) {\n    var one = this.clone();\n    var two = new URI(uri);\n    var one_map = {};\n    var two_map = {};\n    var checked = {};\n    var one_query, two_query, key;\n\n    one.normalize();\n    two.normalize();\n\n    // exact match\n    if (one.toString() === two.toString()) {\n      return true;\n    }\n\n    // extract query string\n    one_query = one.query();\n    two_query = two.query();\n    one.query('');\n    two.query('');\n\n    // definitely not equal if not even non-query parts match\n    if (one.toString() !== two.toString()) {\n      return false;\n    }\n\n    // query parameters have the same length, even if they're permuted\n    if (one_query.length !== two_query.length) {\n      return false;\n    }\n\n    one_map = URI.parseQuery(one_query, this._parts.escapeQuerySpace);\n    two_map = URI.parseQuery(two_query, this._parts.escapeQuerySpace);\n\n    for (key in one_map) {\n      if (hasOwn.call(one_map, key)) {\n        if (!isArray(one_map[key])) {\n          if (one_map[key] !== two_map[key]) {\n            return false;\n          }\n        } else if (!arraysEqual(one_map[key], two_map[key])) {\n          return false;\n        }\n\n        checked[key] = true;\n      }\n    }\n\n    for (key in two_map) {\n      if (hasOwn.call(two_map, key)) {\n        if (!checked[key]) {\n          // two contains a parameter not present in one\n          return false;\n        }\n      }\n    }\n\n    return true;\n  };\n\n  // state\n  p.duplicateQueryParameters = function(v) {\n    this._parts.duplicateQueryParameters = !!v;\n    return this;\n  };\n\n  p.escapeQuerySpace = function(v) {\n    this._parts.escapeQuerySpace = !!v;\n    return this;\n  };\n\n  return URI;\n}));",
    "var $ = (typeof window !== \"undefined\" ? window['$'] : typeof global !== \"undefined\" ? global['$'] : null);\nvar ko = (typeof window !== \"undefined\" ? window['ko'] : typeof global !== \"undefined\" ? global['ko'] : null);\n//var HeroCalc = require('dota-hero-calculator-library');\nvar HeroModel = require('dota-hero-calculator/src/js/herocalc/hero/HeroModel');\nvar HeroOptions = require('dota-hero-calculator/src/js/herocalc/hero/heroOptionsArray');\nvar BitArray = require('bit-array-js');\nvar URI = require('urijs');\nvar Slider = require('./slider');\nvar responsiveVoice = require('./responsivevoice');\n\nrequire('./ko.bindingHandlers.checkbox');\nrequire('./ko.bindingHandlers.radio');\nrequire('./ko.extenders.urlSync');\n\nvar rollbar = require('./rollbar');\nvar buildDate = \"2018-09-10 12:44:24 UTC\";\ndocument.getElementById('buildDate').innerHTML = buildDate;\n\nvar releaseTag = \"1.0.0\";\ndocument.getElementById('releaseTag').innerHTML = releaseTag;\n\nvar App = function () {\n\n    //HeroCalc.init(null, null, null, function () {\n        var attributeOptions = [\n            {id: \"totalArmorPhysical\", name: \"Armor\"},\n            {id: \"totalArmorPhysicalReduction\", name: \"Physical Damage Reduction\"},\n            {id: \"totalMagicResistance\", name: \"Magic Resistance\"},\n            {id: \"totalStatusResistance\", name: \"Status Resistance\"},\n            {id: \"totalattackrange\", name: \"Attack Range\"},\n            {id: \"totalAgi\", name: \"Agility\"},\n            {id: \"totalInt\", name: \"Intelligence\"},\n            {id: \"totalStr\", name: \"Strength\"},\n            {id: \"health\", name: \"HP\"},\n            {id: \"mana\", name: \"Mana\"},\n            {id: \"healthregen\", name: \"HP Regeneration\"},\n            {id: \"manaregen\", name: \"Mana Regeneration\"},\n            {id: \"totalMovementSpeed\", name: \"Movement Speed\"},\n            {id: \"totalTurnRate\", name: \"Turn Rate\"},\n            {id: \"baseDamageMin\", name: \"Attack Damage Min\"},\n            {id: \"baseDamageMax\", name: \"Attack Damage Max\"},\n            {id: \"baseDamageAvg\", name: \"Attack Damage Avg\"},\n            {id: \"ehpPhysical\", name: \"EHP\"},\n            {id: \"ehpMagical\", name: \"Magical EHP\"},\n            {id: \"primaryAttribute\", name: \"Primary Attribute\"},\n            {id: \"projectilespeed\", name: \"Missile Speed\"},\n            {id: \"attributeagilitygain\", name: \"Agility Gain\"},\n            {id: \"attributestrengthgain\", name: \"Strength Gain\"},\n            {id: \"attributeintelligencegain\", name: \"Intelligence Gain\"},\n            {id: \"attributebaseagility\", name: \"Base Agility\"},\n            {id: \"attributebaseintelligence\", name: \"Base Intelligence\"},\n            {id: \"attributebasestrength\", name: \"Base Strength\"},\n            {id: \"visionrangeday\", name: \"Day Vision Range\"},\n            {id: \"visionrangenight\", name: \"Night Vision Range\"},\n        ];\n        \n        \n        function getRandomInt(min, max) {\n            return Math.floor(Math.random() * (max - min + 1)) + min;\n        }\n        \n        function shuffle(array) {\n            var counter = array.length,\n                temp, index;\n\n            // While there are elements in the array\n            while (counter > 0) {\n                // Pick a random index\n                index = Math.floor(Math.random() * counter);\n\n                // Decrease counter by 1\n                counter--;\n\n                // And swap the last element with it\n                temp = array[counter];\n                array[counter] = array[index];\n                array[index] = temp;\n            }\n\n            return array;\n        };\n        \n        function getAttributeValue(heroModel, attribute) {\n            console.log('getAttributeValue', heroModel, attribute);\n            if (heroModel.hasOwnProperty(attribute)) {\n                switch (attribute) {\n                    case 'totalAgi':\n                    case 'totalInt':\n                    case 'totalStr':\n                    case 'health':\n                    case 'healthregen':\n                    case 'mana':\n                    case 'manaregen':\n                    case 'totalArmorPhysical':\n                        return heroModel[attribute]().total.toFixed(2);\n                    break;\n                    case 'totalArmorPhysicalReduction':\n                    case 'totalStatusResistance':\n                    case 'totalMagicResistance':\n                    case 'evasion':\n                    case 'bash':\n                    case 'critChance':\n                    case 'missChance':\n                    case 'lifesteal':\n                        return (heroModel[attribute]() * 100).toFixed(2);\n                    break;\n                    default:\n                        return heroModel[attribute]();\n                    break;\n                }\n            }\n            else {\n                return heroModel.heroData()[attribute];\n            }\n        }\n        \n        function formatValue(value) {\n            switch (value) {\n                case 'agi':\n                    return 'Agility';\n                break;\n                case 'str':\n                    return 'Strength';\n                break;\n                case 'int':\n                    return 'Intelligence';\n                break;\n            }\n            return parseFloat(parseFloat(value).toFixed(2)).toString();\n        }\n        \n        var attributes = attributeOptions.map(function (a) { return a.id; });\n        \n        function getHeroID(hero) {\n            return HeroCalcData.heroData['npc_dota_hero_' + hero].HeroID;\n        }\n\n        var heroData = HeroCalcData.heroData;\n        var heroOptions = HeroOptions.init(HeroCalcData.heroData);\n        var heroIds = heroOptions.map(function (hero) { return hero.heroName });\n        var heroModel = new HeroModel(HeroCalcData.heroData, HeroCalcData.itemData, 'abaddon');\n        \n        function buildDeck() {\n            var DECK = [];\n            for (var i = 0; i < heroIds.length; i++) {\n                for (var j = 0; j < 25; j++) {\n                    for (var k = 0; k < attributes.length; k++) {\n                        var card = {\n                            id: i * heroIds.length + j * 25 + k,\n                            kind: 'attributes',\n                            hero: heroIds[i],\n                            name: attributes[k],\n                            level: j + 1\n                        }\n                        //card.correct = 0;\n                        //card.wrong = 0;\n                        DECK.push(card);\n                    }\n                }\n            }\n            \n            var c = heroIds.length * attributes.length * 25;\n            for (var i = 0; i < heroIds.length; i++) {\n                var heroId = heroIds[i];\n                var abilities = heroData['npc_dota_hero_' + heroId].abilities;\n                for (var j = 0; j < abilities.length; j++) {\n                    var ability = abilities[j];\n                    if (ability.displayname === 'Attribute Bonus' || ability.displayname === '' || ability.displayname === 'Empty') continue;\n                    \n                    var maxAbilityLevel = heroModel.getAbilityLevelMax(ability);\n                    for (var k = 0; k < ability.attributes.length; k++) {\n                        var attribute = ability.attributes[k];\n                        if (!attribute.hasOwnProperty('tooltip')) continue;\n                        \n                        for (var l = 0; l < maxAbilityLevel; l++) {\n                            DECK.push({\n                                id: c,\n                                kind: 'abilities',\n                                hero: heroId,\n                                name: ability.name,\n                                property: attribute.name,\n                                level: l + 1\n                            });\n                            c++;\n                        }\n                    }\n                    \n                    for (var m = 0; m < maxAbilityLevel; m++) {\n                        DECK.push({\n                            id: c,\n                            kind: 'abilities',\n                            hero: heroId,\n                            name: ability.name,\n                            property: 'cooldown',\n                            level: m + 1\n                        });\n                        c++;\n                    }\n                    \n                    for (var n = 0; n < maxAbilityLevel; n++) {\n                        DECK.push({\n                            id: c,\n                            kind: 'abilities',\n                            hero: heroId,\n                            name: ability.name,\n                            property: 'manacost',\n                            level: n + 1\n                        });\n                        c++;\n                    }\n                }\n            }\n            return DECK;\n        }\n        //var t0 = performance.now();\n        var DECK = buildDeck();\n        console.log(DECK);\n        //var t1 = performance.now();\n        //alert(\"Deck build took \" + (t1 - t0) + \"ms.\")\n        \n        function filterDeck(DECK, heroIds, attributes, minLevel, maxLevel, abilityQuestionTypes) {\n            return DECK.filter(function (card) {\n                if (heroIds.indexOf(card.hero) === -1) return false;\n                switch (card.kind) {\n                    case 'attributes':\n                        return card.level >= minLevel && card.level <= maxLevel && attributes.indexOf(card.name) !== -1;\n                    break;\n                    case 'abilities':\n                        switch (card.property) {\n                            case 'manacost':\n                            case 'cooldown':\n                                return abilityQuestionTypes.indexOf(card.property) !== -1;\n                            break;\n                            default:\n                                return abilityQuestionTypes.indexOf('attributes') !== -1;\n                            break;\n                        }\n                    break;\n                }\n            });\n        }\n        \n        function formatCard(card) {\n            var heroName = heroData['npc_dota_hero_' + card.hero].displayname;\n            switch (card.kind) {\n                case 'attributes':\n                    return 'Level ' + card.level + '<br>' + heroName + '<br>' + attributeOptions.filter(function(a) {\n                        return a.id == card.name;\n                    })[0].name;\n                break;\n                case 'abilities':\n                    var ability = heroData['npc_dota_hero_' + card.hero].abilities.filter(function (ability) { return ability.name == card.name })[0]\n                    switch (card.property) {\n                        case 'manacost':\n                            tooltip = 'Mana Cost';\n                        break;\n                        case 'cooldown':\n                            tooltip = 'Cooldown';\n                        break;\n                        default:\n                            var attribute = ability.attributes.filter(function (attribute) { return attribute.name == card.property })[0];\n                            tooltip = attribute.tooltip;\n                        break;\n                    }\n                    if (tooltip.slice(-1) == ':') {\n                        tooltip = tooltip.slice(0, -1);\n                    }\n                    return heroName + '<br>' + ability.displayname + '<br>Level ' + card.level + '<br>' + tooltip;\n                break;\n            }\n        }\n        \n        function getCardAnswer(card) {\n            heroModel.heroId(card.hero);\n            switch (card.kind) {\n                case 'attributes':\n                    heroModel.selectedHeroLevel(card.level);\n                    return formatValue(getAttributeValue(heroModel, card.name));\n                break;\n                case 'abilities':\n                    var ability = heroData['npc_dota_hero_' + card.hero].abilities.filter(function (ability) { return ability.name == card.name })[0]\n                    var values;\n                    switch (card.property) {\n                        case 'manacost':\n                        case 'cooldown':\n                            values = ability[card.property];\n                        break;\n                        default:\n                            var attribute = ability.attributes.filter(function (attribute) { return attribute.name == card.property })[0];\n                            values = attribute.value;\n                        break;\n                    }\n                    if (card.level > values.length) {\n                        var value = values[0];\n                    }\n                    else {\n                        var value = values[Math.max(0, card.level - 1)];\n                    }\n                \n                    return formatValue(value);\n                break;\n            }\n        }\n        \n        function formatSpeech(text) {\n            return text.toString()\n                        .replace(/<br>/g, ' ')\n                        .replace(/Avg/g, 'Average')\n                        .replace(/Shaman/g, 'Shahman')\n                        .replace(/Techies/g, 'Tekkies')\n                        .replace(/Alchemist/g, 'Alkemist')\n                        .replace(/Jakiro/g, 'Jah-keer-roe')\n                        .replace(/Huskar/g, 'Husk-R')\n                        .replace(/Omniknight/g, 'Omni-knight')\n                        .replace(/Aphotic/g, 'Afotic')\n                        .replace(/Avernus/g, 'Ahvernus')\n                        .replace(/Malefice/g, 'Malifice')\n                        .replace(/Chronosphere/g, 'Chrohnosphere')\n                        .replace(/Omnislash/g, 'Omni-slash')\n                        .replace(/Degen Aura/g, 'D-gen Aura')\n                        .replace(/Coup de Grace/g, 'Coup de Grahs')\n                        .replace(/Squad, Attack!/g, 'Squad Attack!')\n                        .replace(/Sigil/g, 'Frozen Sijhil')\n                        .replace(/Grave Chill/g, 'Graiyv Chill')\n                        .replace(/Familiars/g, 'Familiarz.');\n        }\n\n        function ViewModel() {\n            var self = this;\n            this.attributes = ko.observableArray(attributeOptions);\n            this.heroes = heroOptions.sort(function (a, b) {\n                if (a.heroDisplayName < b.heroDisplayName) return -1;\n                if (a.heroDisplayName > b.heroDisplayName) return 1;\n                return 0;\n            });\n            var uri = new URI();\n            this.selectedAttributesBitArray = new BitArray(32);\n            this.selectedAttributesBitArray.fromBase64UrlSafe(uri.query(true)['attributes']);\n            this.selectedAttributes = ko.observableArray(self.attributes().map(function(a) {\n                return a.id;\n            }).filter(function(h, i) {\n                return self.selectedAttributesBitArray.value(i);\n            })).extend({ deferred: true });\n            this.selectedAttributes.subscribe(function(changes) {\n                changes.forEach(function(change) {\n                    if (change.status === 'added' || change.status === 'deleted') {\n                        for (var i = 0; i < self.attributes().length; i++) {\n                            var attr = self.attributes()[i];\n                            if (attr.id == change.value) {\n                                self.selectedAttributesBitArray.value(i, change.status === 'added');\n                                break;\n                            }\n                        }\n                    }\n                });\n                uri.setSearch(\"attributes\", self.selectedAttributesBitArray.toBase64UrlSafe());\n                window.history.replaceState({}, \"\", uri.toString());\n            }, null, \"arrayChange\");\n\n            this.selectedHeroesBitArray = new BitArray(128);\n            this.selectedHeroesBitArray.fromBase64UrlSafe(uri.query(true)['heroes']);\n            this.selectedHeroes = ko.observableArray(\n                this.heroes.map(function (o) { return o.heroName; }).filter(function (h) { return self.selectedHeroesBitArray.value(getHeroID(h)); })\n            ).extend({ deferred: true });\n            this.selectedHeroes.subscribe(function(changes) {\n                changes.forEach(function(change) {\n                    if (change.status === 'added' || change.status === 'deleted') {\n                        self.selectedHeroesBitArray.value(getHeroID(change.value), change.status === 'added');\n                    }\n                });\n                uri.setSearch(\"heroes\", self.selectedHeroesBitArray.toBase64UrlSafe());\n                window.history.replaceState({}, \"\", uri.toString());\n            }, null, \"arrayChange\");\n            \n            this.deck = [];\n            this.card = null;\n            this.state = ko.observable(0);\n            this.text = ko.observable('<i>Tap to start</i>');\n            this.textToSpeech = ko.observable(false).extend({ urlSync: {\n                    param: 'speech',\n                    read: function (value) {\n                        return value != false && value !== 'false';\n                    }\n                }\n            });\n            this.minLevel = ko.observable(1).extend({ numeric: {defaultValue: 1}, urlSync: {\n                    param: 'minlevel',\n                    read: function (value) {\n                        return parseInt(value);\n                    }\n                }\n            });\n            this.minLevel.subscribe(function (newValue) {\n                if (parseInt(newValue) > parseInt(self.maxLevel())) {\n                    self.maxLevel(self.minLevel()); \n                }\n            });\n            this.maxLevel = ko.observable(1).extend({ numeric: {defaultValue: 1}, urlSync: {\n                    param: 'maxlevel',\n                    read: function (value) {\n                        return parseInt(value);\n                    }\n                }\n            });\n            this.maxLevel.subscribe(function (newValue) {\n                if (parseInt(newValue) < parseInt(self.minLevel())) {\n                    self.minLevel(self.maxLevel());\n                }\n            });\n            \n            this.reset = function () {\n                this.state(0);\n                this.stats.correct(0);\n                this.stats.wrong(0);\n                if (this.card) {\n                    this.deck.push(this.card);\n                }\n                this.card = null;\n                this.text('<i>Tap to start</i>');\n            }\n            \n            this.isWrong = ko.observable(false);\n            this.run = function () {\n                if (!this.deck.length && !this.card) {\n                    alert('No heroes or attributes selected.');\n                    return;\n                }\n\n                // when state is 0, pick random card to show\n                if (this.state() === 0) {\n                    \n                    // put old card back in deck\n                    if (this.card) {\n                        var index;\n                        switch (this.drawStrategy()) {\n                            case 'back':\n                                index = 0;\n                            break;\n                            case 'random':\n                                // inserts at random position excluding the very end\n                                index = Math.floor(Math.random() * this.deck.length);\n                            break;\n                            case 'training':\n                                var minP = Math.min(this.deck.length, 5);\n                                var maxP = Math.min(this.deck.length, 10);\n                                if (this.isWrong()) {\n                                    index = this.deck.length - getRandomInt(minP, maxP);\n                                }\n                                else {\n                                    index = getRandomInt(0, this.deck.length - maxP);\n                                }\n                            break;\n                        }\n                        this.deck.splice(index, 0, this.card);\n                        \n                        if (this.isWrong()) {\n                            this.stats.wrong(this.stats.wrong()+1);\n                        }\n                        else {\n                            this.stats.correct(this.stats.correct()+1);\n                        }\n                    }\n                \n                    this.card = this.deck.pop();\n                    console.log(this.card);\n                    this.text(formatCard(this.card));\n                    this.isWrong(false);\n                }\n                // when state is 1, we show the answer\n                else if (this.state() === 1) {\n                    this.text(getCardAnswer(this.card));\n                }\n                console.log(this.text());\n\n                this.state((this.state() + 1) % 2);\n\n                if (this.textToSpeech()) {\n                    responsiveVoice.speak(formatSpeech(this.text()), 'US English Female', {\"onend\": this.loop});\n                }\n                else {\n                    this.loop();\n                }\n            };\n            \n            this.loop = function () {\n                if (self.autoPlay() && self.activeTab() === '#home') {\n                    clearTimeout(self.autoPlayInterval);\n                    self.autoPlayInterval = setTimeout(function () {\n                        self.slider.next();\n                    }, self.autoPlayDelay());\n                }            \n            }\n\n            this.selectAllHeroes = function () {\n                self.selectedHeroes(self.heroes.map(function (o) { return o.heroName; }));\n            }\n            this.deselectAllHeroes = function () {\n                this.selectedHeroes.removeAll();\n            }\n            this.selectAllAttributes = function () {\n                self.selectedAttributes(self.attributes().map(function (o) { return o.id; }));\n            }\n            this.deselectAllAttributes = function () {\n                this.selectedAttributes.removeAll();\n            }\n\n            this.correct = function () {\n                //console.log('btn correct');\n                clearTimeout(this.autoPlayInterval);\n                this.run();\n            }\n\n            this.wrong = function () {\n                //console.log('btn wrong');\n                clearTimeout(this.autoPlayInterval);\n                this.isWrong(true);\n                this.slider.next();\n            }\n\n            this.infoBarVisible = ko.observable(true).extend({ urlSync: {\n                    param: 'infobar',\n                    read: function (value) {\n                        return value != false && value !== 'false';\n                    }\n                }\n            });\n\n            this.autoPlay = ko.observable(false).extend({ urlSync: {\n                    param: 'autoplay',\n                    read: function (value) {\n                        return value != false && value !== 'false';\n                    }\n                }\n            });\n            this.autoPlayDelay = ko.observable(3000).extend({ numeric: {defaultValue: 3000}, urlSync: {\n                    param: 'autodelay',\n                    read: function (value) {\n                        return parseInt(value);\n                    }\n                }\n            });\n            this.autoPlayInterval;\n            this.autoPlay.subscribe(function(newValue) {\n                if (!newValue) {\n                    clearTimeout(self.autoPlayInterval);\n                }\n            });\n            \n            this.drawStrategy = ko.observable('training').extend({ urlSync: {\n                    param: 'shuffle',\n                    read: function (value) {\n                        value = value.toLowerCase();\n                        return ['training', 'back', 'random'].indexOf(value) !== -1 ? value : 'training';\n                    }\n                }\n            });\n            \n            this.questionTypes = ko.observableArray(['attributes']).extend({ urlSync: {\n                    param: 'categories',\n                    read: function (value) {\n                        value = [].concat(value).map(function (o) { return o.toLowerCase(); }).filter(function (o) { return ['attributes', 'abilities'].indexOf(o) !== -1 });\n                        return value.length ? value : ['attributes'];\n                    }\n                }\n            });\n            this.questionTypes.subscribe(function(changes) {\n                if (self.questionTypes().length === 0) {\n                    var arr = [];\n                    changes.forEach(function(change) {\n                        if (change.status === 'deleted') arr.push(change.value);\n                    });\n                    self.questionTypes(arr);\n                }\n            }, null, \"arrayChange\");\n            \n            this.abilityQuestionTypes = ko.observableArray(['attributes']).extend({ urlSync: {\n                    param: 'abilities',\n                    read: function (value) {\n                        value = [].concat(value).map(function (o) { return o.toLowerCase(); }).filter(function (o) { return ['attributes', 'cooldown', 'manacost'].indexOf(o) !== -1 });\n                        return value.length ? value : ['abilities'];\n                    }\n                }\n            });\n            this.abilityQuestionTypes.subscribe(function(changes) {\n                if (self.abilityQuestionTypes().length === 0) {\n                    var arr = [];\n                    changes.forEach(function(change) {\n                        if (change.status === 'deleted') arr.push(change.value);\n                    });\n                    self.abilityQuestionTypes(arr);\n                }\n            }, null, \"arrayChange\");\n            this.abilityQuestionTypesVisible = ko.computed(function () {\n                return self.questionTypes().indexOf('abilities') !== -1;\n            });\n\n            this.stats = {\n                deck: ko.observable(0),\n                correct: ko.observable(0),\n                wrong: ko.observable(0)\n            }\n            \n            // serialized deck settings string, used to check if settings have changed\n            this.deckSettingsState = '';\n            \n            this.serializeDeckSettings = function () {\n                return ko.toJSON({\n                    heroes: self.selectedHeroesBitArray.toBase64UrlSafe(),\n                    attributes: self.selectedAttributesBitArray.toBase64UrlSafe(),\n                    minLevel: self.minLevel(),\n                    maxLevel: self.maxLevel(),\n                    autoPlay: self.autoPlay(),\n                    autoPlayDelay: self.autoPlayDelay(),\n                    drawStrategy: self.drawStrategy(),\n                    questionTypes: self.questionTypes(),\n                    abilityQuestionTypes: self.abilityQuestionTypes()\n                });\n            }\n            \n            this.updateDeck = function () {\n                var selectedAttributes = (this.questionTypes.indexOf('attributes') !== -1) ? this.selectedAttributes() : [];\n                var abilityQuestionTypes = (this.questionTypes.indexOf('abilities') !== -1) ? this.abilityQuestionTypes() : [];\n                this.reset();\n                this.deck = shuffle(filterDeck(DECK, this.selectedHeroes(), selectedAttributes, parseInt(this.minLevel()), parseInt(this.maxLevel()), abilityQuestionTypes));\n                this.deckSettingsState = this.serializeDeckSettings();\n                this.stats.deck(this.deck.length);\n            }\n            this.updateDeck();\n            \n            this.shuffleDeck = function () {\n                this.reset();\n                this.deck = shuffle(this.deck);\n            }\n            \n            this.slider = new Slider('#slider', {\n                onPanStart: function () {\n                    clearTimeout(self.autoPlayInterval);\n                },\n                onGoTo: function (bChanged) {\n                    if (bChanged) {\n                        self.correct();\n                    }\n                    else {\n                        self.loop();\n                    }\n                }\n            });\n            \n            this.activeTab = ko.observable('#home');\n        }\n        var vm = new ViewModel();\n        ko.applyBindings(vm);\n        \n        $('a[data-toggle=\"tab\"]').on('shown.bs.tab', function (e) {\n            var target = $(e.target).attr(\"href\") // activated tab\n            vm.activeTab(target);\n            if (target === '#home') {\n                //console.log(vm.serializeDeckSettings(), vm.deckSettingsState, vm.serializeDeckSettings() !== vm.deckSettingsState);\n                if (vm.serializeDeckSettings() !== vm.deckSettingsState) {\n                    vm.updateDeck();\n                }\n            }\n            else {\n                clearTimeout(vm.autoPlayInterval);\n            }\n        });\n    //});\n};\nconsole.log('bundle.js');\nmodule.exports = App;",
    "var ko = (typeof window !== \"undefined\" ? window['ko'] : typeof global !== \"undefined\" ? global['ko'] : null);\n\n// Knockout checked binding doesn't work with Bootstrap checkboxes\nko.bindingHandlers.checkbox = {\n    init: function (element, valueAccessor) {\n        var $element = $(element),\n            handler = function (e) {\n            // we need to handle change event after bootsrap will handle its event\n            // to prevent incorrect changing of checkbox state\n            setTimeout(function () {\n                var $checkbox = $(e.target),\n                    value = valueAccessor(),\n                    data = $checkbox.val(),\n                    isChecked = $checkbox.parent().hasClass('active');\n                \n                if(!$checkbox.prop('disbled')) {\n                    if (ko.unwrap(value) instanceof Array) {\n                        var index = ko.utils.arrayIndexOf(ko.unwrap(value), (data));\n\n                        if (isChecked && (index === -1)) {\n                            value.push(data);\n                        } else if (!isChecked && (index !== -1)) {\n                            value.splice(index, 1);\n                        }\n                    } else {\n                        value(isChecked);\n                    }\n                }\n            }, 0);\n        };\n\n        if ($element.attr('data-toggle') === 'buttons' && $element.find('input:checkbox').length) {\n\n            if (!(ko.unwrap(valueAccessor()) instanceof Array)) {\n                throw new Error('checkbox binding should be used only with array or observableArray values in this case');\n            }\n\n            $element.on('change', 'input:checkbox', handler);\n        } else if ($element.attr('type') === 'checkbox') {\n\n            if (!ko.isObservable(valueAccessor())) {\n                throw new Error('checkbox binding should be used only with observable values in this case');\n            }\n\n            $element.on('change', handler);\n        } else {\n            throw new Error('checkbox binding should be used only with bootstrap checkboxes');\n        }\n    },\n\n    update: function (element, valueAccessor) {\n        var $element = $(element),\n            value = ko.unwrap(valueAccessor()),\n            isChecked;\n\n        if (value instanceof Array) {\n            if ($element.attr('data-toggle') === 'buttons') {\n                $element.find('input:checkbox').each(function (index, el) {\n                    isChecked = ko.utils.arrayIndexOf(value, el.value) !== -1;\n                    $(el).parent().toggleClass('active', isChecked);\n                    el.checked = isChecked;\n                });\n            } else {\n                isChecked = ko.utils.arrayIndexOf(value, $element.val()) !== -1;\n                $element.toggleClass('active', isChecked);\n                $element.find('input').prop('checked', isChecked);\n            }\n        } else {\n            isChecked = !!value;\n            $element.prop('checked', isChecked);\n            $element.parent().toggleClass('active', isChecked);\n        }\n    }\n};",
    "var ko = (typeof window !== \"undefined\" ? window['ko'] : typeof global !== \"undefined\" ? global['ko'] : null);\n\n// Knockout checked binding doesn't work with Bootstrap radio-buttons\nko.bindingHandlers.radio = {\n    init: function (element, valueAccessor) {\n\n        if (!ko.isObservable(valueAccessor())) {\n            throw new Error('radio binding should be used only with observable values');\n        }\n\n        $(element).on('change', 'input:radio', function (e) {\n            // we need to handle change event after bootsrap will handle its event\n            // to prevent incorrect changing of radio button styles\n            setTimeout(function() {\n                var radio = $(e.target),\n                    value = valueAccessor(),\n                    newValue = radio.val();\n\n                // we shouldn't change value for disables buttons\n                if (!radio.prop('disabled')) {\n                    value(newValue);\n                }\n            }, 0);\n        });\n    },\n\n    update: function (element, valueAccessor) {\n        var value = ko.unwrap(valueAccessor()) || '',\n            $radioButton = $(element).find('input[value=\"' + value.replace(/\"/g, '\\\\\"') + '\"]'),\n            $radioButtonWrapper;\n\n        if ($radioButton.length) {\n            $radioButtonWrapper = $radioButton.parent();\n\n            $radioButtonWrapper.siblings().removeClass('active');\n            $radioButtonWrapper.addClass('active');\n\n            $radioButton.prop('checked', true);\n        } else {\n            $radioButtonWrapper = $(element).find('.active');\n            $radioButtonWrapper.removeClass('active');\n            $radioButtonWrapper.find('input').prop('checked', false);\n        }\n    }\n};",
    "var ko = (typeof window !== \"undefined\" ? window['ko'] : typeof global !== \"undefined\" ? global['ko'] : null);\nvar URI = require('urijs');\nvar isString = require('lodash/isString');\nvar isUndefined = require('lodash/isUndefined');\n\nko.extenders.urlSync = function(target, options) {\n    if (isString(options)) {\n        options = {\n            param: options\n        };\n    }\n    else {\n        options = options || {};\n    }\n    options.read = options.read || function(value) {\n        return value;\n    };\n    options.write = options.write || function(value) {\n        return value;\n    };\n\n    if (isUndefined(options.param)) return target;\n\n    // retrieve from URI\n    var uri = new URI();\n    var paramValueQuery = uri.query(true)[options.param];\n    if (!isUndefined(paramValueQuery)) {\n        var readValue = options.read(paramValueQuery);\n        target(readValue);\n        uri.setSearch(options.param, options.write(readValue));\n        window.history.replaceState({}, \"\", uri.toString());\n    }\n\n    target.subscribe(function(newValue) {\n        var uri = new URI();\n        var writtenValue = options.write(newValue);\n        uri.setSearch(options.param, writtenValue);\n\n        // update hash\n        window.history.replaceState({}, \"\", uri.toString());\n    });\n    return target;\n};",
    "/*\n ResponsiveVoice JS v1.5.0\n\n (c) 2015-2016 LearnBrite\n\n License: http://responsivevoice.org/license\n*/\nif(\"undefined\"!=typeof responsiveVoice)console.log(\"ResponsiveVoice already loaded\"),console.log(responsiveVoice);else var ResponsiveVoice=function(){var a=this;a.version=\"1.5.0\";console.log(\"ResponsiveVoice r\"+a.version);a.responsivevoices=[{name:\"UK English Female\",flag:\"gb\",gender:\"f\",voiceIDs:[3,5,1,6,7,171,201,8]},{name:\"UK English Male\",flag:\"gb\",gender:\"m\",voiceIDs:[0,4,2,75,202,159,6,7]},{name:\"US English Female\",flag:\"us\",gender:\"f\",voiceIDs:[39,40,41,42,43,173,205,204,235,44]},{name:\"Arabic Male\",\nflag:\"ar\",gender:\"m\",voiceIDs:[96,95,97,196,98],deprecated:!0},{name:\"Arabic Female\",flag:\"ar\",gender:\"f\",voiceIDs:[96,95,97,196,98]},{name:\"Armenian Male\",flag:\"hy\",gender:\"f\",voiceIDs:[99]},{name:\"Australian Female\",flag:\"au\",gender:\"f\",voiceIDs:[87,86,5,201,88]},{name:\"Brazilian Portuguese Female\",flag:\"br\",gender:\"f\",voiceIDs:[245,124,123,125,186,223,126]},{name:\"Chinese Female\",flag:\"cn\",gender:\"f\",voiceIDs:[249,58,59,60,155,191,231,61]},{name:\"Chinese (Hong Kong) Female\",flag:\"hk\",gender:\"f\",\nvoiceIDs:[192,193,232,250,251,252]},{name:\"Chinese Taiwan Female\",flag:\"tw\",gender:\"f\",voiceIDs:[252,194,233,253,254,255]},{name:\"Czech Female\",flag:\"cz\",gender:\"f\",voiceIDs:[101,100,102,197,103]},{name:\"Danish Female\",flag:\"dk\",gender:\"f\",voiceIDs:[105,104,106,198,107]},{name:\"Deutsch Female\",flag:\"de\",gender:\"f\",voiceIDs:[27,28,29,30,31,78,170,199,32]},{name:\"Dutch Female\",flag:\"nl\",gender:\"f\",voiceIDs:[243,219,84,157,158,184,45]},{name:\"Finnish Female\",flag:\"fi\",gender:\"f\",voiceIDs:[90,89,91,209,\n92]},{name:\"French Female\",flag:\"fr\",gender:\"f\",voiceIDs:[240,21,22,23,77,178,210,26]},{name:\"Greek Female\",flag:\"gr\",gender:\"f\",voiceIDs:[62,63,80,200,64]},{name:\"Hatian Creole Female\",flag:\"ht\",gender:\"f\",voiceIDs:[109]},{name:\"Hindi Female\",flag:\"hi\",gender:\"f\",voiceIDs:[247,66,154,179,213,67]},{name:\"Hungarian Female\",flag:\"hu\",gender:\"f\",voiceIDs:[9,10,81,214,11]},{name:\"Indonesian Female\",flag:\"id\",gender:\"f\",voiceIDs:[241,111,112,180,215,113]},{name:\"Italian Female\",flag:\"it\",gender:\"f\",voiceIDs:[242,\n33,34,35,36,37,79,181,216,38]},{name:\"Japanese Female\",flag:\"jp\",gender:\"f\",voiceIDs:[248,50,51,52,153,182,217,53]},{name:\"Korean Female\",flag:\"kr\",gender:\"f\",voiceIDs:[54,55,56,156,183,218,57]},{name:\"Latin Female\",flag:\"va\",gender:\"f\",voiceIDs:[114]},{name:\"Norwegian Female\",flag:\"no\",gender:\"f\",voiceIDs:[72,73,221,74]},{name:\"Polish Female\",flag:\"pl\",gender:\"f\",voiceIDs:[244,120,119,121,185,222,122]},{name:\"Portuguese Female\",flag:\"br\",gender:\"f\",voiceIDs:[128,127,129,187,224,130]},{name:\"Romanian Male\",\nflag:\"ro\",gender:\"m\",voiceIDs:[151,150,152,225,46]},{name:\"Russian Female\",flag:\"ru\",gender:\"f\",voiceIDs:[246,47,48,83,188,226,49]},{name:\"Slovak Female\",flag:\"sk\",gender:\"f\",voiceIDs:[133,132,134,227,135]},{name:\"Spanish Female\",flag:\"es\",gender:\"f\",voiceIDs:[19,238,16,17,18,20,76,174,207,15]},{name:\"Spanish Latin American Female\",flag:\"es\",gender:\"f\",voiceIDs:[239,137,136,138,175,208,139]},{name:\"Swedish Female\",flag:\"sv\",gender:\"f\",voiceIDs:[85,148,149,228,65]},{name:\"Tamil Male\",flag:\"hi\",gender:\"m\",\nvoiceIDs:[141]},{name:\"Thai Female\",flag:\"th\",gender:\"f\",voiceIDs:[143,142,144,189,229,145]},{name:\"Turkish Female\",flag:\"tr\",gender:\"f\",voiceIDs:[69,70,82,190,230,71]},{name:\"Afrikaans Male\",flag:\"af\",gender:\"m\",voiceIDs:[93]},{name:\"Albanian Male\",flag:\"sq\",gender:\"m\",voiceIDs:[94]},{name:\"Bosnian Male\",flag:\"bs\",gender:\"m\",voiceIDs:[14]},{name:\"Catalan Male\",flag:\"catalonia\",gender:\"m\",voiceIDs:[68]},{name:\"Croatian Male\",flag:\"hr\",gender:\"m\",voiceIDs:[13]},{name:\"Czech Male\",flag:\"cz\",gender:\"m\",\nvoiceIDs:[161]},{name:\"Danish Male\",flag:\"da\",gender:\"m\",voiceIDs:[162],deprecated:!0},{name:\"Esperanto Male\",flag:\"eo\",gender:\"m\",voiceIDs:[108]},{name:\"Finnish Male\",flag:\"fi\",gender:\"m\",voiceIDs:[160],deprecated:!0},{name:\"Greek Male\",flag:\"gr\",gender:\"m\",voiceIDs:[163],deprecated:!0},{name:\"Hungarian Male\",flag:\"hu\",gender:\"m\",voiceIDs:[164]},{name:\"Icelandic Male\",flag:\"is\",gender:\"m\",voiceIDs:[110]},{name:\"Latin Male\",flag:\"va\",gender:\"m\",voiceIDs:[165],deprecated:!0},{name:\"Latvian Male\",flag:\"lv\",\ngender:\"m\",voiceIDs:[115]},{name:\"Macedonian Male\",flag:\"mk\",gender:\"m\",voiceIDs:[116]},{name:\"Moldavian Male\",flag:\"md\",gender:\"m\",voiceIDs:[117]},{name:\"Montenegrin Male\",flag:\"me\",gender:\"m\",voiceIDs:[118]},{name:\"Norwegian Male\",flag:\"no\",gender:\"m\",voiceIDs:[166]},{name:\"Serbian Male\",flag:\"sr\",gender:\"m\",voiceIDs:[12]},{name:\"Serbo-Croatian Male\",flag:\"hr\",gender:\"m\",voiceIDs:[131]},{name:\"Slovak Male\",flag:\"sk\",gender:\"m\",voiceIDs:[167],deprecated:!0},{name:\"Swahili Male\",flag:\"sw\",gender:\"m\",\nvoiceIDs:[140]},{name:\"Swedish Male\",flag:\"sv\",gender:\"m\",voiceIDs:[168],deprecated:!0},{name:\"Vietnamese Male\",flag:\"vi\",gender:\"m\",voiceIDs:[146],deprecated:!0},{name:\"Welsh Male\",flag:\"cy\",gender:\"m\",voiceIDs:[147]},{name:\"US English Male\",flag:\"us\",gender:\"m\",voiceIDs:[0,4,2,6,7,75,159,234,236,237]},{name:\"Fallback UK Female\",flag:\"gb\",gender:\"f\",voiceIDs:[8]}];a.voicecollection=[{name:\"Google UK English Male\"},{name:\"Agnes\"},{name:\"Daniel Compact\"},{name:\"Google UK English Female\"},{name:\"en-GB\",\nrate:.25,pitch:1},{name:\"en-AU\",rate:.25,pitch:1},{name:\"ingl\\u00e9s Reino Unido\"},{name:\"English United Kingdom\"},{name:\"Fallback en-GB Female\",lang:\"en-GB\",fallbackvoice:!0},{name:\"Eszter Compact\"},{name:\"hu-HU\",rate:.4},{name:\"Fallback Hungarian\",lang:\"hu\",fallbackvoice:!0,service:\"g2\"},{name:\"Fallback Serbian\",lang:\"sr\",fallbackvoice:!0},{name:\"Fallback Croatian\",lang:\"hr\",fallbackvoice:!0},{name:\"Fallback Bosnian\",lang:\"bs\",fallbackvoice:!0},{name:\"Fallback Spanish\",lang:\"es\",fallbackvoice:!0},\n{name:\"Spanish Spain\"},{name:\"espa\\u00f1ol Espa\\u00f1a\"},{name:\"Diego Compact\",rate:.3},{name:\"Google Espa\\u00f1ol\"},{name:\"es-ES\",rate:.2},{name:\"Google Fran\\u00e7ais\"},{name:\"French France\"},{name:\"franc\\u00e9s Francia\"},{name:\"Virginie Compact\",rate:.5},{name:\"fr-FR\",rate:.25},{name:\"Fallback French\",lang:\"fr\",fallbackvoice:!0},{name:\"Google Deutsch\"},{name:\"German Germany\"},{name:\"alem\\u00e1n Alemania\"},{name:\"Yannick Compact\",rate:.5},{name:\"de-DE\",rate:.25},{name:\"Fallback Deutsch\",lang:\"de\",\nfallbackvoice:!0},{name:\"Google Italiano\"},{name:\"Italian Italy\"},{name:\"italiano Italia\"},{name:\"Paolo Compact\",rate:.5},{name:\"it-IT\",rate:.25},{name:\"Fallback Italian\",lang:\"it\",fallbackvoice:!0},{name:\"Google US English\",timerSpeed:1},{name:\"English United States\"},{name:\"ingl\\u00e9s Estados Unidos\"},{name:\"Vicki\"},{name:\"en-US\",rate:.2,pitch:1,timerSpeed:1.3},{name:\"Fallback English\",lang:\"en-US\",fallbackvoice:!0,timerSpeed:0},{name:\"Fallback Dutch\",lang:\"nl\",fallbackvoice:!0,timerSpeed:0},{name:\"Fallback Romanian\",\nlang:\"ro\",fallbackvoice:!0},{name:\"Milena Compact\"},{name:\"ru-RU\",rate:.25},{name:\"Fallback Russian\",lang:\"ru\",fallbackvoice:!0},{name:\"Google \\u65e5\\u672c\\u4eba\",timerSpeed:1},{name:\"Kyoko Compact\"},{name:\"ja-JP\",rate:.25},{name:\"Fallback Japanese\",lang:\"ja\",fallbackvoice:!0},{name:\"Google \\ud55c\\uad6d\\uc758\",timerSpeed:1},{name:\"Narae Compact\"},{name:\"ko-KR\",rate:.25},{name:\"Fallback Korean\",lang:\"ko\",fallbackvoice:!0},{name:\"Google \\u4e2d\\u56fd\\u7684\",timerSpeed:1},{name:\"Ting-Ting Compact\"},{name:\"zh-CN\",\nrate:.25},{name:\"Fallback Chinese\",lang:\"zh-CN\",fallbackvoice:!0},{name:\"Alexandros Compact\"},{name:\"el-GR\",rate:.25},{name:\"Fallback Greek\",lang:\"el\",fallbackvoice:!0,service:\"g2\"},{name:\"Fallback Swedish\",lang:\"sv\",fallbackvoice:!0,service:\"g2\"},{name:\"hi-IN\",rate:.25},{name:\"Fallback Hindi\",lang:\"hi\",fallbackvoice:!0},{name:\"Fallback Catalan\",lang:\"ca\",fallbackvoice:!0},{name:\"Aylin Compact\"},{name:\"tr-TR\",rate:.25},{name:\"Fallback Turkish\",lang:\"tr\",fallbackvoice:!0},{name:\"Stine Compact\"},{name:\"no-NO\",\nrate:.25},{name:\"Fallback Norwegian\",lang:\"no\",fallbackvoice:!0,service:\"g2\"},{name:\"Daniel\"},{name:\"Monica\"},{name:\"Amelie\"},{name:\"Anna\"},{name:\"Alice\"},{name:\"Melina\"},{name:\"Mariska\"},{name:\"Yelda\"},{name:\"Milena\"},{name:\"Xander\"},{name:\"Alva\"},{name:\"Lee Compact\"},{name:\"Karen\"},{name:\"Fallback Australian\",lang:\"en-AU\",fallbackvoice:!0},{name:\"Mikko Compact\"},{name:\"Satu\"},{name:\"fi-FI\",rate:.25},{name:\"Fallback Finnish\",lang:\"fi\",fallbackvoice:!0,service:\"g2\"},{name:\"Fallback Afrikans\",lang:\"af\",\nfallbackvoice:!0},{name:\"Fallback Albanian\",lang:\"sq\",fallbackvoice:!0},{name:\"Maged Compact\"},{name:\"Tarik\"},{name:\"ar-SA\",rate:.25},{name:\"Fallback Arabic\",lang:\"ar\",fallbackvoice:!0,service:\"g2\"},{name:\"Fallback Armenian\",lang:\"hy\",fallbackvoice:!0,service:\"g2\"},{name:\"Zuzana Compact\"},{name:\"Zuzana\"},{name:\"cs-CZ\",rate:.25},{name:\"Fallback Czech\",lang:\"cs\",fallbackvoice:!0,service:\"g2\"},{name:\"Ida Compact\"},{name:\"Sara\"},{name:\"da-DK\",rate:.25},{name:\"Fallback Danish\",lang:\"da\",fallbackvoice:!0,\nservice:\"g2\"},{name:\"Fallback Esperanto\",lang:\"eo\",fallbackvoice:!0},{name:\"Fallback Hatian Creole\",lang:\"ht\",fallbackvoice:!0},{name:\"Fallback Icelandic\",lang:\"is\",fallbackvoice:!0},{name:\"Damayanti\"},{name:\"id-ID\",rate:.25},{name:\"Fallback Indonesian\",lang:\"id\",fallbackvoice:!0},{name:\"Fallback Latin\",lang:\"la\",fallbackvoice:!0,service:\"g2\"},{name:\"Fallback Latvian\",lang:\"lv\",fallbackvoice:!0},{name:\"Fallback Macedonian\",lang:\"mk\",fallbackvoice:!0},{name:\"Fallback Moldavian\",lang:\"mo\",fallbackvoice:!0,\nservice:\"g2\"},{name:\"Fallback Montenegrin\",lang:\"sr-ME\",fallbackvoice:!0},{name:\"Agata Compact\"},{name:\"Zosia\"},{name:\"pl-PL\",rate:.25},{name:\"Fallback Polish\",lang:\"pl\",fallbackvoice:!0},{name:\"Raquel Compact\"},{name:\"Luciana\"},{name:\"pt-BR\",rate:.25},{name:\"Fallback Brazilian Portugese\",lang:\"pt-BR\",fallbackvoice:!0,service:\"g2\"},{name:\"Joana Compact\"},{name:\"Joana\"},{name:\"pt-PT\",rate:.25},{name:\"Fallback Portuguese\",lang:\"pt-PT\",fallbackvoice:!0},{name:\"Fallback Serbo-Croation\",lang:\"sh\",fallbackvoice:!0,\nservice:\"g2\"},{name:\"Laura Compact\"},{name:\"Laura\"},{name:\"sk-SK\",rate:.25},{name:\"Fallback Slovak\",lang:\"sk\",fallbackvoice:!0,service:\"g2\"},{name:\"Javier Compact\"},{name:\"Paulina\"},{name:\"es-MX\",rate:.25},{name:\"Fallback Spanish (Latin American)\",lang:\"es-419\",fallbackvoice:!0,service:\"g2\"},{name:\"Fallback Swahili\",lang:\"sw\",fallbackvoice:!0},{name:\"Fallback Tamil\",lang:\"ta\",fallbackvoice:!0},{name:\"Narisa Compact\"},{name:\"Kanya\"},{name:\"th-TH\",rate:.25},{name:\"Fallback Thai\",lang:\"th\",fallbackvoice:!0},\n{name:\"Fallback Vietnamese\",lang:\"vi\",fallbackvoice:!0},{name:\"Fallback Welsh\",lang:\"cy\",fallbackvoice:!0},{name:\"Oskar Compact\"},{name:\"sv-SE\",rate:.25},{name:\"Simona Compact\"},{name:\"Ioana\"},{name:\"ro-RO\",rate:.25},{name:\"Kyoko\"},{name:\"Lekha\"},{name:\"Ting-Ting\"},{name:\"Yuna\"},{name:\"Xander Compact\"},{name:\"nl-NL\",rate:.25},{name:\"Fallback UK English Male\",lang:\"en-GB\",fallbackvoice:!0,service:\"g1\",voicename:\"rjs\"},{name:\"Finnish Male\",lang:\"fi\",fallbackvoice:!0,service:\"g1\",voicename:\"\"},{name:\"Czech Male\",\nlang:\"cs\",fallbackvoice:!0,service:\"g1\",voicename:\"\"},{name:\"Danish Male\",lang:\"da\",fallbackvoice:!0,service:\"g1\",voicename:\"\"},{name:\"Greek Male\",lang:\"el\",fallbackvoice:!0,service:\"g1\",voicename:\"\",rate:.25},{name:\"Hungarian Male\",lang:\"hu\",fallbackvoice:!0,service:\"g1\",voicename:\"\"},{name:\"Latin Male\",lang:\"la\",fallbackvoice:!0,service:\"g1\",voicename:\"\"},{name:\"Norwegian Male\",lang:\"no\",fallbackvoice:!0,service:\"g1\",voicename:\"\"},{name:\"Slovak Male\",lang:\"sk\",fallbackvoice:!0,service:\"g1\",voicename:\"\"},\n{name:\"Swedish Male\",lang:\"sv\",fallbackvoice:!0,service:\"g1\",voicename:\"\"},{name:\"Fallback US English Male\",lang:\"en\",fallbackvoice:!0,service:\"tts-api\",voicename:\"\"},{name:\"German Germany\",lang:\"de_DE\"},{name:\"English United Kingdom\",lang:\"en_GB\"},{name:\"English India\",lang:\"en_IN\"},{name:\"English United States\",lang:\"en_US\"},{name:\"Spanish Spain\",lang:\"es_ES\"},{name:\"Spanish Mexico\",lang:\"es_MX\"},{name:\"Spanish United States\",lang:\"es_US\"},{name:\"French Belgium\",lang:\"fr_BE\"},{name:\"French France\",\nlang:\"fr_FR\"},{name:\"Hindi India\",lang:\"hi_IN\"},{name:\"Indonesian Indonesia\",lang:\"in_ID\"},{name:\"Italian Italy\",lang:\"it_IT\"},{name:\"Japanese Japan\",lang:\"ja_JP\"},{name:\"Korean South Korea\",lang:\"ko_KR\"},{name:\"Dutch Netherlands\",lang:\"nl_NL\"},{name:\"Polish Poland\",lang:\"pl_PL\"},{name:\"Portuguese Brazil\",lang:\"pt_BR\"},{name:\"Portuguese Portugal\",lang:\"pt_PT\"},{name:\"Russian Russia\",lang:\"ru_RU\"},{name:\"Thai Thailand\",lang:\"th_TH\"},{name:\"Turkish Turkey\",lang:\"tr_TR\"},{name:\"Chinese China\",lang:\"zh_CN_#Hans\"},\n{name:\"Chinese Hong Kong\",lang:\"zh_HK_#Hans\"},{name:\"Chinese Hong Kong\",lang:\"zh_HK_#Hant\"},{name:\"Chinese Taiwan\",lang:\"zh_TW_#Hant\"},{name:\"Alex\"},{name:\"Maged\",lang:\"ar-SA\"},{name:\"Zuzana\",lang:\"cs-CZ\"},{name:\"Sara\",lang:\"da-DK\"},{name:\"Anna\",lang:\"de-DE\"},{name:\"Melina\",lang:\"el-GR\"},{name:\"Karen\",lang:\"en-AU\"},{name:\"Daniel\",lang:\"en-GB\"},{name:\"Moira\",lang:\"en-IE\"},{name:\"Samantha (Enhanced)\",lang:\"en-US\"},{name:\"Samantha\",lang:\"en-US\"},{name:\"Tessa\",lang:\"en-ZA\"},{name:\"Monica\",lang:\"es-ES\"},\n{name:\"Paulina\",lang:\"es-MX\"},{name:\"Satu\",lang:\"fi-FI\"},{name:\"Amelie\",lang:\"fr-CA\"},{name:\"Thomas\",lang:\"fr-FR\"},{name:\"Carmit\",lang:\"he-IL\"},{name:\"Lekha\",lang:\"hi-IN\"},{name:\"Mariska\",lang:\"hu-HU\"},{name:\"Damayanti\",lang:\"id-ID\"},{name:\"Alice\",lang:\"it-IT\"},{name:\"Kyoko\",lang:\"ja-JP\"},{name:\"Yuna\",lang:\"ko-KR\"},{name:\"Ellen\",lang:\"nl-BE\"},{name:\"Xander\",lang:\"nl-NL\"},{name:\"Nora\",lang:\"no-NO\"},{name:\"Zosia\",lang:\"pl-PL\"},{name:\"Luciana\",lang:\"pt-BR\"},{name:\"Joana\",lang:\"pt-PT\"},{name:\"Ioana\",\nlang:\"ro-RO\"},{name:\"Milena\",lang:\"ru-RU\"},{name:\"Laura\",lang:\"sk-SK\"},{name:\"Alva\",lang:\"sv-SE\"},{name:\"Kanya\",lang:\"th-TH\"},{name:\"Yelda\",lang:\"tr-TR\"},{name:\"Ting-Ting\",lang:\"zh-CN\"},{name:\"Sin-Ji\",lang:\"zh-HK\"},{name:\"Mei-Jia\",lang:\"zh-TW\"},{name:\"Microsoft David Mobile - English (United States)\",lang:\"en-US\"},{name:\"Microsoft Zira Mobile - English (United States)\",lang:\"en-US\"},{name:\"Microsoft Mark Mobile - English (United States)\",lang:\"en-US\"},{name:\"native\",lang:\"\"},{name:\"Google espa\\u00f1ol\"},\n{name:\"Google espa\\u00f1ol de Estados Unidos\"},{name:\"Google fran\\u00e7ais\"},{name:\"Google Bahasa Indonesia\"},{name:\"Google italiano\"},{name:\"Google Nederlands\"},{name:\"Google polski\"},{name:\"Google portugu\\u00eas do Brasil\"},{name:\"Google \\u0440\\u0443\\u0441\\u0441\\u043a\\u0438\\u0439\"},{name:\"Google \\u0939\\u093f\\u0928\\u094d\\u0926\\u0940\"},{name:\"Google \\u65e5\\u672c\\u8a9e\"},{name:\"Google \\u666e\\u901a\\u8bdd\\uff08\\u4e2d\\u56fd\\u5927\\u9646\\uff09\"},{name:\"Google \\u7ca4\\u8a9e\\uff08\\u9999\\u6e2f\\uff09\"},{name:\"zh-HK\",\nrate:.25},{name:\"Fallback Chinese (Hong Kong) Female\",lang:\"zh-HK\",fallbackvoice:!0,service:\"g1\"},{name:\"Google \\u7ca4\\u8a9e\\uff08\\u9999\\u6e2f\\uff09\"},{name:\"zh-TW\",rate:.25},{name:\"Fallback Chinese (Taiwan) Female\",lang:\"zh-TW\",fallbackvoice:!0,service:\"g1\"}];a.iOS=/(iPad|iPhone|iPod)/g.test(navigator.userAgent);a.iOS9=/(iphone|ipod|ipad).* os 9_/.test(navigator.userAgent.toLowerCase())||/(iphone|ipod|ipad).* os 10_/.test(navigator.userAgent.toLowerCase());a.is_chrome=-1<navigator.userAgent.indexOf(\"Chrome\");\na.is_safari=-1<navigator.userAgent.indexOf(\"Safari\");a.is_chrome&&a.is_safari&&(a.is_safari=!1);a.is_opera=!!window.opera||0<=navigator.userAgent.indexOf(\" OPR/\");a.is_android=-1<navigator.userAgent.toLowerCase().indexOf(\"android\");a.iOS_initialized=!1;a.iOS9_initialized=!1;a.cache_ios_voices=[{name:\"he-IL\",voiceURI:\"he-IL\",lang:\"he-IL\"},{name:\"th-TH\",voiceURI:\"th-TH\",lang:\"th-TH\"},{name:\"pt-BR\",voiceURI:\"pt-BR\",lang:\"pt-BR\"},{name:\"sk-SK\",voiceURI:\"sk-SK\",lang:\"sk-SK\"},{name:\"fr-CA\",voiceURI:\"fr-CA\",\nlang:\"fr-CA\"},{name:\"ro-RO\",voiceURI:\"ro-RO\",lang:\"ro-RO\"},{name:\"no-NO\",voiceURI:\"no-NO\",lang:\"no-NO\"},{name:\"fi-FI\",voiceURI:\"fi-FI\",lang:\"fi-FI\"},{name:\"pl-PL\",voiceURI:\"pl-PL\",lang:\"pl-PL\"},{name:\"de-DE\",voiceURI:\"de-DE\",lang:\"de-DE\"},{name:\"nl-NL\",voiceURI:\"nl-NL\",lang:\"nl-NL\"},{name:\"id-ID\",voiceURI:\"id-ID\",lang:\"id-ID\"},{name:\"tr-TR\",voiceURI:\"tr-TR\",lang:\"tr-TR\"},{name:\"it-IT\",voiceURI:\"it-IT\",lang:\"it-IT\"},{name:\"pt-PT\",voiceURI:\"pt-PT\",lang:\"pt-PT\"},{name:\"fr-FR\",voiceURI:\"fr-FR\",lang:\"fr-FR\"},\n{name:\"ru-RU\",voiceURI:\"ru-RU\",lang:\"ru-RU\"},{name:\"es-MX\",voiceURI:\"es-MX\",lang:\"es-MX\"},{name:\"zh-HK\",voiceURI:\"zh-HK\",lang:\"zh-HK\"},{name:\"sv-SE\",voiceURI:\"sv-SE\",lang:\"sv-SE\"},{name:\"hu-HU\",voiceURI:\"hu-HU\",lang:\"hu-HU\"},{name:\"zh-TW\",voiceURI:\"zh-TW\",lang:\"zh-TW\"},{name:\"es-ES\",voiceURI:\"es-ES\",lang:\"es-ES\"},{name:\"zh-CN\",voiceURI:\"zh-CN\",lang:\"zh-CN\"},{name:\"nl-BE\",voiceURI:\"nl-BE\",lang:\"nl-BE\"},{name:\"en-GB\",voiceURI:\"en-GB\",lang:\"en-GB\"},{name:\"ar-SA\",voiceURI:\"ar-SA\",lang:\"ar-SA\"},{name:\"ko-KR\",\nvoiceURI:\"ko-KR\",lang:\"ko-KR\"},{name:\"cs-CZ\",voiceURI:\"cs-CZ\",lang:\"cs-CZ\"},{name:\"en-ZA\",voiceURI:\"en-ZA\",lang:\"en-ZA\"},{name:\"en-AU\",voiceURI:\"en-AU\",lang:\"en-AU\"},{name:\"da-DK\",voiceURI:\"da-DK\",lang:\"da-DK\"},{name:\"en-US\",voiceURI:\"en-US\",lang:\"en-US\"},{name:\"en-IE\",voiceURI:\"en-IE\",lang:\"en-IE\"},{name:\"hi-IN\",voiceURI:\"hi-IN\",lang:\"hi-IN\"},{name:\"el-GR\",voiceURI:\"el-GR\",lang:\"el-GR\"},{name:\"ja-JP\",voiceURI:\"ja-JP\",lang:\"ja-JP\"}];a.cache_ios9_voices=[{name:\"Maged\",voiceURI:\"com.apple.ttsbundle.Maged-compact\",\nlang:\"ar-SA\",localService:!0,\"default\":!0},{name:\"Zuzana\",voiceURI:\"com.apple.ttsbundle.Zuzana-compact\",lang:\"cs-CZ\",localService:!0,\"default\":!0},{name:\"Sara\",voiceURI:\"com.apple.ttsbundle.Sara-compact\",lang:\"da-DK\",localService:!0,\"default\":!0},{name:\"Anna\",voiceURI:\"com.apple.ttsbundle.Anna-compact\",lang:\"de-DE\",localService:!0,\"default\":!0},{name:\"Melina\",voiceURI:\"com.apple.ttsbundle.Melina-compact\",lang:\"el-GR\",localService:!0,\"default\":!0},{name:\"Karen\",voiceURI:\"com.apple.ttsbundle.Karen-compact\",\nlang:\"en-AU\",localService:!0,\"default\":!0},{name:\"Daniel\",voiceURI:\"com.apple.ttsbundle.Daniel-compact\",lang:\"en-GB\",localService:!0,\"default\":!0},{name:\"Moira\",voiceURI:\"com.apple.ttsbundle.Moira-compact\",lang:\"en-IE\",localService:!0,\"default\":!0},{name:\"Samantha (Enhanced)\",voiceURI:\"com.apple.ttsbundle.Samantha-premium\",lang:\"en-US\",localService:!0,\"default\":!0},{name:\"Samantha\",voiceURI:\"com.apple.ttsbundle.Samantha-compact\",lang:\"en-US\",localService:!0,\"default\":!0},{name:\"Tessa\",voiceURI:\"com.apple.ttsbundle.Tessa-compact\",\nlang:\"en-ZA\",localService:!0,\"default\":!0},{name:\"Monica\",voiceURI:\"com.apple.ttsbundle.Monica-compact\",lang:\"es-ES\",localService:!0,\"default\":!0},{name:\"Paulina\",voiceURI:\"com.apple.ttsbundle.Paulina-compact\",lang:\"es-MX\",localService:!0,\"default\":!0},{name:\"Satu\",voiceURI:\"com.apple.ttsbundle.Satu-compact\",lang:\"fi-FI\",localService:!0,\"default\":!0},{name:\"Amelie\",voiceURI:\"com.apple.ttsbundle.Amelie-compact\",lang:\"fr-CA\",localService:!0,\"default\":!0},{name:\"Thomas\",voiceURI:\"com.apple.ttsbundle.Thomas-compact\",\nlang:\"fr-FR\",localService:!0,\"default\":!0},{name:\"Carmit\",voiceURI:\"com.apple.ttsbundle.Carmit-compact\",lang:\"he-IL\",localService:!0,\"default\":!0},{name:\"Lekha\",voiceURI:\"com.apple.ttsbundle.Lekha-compact\",lang:\"hi-IN\",localService:!0,\"default\":!0},{name:\"Mariska\",voiceURI:\"com.apple.ttsbundle.Mariska-compact\",lang:\"hu-HU\",localService:!0,\"default\":!0},{name:\"Damayanti\",voiceURI:\"com.apple.ttsbundle.Damayanti-compact\",lang:\"id-ID\",localService:!0,\"default\":!0},{name:\"Alice\",voiceURI:\"com.apple.ttsbundle.Alice-compact\",\nlang:\"it-IT\",localService:!0,\"default\":!0},{name:\"Kyoko\",voiceURI:\"com.apple.ttsbundle.Kyoko-compact\",lang:\"ja-JP\",localService:!0,\"default\":!0},{name:\"Yuna\",voiceURI:\"com.apple.ttsbundle.Yuna-compact\",lang:\"ko-KR\",localService:!0,\"default\":!0},{name:\"Ellen\",voiceURI:\"com.apple.ttsbundle.Ellen-compact\",lang:\"nl-BE\",localService:!0,\"default\":!0},{name:\"Xander\",voiceURI:\"com.apple.ttsbundle.Xander-compact\",lang:\"nl-NL\",localService:!0,\"default\":!0},{name:\"Nora\",voiceURI:\"com.apple.ttsbundle.Nora-compact\",\nlang:\"no-NO\",localService:!0,\"default\":!0},{name:\"Zosia\",voiceURI:\"com.apple.ttsbundle.Zosia-compact\",lang:\"pl-PL\",localService:!0,\"default\":!0},{name:\"Luciana\",voiceURI:\"com.apple.ttsbundle.Luciana-compact\",lang:\"pt-BR\",localService:!0,\"default\":!0},{name:\"Joana\",voiceURI:\"com.apple.ttsbundle.Joana-compact\",lang:\"pt-PT\",localService:!0,\"default\":!0},{name:\"Ioana\",voiceURI:\"com.apple.ttsbundle.Ioana-compact\",lang:\"ro-RO\",localService:!0,\"default\":!0},{name:\"Milena\",voiceURI:\"com.apple.ttsbundle.Milena-compact\",\nlang:\"ru-RU\",localService:!0,\"default\":!0},{name:\"Laura\",voiceURI:\"com.apple.ttsbundle.Laura-compact\",lang:\"sk-SK\",localService:!0,\"default\":!0},{name:\"Alva\",voiceURI:\"com.apple.ttsbundle.Alva-compact\",lang:\"sv-SE\",localService:!0,\"default\":!0},{name:\"Kanya\",voiceURI:\"com.apple.ttsbundle.Kanya-compact\",lang:\"th-TH\",localService:!0,\"default\":!0},{name:\"Yelda\",voiceURI:\"com.apple.ttsbundle.Yelda-compact\",lang:\"tr-TR\",localService:!0,\"default\":!0},{name:\"Ting-Ting\",voiceURI:\"com.apple.ttsbundle.Ting-Ting-compact\",\nlang:\"zh-CN\",localService:!0,\"default\":!0},{name:\"Sin-Ji\",voiceURI:\"com.apple.ttsbundle.Sin-Ji-compact\",lang:\"zh-HK\",localService:!0,\"default\":!0},{name:\"Mei-Jia\",voiceURI:\"com.apple.ttsbundle.Mei-Jia-compact\",lang:\"zh-TW\",localService:!0,\"default\":!0}];a.systemvoices=null;a.CHARACTER_LIMIT=100;a.VOICESUPPORT_ATTEMPTLIMIT=5;a.voicesupport_attempts=0;a.fallbackMode=!1;a.WORDS_PER_MINUTE=130;a.fallback_parts=null;a.fallback_part_index=0;a.fallback_audio=null;a.fallback_playbackrate=1;a.def_fallback_playbackrate=\na.fallback_playbackrate;a.fallback_audiopool=[];a.msgparameters=null;a.timeoutId=null;a.OnLoad_callbacks=[];a.useTimer=!1;a.utterances=[];a.tstCompiled=function(a){return eval(\"typeof xy === 'undefined'\")};a.fallbackServicePath=\"https://code.responsivevoice.org/\"+(a.tstCompiled()?\"\":\"develop/\")+\"getvoice.php\";a.default_rv=a.responsivevoices[0];a.debug=!1;a.log=function(b){a.debug&&console.log(b)};a.init=function(){a.is_android&&(a.useTimer=!0);a.is_opera||\"undefined\"===typeof speechSynthesis?(console.log(\"RV: Voice synthesis not supported\"),\na.enableFallbackMode()):setTimeout(function(){var b=setInterval(function(){var c=window.speechSynthesis.getVoices();0!=c.length||null!=a.systemvoices&&0!=a.systemvoices.length?(console.log(\"RV: Voice support ready\"),a.systemVoicesReady(c),clearInterval(b)):(console.log(\"Voice support NOT ready\"),a.voicesupport_attempts++,a.voicesupport_attempts>a.VOICESUPPORT_ATTEMPTLIMIT&&(clearInterval(b),null!=window.speechSynthesis?a.iOS?(a.iOS9?a.systemVoicesReady(a.cache_ios9_voices):a.systemVoicesReady(a.cache_ios_voices),\nconsole.log(\"RV: Voice support ready (cached)\")):(console.log(\"RV: speechSynthesis present but no system voices found\"),a.enableFallbackMode()):a.enableFallbackMode()))},100)},100);a.Dispatch(\"OnLoad\")};a.systemVoicesReady=function(b){a.systemvoices=b;a.mapRVs();null!=a.OnVoiceReady&&a.OnVoiceReady.call();a.Dispatch(\"OnReady\");window.hasOwnProperty(\"dispatchEvent\")&&window.dispatchEvent(new Event(\"ResponsiveVoice_OnReady\"))};a.enableFallbackMode=function(){a.fallbackMode=!0;console.log(\"RV: Enabling fallback mode\");\na.mapRVs();null!=a.OnVoiceReady&&a.OnVoiceReady.call();a.Dispatch(\"OnReady\");window.hasOwnProperty(\"dispatchEvent\")&&window.dispatchEvent(new Event(\"ResponsiveVoice_OnReady\"))};a.getVoices=function(){for(var b=[],c=0;c<a.responsivevoices.length;c++)b.push({name:a.responsivevoices[c].name});return b};a.speak=function(b,c,e){if(a.iOS9&&!a.iOS9_initialized)a.log(\"Initializing ios9\"),setTimeout(function(){a.speak(b,c,e)},100),a.clickEvent(),a.iOS9_initialized=!0;else{a.isPlaying()&&(a.log(\"Cancelling previous speech\"),\na.cancel());a.fallbackMode&&0<a.fallback_audiopool.length&&a.clearFallbackPool();b=b.replace(/[\\\"\\`]/gm,\"'\");a.msgparameters=e||{};a.msgtext=b;a.msgvoicename=c;a.onstartFired=!1;var h=[];if(b.length>a.CHARACTER_LIMIT){for(var f=b;f.length>a.CHARACTER_LIMIT;){var g=f.search(/[:!?.;]+/),d=\"\";if(-1==g||g>=a.CHARACTER_LIMIT)g=f.search(/[,]+/);-1==g&&-1==f.search(\" \")&&(g=99);if(-1==g||g>=a.CHARACTER_LIMIT)for(var k=f.split(\" \"),g=0;g<k.length&&!(d.length+k[g].length+1>a.CHARACTER_LIMIT);g++)d+=(0!=g?\n\" \":\"\")+k[g];else d=f.substr(0,g+1);f=f.substr(d.length,f.length-d.length);h.push(d)}0<f.length&&h.push(f)}else h.push(b);a.multipartText=h;g=null==c?a.default_rv:a.getResponsiveVoice(c);!0===g.deprecated&&console.warn(\"ResponsiveVoice: Voice \"+g.name+\" is deprecated and will be removed in future releases\");f={};if(null!=g.mappedProfile)f=g.mappedProfile;else if(f.systemvoice=a.getMatchedVoice(g),f.collectionvoice={},null==f.systemvoice){console.log(\"RV: ERROR: No voice found for: \"+c);return}a.msgprofile=\nf;a.utterances=[];for(g=0;g<h.length;g++)if(a.fallbackMode){a.fallback_playbackrate=a.def_fallback_playbackrate;var d=a.selectBest([f.collectionvoice.pitch,f.systemvoice.pitch,1]),k=a.selectBest([a.iOS9?1:null,f.collectionvoice.rate,f.systemvoice.rate,1]),l=a.selectBest([f.collectionvoice.volume,f.systemvoice.volume,1]),m;null!=e&&(d*=null!=e.pitch?e.pitch:1,k*=null!=e.rate?e.rate:1,l*=null!=e.volume?e.volume:1,m=e.extraParams||null);d/=2;k/=2;l*=2;d=Math.min(Math.max(d,0),1);k=Math.min(Math.max(k,\n0),1);l=Math.min(Math.max(l,0),1);d=a.fallbackServicePath+\"?t=\"+encodeURIComponent(h[g])+\"&tl=\"+(f.collectionvoice.lang||f.systemvoice.lang||\"en-US\")+\"&sv=\"+(f.collectionvoice.service||f.systemvoice.service||\"\")+\"&vn=\"+(f.collectionvoice.voicename||f.systemvoice.voicename||\"\")+\"&pitch=\"+d.toString()+\"&rate=\"+k.toString()+\"&vol=\"+l.toString();m&&(d+=\"&extraParams=\"+JSON.stringify(m));k=document.createElement(\"AUDIO\");k.src=d;k.playbackRate=a.fallback_playbackrate;k.preload=\"auto\";k.load();a.fallback_parts.push(k)}else a.log(\"Using SpeechSynthesis\"),\nd=new SpeechSynthesisUtterance,d.voiceURI=f.systemvoice.voiceURI,d.volume=a.selectBest([f.collectionvoice.volume,f.systemvoice.volume,1]),d.rate=a.selectBest([a.iOS9?1:null,f.collectionvoice.rate,f.systemvoice.rate,1]),d.pitch=a.selectBest([f.collectionvoice.pitch,f.systemvoice.pitch,1]),d.text=h[g],d.lang=a.selectBest([f.collectionvoice.lang,f.systemvoice.lang]),d.rvIndex=g,d.rvTotal=h.length,0==g&&(d.onstart=a.speech_onstart),a.msgparameters.onendcalled=!1,null!=e?(d.voice=\"undefined\"!==typeof e.voice?\ne.voice:f.systemvoice,g<h.length-1&&1<h.length?(d.onend=a.onPartEnd,d.hasOwnProperty(\"addEventListener\")&&d.addEventListener(\"end\",a.onPartEnd)):(d.onend=a.speech_onend,d.hasOwnProperty(\"addEventListener\")&&d.addEventListener(\"end\",a.speech_onend)),d.onerror=e.onerror||function(b){a.log(\"RV: Unknow Error\");a.log(b)},d.onpause=e.onpause,d.onresume=e.onresume,d.onmark=e.onmark,d.onboundary=e.onboundary||a.onboundary,d.pitch=null!=e.pitch?e.pitch:d.pitch,d.rate=a.iOS?(null!=e.rate?e.rate*e.rate:1)*d.rate:\n(null!=e.rate?e.rate:1)*d.rate,d.volume=null!=e.volume?e.volume:d.volume):(a.log(\"No Params received for current Utterance\"),d.voice=f.systemvoice,d.onend=a.speech_onend,d.onboundary=a.onboundary,d.onerror=function(b){a.log(\"RV: Unknow Error\");a.log(b)}),a.utterances.push(d),0==g&&(a.currentMsg=d),console.log(d),a.tts_speak(d);a.fallbackMode&&(a.fallback_part_index=0,a.fallback_startPart())}};a.startTimeout=function(b,c){var e=a.msgprofile.collectionvoice.timerSpeed;null==a.msgprofile.collectionvoice.timerSpeed&&\n(e=1);0>=e||(a.timeoutId=setTimeout(c,a.getEstimatedTimeLength(b,e)),a.log(\"Timeout ID: \"+a.timeoutId))};a.checkAndCancelTimeout=function(){null!=a.timeoutId&&(clearTimeout(a.timeoutId),a.timeoutId=null)};a.speech_timedout=function(){a.cancel();a.cancelled=!1;a.speech_onend()};a.speech_onend=function(){a.checkAndCancelTimeout();!0===a.cancelled?a.cancelled=!1:(a.log(\"on end fired\"),null!=a.msgparameters&&null!=a.msgparameters.onend&&1!=a.msgparameters.onendcalled&&(a.log(\"Speech on end called  -\"+\na.msgtext),a.msgparameters.onendcalled=!0,a.msgparameters.onend()))};a.speech_onstart=function(){if(!a.onstartFired){a.onstartFired=!0;a.log(\"Speech start\");if(a.iOS||a.is_safari||a.useTimer)a.fallbackMode||a.startTimeout(a.msgtext,a.speech_timedout);a.msgparameters.onendcalled=!1;if(null!=a.msgparameters&&null!=a.msgparameters.onstart)a.msgparameters.onstart()}};a.fallback_startPart=function(){0==a.fallback_part_index&&a.speech_onstart();a.fallback_audio=a.fallback_parts[a.fallback_part_index];if(null==\na.fallback_audio)a.log(\"RV: Fallback Audio is not available\");else{var b=a.fallback_audio;a.fallback_audiopool.push(b);setTimeout(function(){b.playbackRate=a.fallback_playbackrate},50);b.onloadedmetadata=function(){b.play();b.playbackRate=a.fallback_playbackrate};a.fallback_errors&&(a.log(\"RV: Speech cancelled due to errors\"),a.speech_onend());a.fallback_audio.play();a.fallback_audio.addEventListener(\"ended\",a.fallback_finishPart);a.useTimer&&a.startTimeout(a.multipartText[a.fallback_part_index],\na.fallback_finishPart)}};a.isFallbackAudioPlaying=function(){var b;for(b=0;b<a.fallback_audiopool.length;b++)if(!a.fallback_audiopool[b].paused)return!0;return!1};a.fallback_finishPart=function(b){a.isFallbackAudioPlaying()?(a.checkAndCancelTimeout(),a.timeoutId=setTimeout(a.fallback_finishPart,1E3*(a.fallback_audio.duration-a.fallback_audio.currentTime))):(a.checkAndCancelTimeout(),a.fallback_part_index<a.fallback_parts.length-1?(a.fallback_part_index++,a.fallback_startPart()):a.speech_onend())};\na.cancel=function(){a.checkAndCancelTimeout();a.fallbackMode?(null!=a.fallback_audio&&a.fallback_audio.pause(),a.clearFallbackPool()):(a.cancelled=!0,speechSynthesis.cancel())};a.voiceSupport=function(){return\"speechSynthesis\"in window};a.OnFinishedPlaying=function(b){if(null!=a.msgparameters&&null!=a.msgparameters.onend)a.msgparameters.onend()};a.setDefaultVoice=function(b){b=a.getResponsiveVoice(b);null!=b&&(a.default_rv=b)};a.mapRVs=function(){for(var b=0;b<a.responsivevoices.length;b++)for(var c=\na.responsivevoices[b],e=0;e<c.voiceIDs.length;e++){var h=a.voicecollection[c.voiceIDs[e]];if(1!=h.fallbackvoice){var f=a.getSystemVoice(h.name);if(null!=f){c.mappedProfile={systemvoice:f,collectionvoice:h};break}}else{c.mappedProfile={systemvoice:{},collectionvoice:h};break}}};a.getMatchedVoice=function(b){for(var c=0;c<b.voiceIDs.length;c++){var e=a.getSystemVoice(a.voicecollection[b.voiceIDs[c]].name);if(null!=e)return e}return null};a.getSystemVoice=function(b){var c=String.fromCharCode(160);b=\nb.replace(new RegExp(\"\\\\s+|\"+c,\"g\"),\"\");if(\"undefined\"===typeof a.systemvoices||null===a.systemvoices)return null;for(var e=0;e<a.systemvoices.length;e++)if(0===a.systemvoices[e].name.replace(new RegExp(\"\\\\s+|\"+c,\"g\"),\"\").localeCompare(b))return a.systemvoices[e];return null};a.getResponsiveVoice=function(b){for(var c=0;c<a.responsivevoices.length;c++)if(a.responsivevoices[c].name==b)return!0===a.responsivevoices[c].mappedProfile.collectionvoice.fallbackvoice||!0===a.fallbackMode?(a.fallbackMode=\n!0,a.fallback_parts=[]):a.fallbackMode=!1,a.responsivevoices[c];return null};a.Dispatch=function(b){if(a.hasOwnProperty(b+\"_callbacks\")&&null!=a[b+\"_callbacks\"]&&0<a[b+\"_callbacks\"].length){for(var c=a[b+\"_callbacks\"],e=0;e<c.length;e++)c[e]();return!0}var h=b+\"_callbacks_timeout\",f=b+\"_callbacks_timeoutCount\";a.hasOwnProperty(h)||(a[f]=10,a[h]=setInterval(function(){--a[f];(a.Dispatch(b)||0>a[f])&&clearTimeout(a[h])},50));return!1};a.AddEventListener=function(b,c){a.hasOwnProperty(b+\"_callbacks\")||\n(a[b+\"_callbacks\"]=[]);a[b+\"_callbacks\"].push(c)};a.addEventListener=a.AddEventListener;a.clickEvent=function(){if(a.iOS&&!a.iOS_initialized){a.log(\"Initializing iOS click event\");var b=new SpeechSynthesisUtterance(\" \");speechSynthesis.speak(b);a.iOS_initialized=!0}};a.isPlaying=function(){return a.fallbackMode?null!=a.fallback_audio&&!a.fallback_audio.ended&&!a.fallback_audio.paused:speechSynthesis.speaking};a.clearFallbackPool=function(){for(var b=0;b<a.fallback_audiopool.length;b++)null!=a.fallback_audiopool[b]&&\n(a.fallback_audiopool[b].pause(),a.fallback_audiopool[b].src=\"\");a.fallback_audiopool=[]};\"complete\"===document.readyState?a.init():document.addEventListener(\"DOMContentLoaded\",function(){a.init()});a.selectBest=function(a){for(var b=0;b<a.length;b++)if(null!=a[b])return a[b];return null};a.pause=function(){a.fallbackMode?null!=a.fallback_audio&&a.fallback_audio.pause():speechSynthesis.pause()};a.resume=function(){a.fallbackMode?null!=a.fallback_audio&&a.fallback_audio.play():speechSynthesis.resume()};\na.tts_speak=function(b){setTimeout(function(){a.cancelled=!1;speechSynthesis.speak(b)},.01)};a.setVolume=function(b){if(a.isPlaying())if(a.fallbackMode){for(var c=0;c<a.fallback_parts.length;c++)a.fallback_parts[c].volume=b;for(c=0;c<a.fallback_audiopool.length;c++)a.fallback_audiopool[c].volume=b;a.fallback_audio.volume=b}else for(c=0;c<a.utterances.length;c++)a.utterances[c].volume=b};a.onPartEnd=function(b){if(null!=a.msgparameters&&null!=a.msgparameters.onchuckend)a.msgparameters.onchuckend();\na.Dispatch(\"OnPartEnd\");b=a.utterances.indexOf(b.utterance);a.currentMsg=a.utterances[b+1]};a.onboundary=function(b){a.log(\"On Boundary\");a.iOS&&!a.onstartFired&&a.speech_onstart()};a.numToWords=function(b){function c(a){if(Array.isArray(a)){for(var b=0,c=Array(a.length);b<a.length;b++)c[b]=a[b];return c}return Array.from(a)}var e=function(){return function(a,b){if(Array.isArray(a))return a;if(Symbol.iterator in Object(a)){var c=[],d=!0,e=!1,f=void 0;try{for(var g=a[Symbol.iterator](),h;!(d=(h=g.next()).done)&&\n(c.push(h.value),!b||c.length!==b);d=!0);}catch(r){e=!0,f=r}finally{try{if(!d&&g[\"return\"])g[\"return\"]()}finally{if(e)throw f;}}return c}throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");}}(),h=function(a){return 0===a.length},f=function(a){return function(b){return b.slice(0,a)}},g=function(a){return function(b){return b.slice(a)}},d=function(a){return a.slice(0).reverse()},k=function(a){return function(b){return function(c){return a(b(c))}}},l=function(a){return!a},m=function q(a){return function(b){return h(b)?\n[]:[f(a)(b)].concat(c(q(a)(g(a)(b))))}},n=\" one two three four five six seven eight nine ten eleven twelve thirteen fourteen fifteen sixteen seventeen eighteen nineteen\".split(\" \"),p=\"  twenty thirty forty fifty sixty seventy eighty ninety\".split(\" \"),t=\" thousand million billion trillion quadrillion quintillion sextillion septillion octillion nonillion\".split(\" \"),u=function(a){var b=e(a,3);a=b[0];var c=b[1],b=b[2];return[0===(Number(b)||0)?\"\":n[b]+\" hundred \",0===(Number(a)||0)?p[c]:p[c]&&p[c]+\n\"-\"||\"\",n[c+a]||n[a]].join(\"\")},v=function(a,b){return\"\"===a?a:a+\" \"+t[b]};return\"number\"===typeof b?a.numToWords(String(b)):\"0\"===b?\"zero\":k(m(3))(d)(Array.from(b)).map(u).map(v).filter(k(l)(h)).reverse().join(\" \").trim()};a.getWords=function(b){for(var c=b.split(/\\s+/),e=0;e<c.length;e++)null!=(b=c[e].toString().match(/\\d+/))&&(c.splice(e,1),a.numToWords(+b[0]).split(/\\s+/).map(function(a){c.push(a)}));return c};a.getEstimatedTimeLength=function(b,c){var e=a.getWords(b),h=0,f=a.fallbackMode?1300:\n700;c=c||1;e.map(function(a,b){h+=(a.toString().match(/[^ ]/igm)||a).length});var g=e.length,d=60/a.WORDS_PER_MINUTE*c*1E3*g;5>g&&(d=c*(f+50*h));a.log(\"Estimated time length: \"+d+\" ms, words: [\"+e+\"], charsCount: \"+h);return d}},responsiveVoice=new ResponsiveVoice;\n\nmodule.exports = responsiveVoice;",
    "var Rollbar = require(\"rollbar\");\n\nvar rollbarConfig = {\n    accessToken: \"d2c7ea5208bf4b5b8df4c6f4ccc61fb6\",\n    captureUncaught: true,\n    payload: {\n        environment: \"development\",\n        client: {\n            javascript: {\n                source_map_enabled: true,\n                code_version: \"7a1fda0f13e8afe7f4d53876fbf97920a78b6e1d\",\n                // Optionally have Rollbar guess which frames the error was thrown from\n                // when the browser does not provide line and column numbers.\n                guess_uncaught_frames: true\n            }\n        }\n    }\n};\n\nvar rollbar = new Rollbar(rollbarConfig);\n\nmodule.exports = rollbar;",
    "var Hammer = require('hammerjs');\n\n// From https://blog.madewithenvy.com/build-your-own-touch-slider-with-hammerjs-af99665d2869\n\n// 1. Basic object for our stuff\nfunction Slider(selector, opts) {\n    this.sliderPanelSelector = '.slider-panel';\n    this.sensitivity = 25 // horizontal % needed to trigger swipe\n\n    // 2. Placeholder to remember which slide were on\n    this.activeSlide = 0;\n\n    // 3. Slide counter\n    this.slideCount = 0;\n    \n    this.onGoTo = opts.onGoTo;\n    this.onPanStart = opts.onPanStart;\n    \n    this.init(selector);\n}\n\n// 4. Initialization + event listener\nSlider.prototype.init = function(selector) {\n\n    // 4a. Find the container\n    this.sliderEl = document.querySelector(selector);\n\n    // 4b. Count stuff\n    this.slideCount = this.sliderEl.querySelectorAll(this.sliderPanelSelector).length;\n\n    // 4c. Set up HammerJS\n    var sliderManager = new Hammer.Manager(this.sliderEl);\n    var pan = new Hammer.Pan({\n        threshold: 5,\n        pointers: 0\n    })\n    sliderManager.add(pan);\n    var tap = new Hammer.Tap({\n        interval: 0\n    })\n    sliderManager.add(tap);\n    \n    pan.requireFailure(tap);\n    \n    var self = this;\n    \n    // Tap triggers a next slide change\n    sliderManager.on('tap', function(e) {\n        self.next();\n    });\n    \n    sliderManager.on('panstart', function(e) {\n        if (self.onPanStart) self.onPanStart();\n    });\n    \n    sliderManager.on('pan', function(e) {\n        \n        // 4d. Calculate pixel movements into 1:1 screen percents so gestures track with motion\n        var percentage = 100 / self.slideCount * e.deltaX / window.innerWidth;\n\n        // 4e. Multiply percent by # of slide were on\n        var percentageCalculated = percentage - 100 / self.slideCount * self.activeSlide;\n\n        // 4f. Apply transformation\n        self.sliderEl.style.transform = 'translateX( ' + percentageCalculated + '% )';\n\n        // 4g. Snap to slide when done\n        if (e.isFinal) {\n            if (e.velocityX > 1) {\n                self.goTo(self.activeSlide - 1);\n            } else if (e.velocityX < -1) {\n                self.goTo(self.activeSlide + 1)\n            } else {\n                if (percentage <= -(self.sensitivity / self.slideCount))\n                    self.goTo(self.activeSlide + 1);\n                else if (percentage >= (self.sensitivity / self.slideCount))\n                    self.goTo(self.activeSlide - 1);\n                else\n                    self.goTo(self.activeSlide);\n            }\n        }\n    });\n    \n    // Start slider in the middle, suppress change event\n    this.goTo(1, true);\n};\n\nSlider.prototype.next = function() {\n    this.goTo(this.activeSlide + 1);\n}\n\n// 5. Update current slide\nSlider.prototype.goTo = function(number, bSuppressChangeEvent) {\n    var bChanged = this.activeSlide !== number;\n    \n    // 5a. Stop it from doing weird things like moving to slides that dont exist\n    if (number < 0) {\n        this.activeSlide = 0;\n    }\n    else if (number > this.slideCount - 1) {\n        this.activeSlide = this.slideCount - 1;\n    }\n    else {\n        this.activeSlide = number;\n    }\n    // 5b. Apply transformation & smoothly animate via .is-animating CSS\n    this.sliderEl.classList.add('is-animating');\n    var percentage = -(100 / this.slideCount) * this.activeSlide;\n    this.sliderEl.style.transform = 'translateX( ' + percentage + '% )';\n    clearTimeout(this.timer);\n    \n    var self = this;\n    this.timer = setTimeout(function() {\n        self.sliderEl.classList.remove('is-animating');\n    \n        // 6. Rearrange slides\n        // 6a. If on last slide, move first slide to end\n        if (self.activeSlide == self.slideCount - 1) {\n            var slides = self.sliderEl.querySelectorAll(self.sliderPanelSelector);\n            self.sliderEl.appendChild(slides[0])\n            self.activeSlide--;\n            var percentage = -(100 / self.slideCount) * self.activeSlide;\n            self.sliderEl.style.transform = 'translateX( ' + percentage + '% )';\n        }\n        // 6b. If on first slide, move last slide to front\n        if (self.activeSlide == 0) {\n            var slides = self.sliderEl.querySelectorAll(self.sliderPanelSelector);\n            self.sliderEl.insertBefore(slides[slides.length - 1], slides[0])\n            self.activeSlide++;\n            var percentage = -(100 / self.slideCount) * self.activeSlide;\n            self.sliderEl.style.transform = 'translateX( ' + percentage + '% )';\n        }\n    }, 400);\n    \n    // Slide change callback\n    if (this.onGoTo && !bSuppressChangeEvent) this.onGoTo(bChanged);\n};\n\nmodule.exports = Slider;"
  ]
}